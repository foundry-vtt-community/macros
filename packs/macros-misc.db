{"_id":"3byKEzTIX7jnn0DX","name":"Folder To Rollable Table","permission":{"default":0,"y5gmtwxmW3A5ZuOP":3},"type":"script","flags":{},"scope":"global","command":"// Take the entries of a folder and turn it into a rollable table.\n// NOTE: you must click the \"Normalize Result Weights\" button (scale icon) after import.\n// Author: @Atropos#3814\n\n// name of folder whos entities you wish to push into a rollable table.\nconst folder = game.folders.getName(\"Herbalism & Alchemy\");\n// name of table you will be overwriting\nconst table = game.tables.getName(\"Common Ingredients\");\n// change this to match the entity type you are importing.\n// Actor, Item, Scene, JournalEntry, Macro, RollTable, Playlist\nconst entityType = \"Item\"\n\nconst items = folder.entities;\nconst results = folder.entities.map(i => {\n  return {\n    text: i.data.name,\n    type: 1,\n    collection: \"Item\",\n    resultId: i.data._id,\n    img: i.data.img,\n    weight: 1,\n    range: [1, 1],\n    drawn: false\n  }\n});\nawait table.createEmbeddedEntity(\"TableResult\", results);\n","author":"y5gmtwxmW3A5ZuOP","img":"icons/svg/dice-target.svg","actorIds":[]}
{"_id":"525JVjJGyjIH5gv2","name":"Log Troubleshooting MSG To Console","type":"script","author":"y5gmtwxmW3A5ZuOP","img":"icons/svg/dice-target.svg","scope":"global","command":"// Courtesy of @fohswe\n// Logs a troubleshooting message to the browser console.\n// (You can usually view the browser console using F12.)\n\nconst gl = canvas.app.renderer.context.gl;\n\nconsole.log(\n`=== Start of troubleshooting ===\nBackground image: ${canvas.dimensions.width}x${canvas.dimensions.height}\nNumber of walls: ${canvas.scene.walls.size}\nNumber of selected vision sources: ${canvas.sight.sources.size}\nNumber of light sources: ${canvas.lighting.sources.size}\nWebGL MAX_TEXTURE_SIZE: ${gl.getParameter(gl.MAX_TEXTURE_SIZE)}\n`\n);","folder":null,"sort":0,"permission":{"default":0,"y5gmtwxmW3A5ZuOP":3},"flags":{}}
{"_id":"5LiZJnGQpu0g9mB0","name":"Polygon Drawing To Walls","type":"script","author":"y5gmtwxmW3A5ZuOP","img":"icons/svg/dice-target.svg","scope":"global","command":"/**\n * Converts selected polygon drawing to a wall\n * @Author: cole#9640\n */\n\nfunction toRadians(degrees)\n{\n  var pi = Math.PI;\n  return degrees * (pi/180);\n}\n\n\nlet drawings = canvas.drawings.controlled;\n\ndrawings = drawings.filter(drawing =>  {\n    if (!drawing.isPolygon) {\n        ui.notifications.warn(`Drawing \"${drawing.data._id}\" is not a polygon, skipping`);\n        return false;\n    }\n    return true;\n});\n\nif (drawings.length) {\n    const newWalls = drawings.flatMap((drawing) => {\n        const { x, y, width, height } = drawing.data;\n        const xCenterOffset = width/2;\n        const yCenterOffset = height/2;\n        \n        const θ = toRadians(drawing.data.rotation);\n        const cosθ = Math.cos(θ);\n        const sinθ = Math.sin(θ);\n        \n        const points = drawing.data.points.map((point) => {\n            const offsetX = point[0] - xCenterOffset;\n            const offsetY = point[1] - yCenterOffset;\n            const rotatedX = (offsetX * cosθ - offsetY * sinθ);\n            const rotatedY = (offsetY * cosθ + offsetX * sinθ);\n            return [rotatedX + x + xCenterOffset, rotatedY + y + yCenterOffset];\n        });\n        \n        return points.slice(0, points.length - 1)\n            .map((point, i) => {\n                return { c: point.concat(points[i + 1]) };\n            });\n    });\n    \n    canvas.scene.createEmbeddedDocuments(\"Wall\", newWalls);\n    canvas.walls.activate();\n} else {\n    ui.notifications.error(\"No polygon drawings selected!\");\n}","folder":null,"sort":0,"permission":{"default":0,"y5gmtwxmW3A5ZuOP":3},"flags":{}}
{"name":"Find Selected Wall IDs","type":"script","author":"y5gmtwxmW3A5ZuOP","img":"icons/svg/dice-target.svg","scope":"global","command":"for (const [i, wall] of canvas.walls.controlled.entries()) {\n\tconst text = new PIXI.Text(`${i} - ${wall.id}`);\n\ttext.anchor.set(0.5);\n\ttext.x = (wall.data.c[0] + wall.data.c[2]) / 2;\n\ttext.y = (wall.data.c[1] + wall.data.c[3]) / 2;\n\ttext.name = wall.id;\n\ttext.style = new PIXI.TextStyle({ fill: 0xffffff, dropShadow: true, fontSize: 20 });\n\twall.addChild(text);\n}\n\nconst wallIds = canvas.walls.controlled.map((x) => x.id);\nconst wallsToExport = new Set(wallIds);\n\nnew Dialog({\n\ttitle: \"Selected Wall IDs\",\n\tcontent: `\n${[...wallIds.entries()].map(([i, x]) => `<div><input data-i=\"${i}\" checked type=\"checkbox\"> ${i}: <b>${x}</b></div>`).join(\"\")}\n<p style=\"text-align:right\">\n<span class=\"span-copy-text\" style=\"display:none;opacity:0.7\">(copied) </span>\n<button style=\"width:auto\" class=\"button-copy-text\">Copy JS Array</button>\n</p>`,\n\tbuttons: { close: { label: \"Close\" } },\n\tclose() {\n\t\tfor (const wall of canvas.walls.placeables) {\n\t\t\tconst child = wall.children.find((w) => w.name === wall.id);\n\t\t\tif (child) wall.removeChild(child);\n\t\t}\n\t},\n\trender(html) {\n\t\thtml.find(`input[type=checkbox]`).on(\"change\", function () {\n\t\t\tconst $this = $(this);\n\t\t\tconst index = +$this.attr(\"data-i\");\n\t\t\tif ($this.prop(\"checked\")) wallsToExport.add(wallIds[index]);\n\t\t\telse wallsToExport.delete(wallIds[index]);\n\t\t});\n\n\t\thtml.find(\".button-copy-text\").on(\"click\", async () => {\n\t\t\tconst toCopy = JSON.stringify(wallIds.filter((w) => wallsToExport.has(w)));\n\t\t\tawait navigator.clipboard.writeText(toCopy);\n\t\t\thtml.find(\".span-copy-text\").css(\"display\", \"unset\");\n\t\t});\n\t},\n}).render(true);","folder":null,"sort":0,"permission":{"default":0,"y5gmtwxmW3A5ZuOP":3},"flags":{"core":{"sourceId":"Macro.JpHGLlRLS6ntLfp4"}},"_id":"8Mu55GZEVVid1UOh"}
{"_id":"8iEx21HSVOmkbBFE","name":"Combat Tracker AC HP","permission":{"default":0,"y5gmtwxmW3A5ZuOP":3},"type":"script","flags":{},"scope":"global","command":"// Adds the actor's AC to the combat tracker. Then toggles between HP and AC\nconst a = \"attributes.ac.value\";\nconst b = \"attributes.hp.value\";\n\nif (game.combat.settings.resource == a) {\n  game.settings.set('core', 'combatTrackerConfig', {resource: b, skipDefeated: true});\n} else {\n  game.settings.set('core', 'combatTrackerConfig', {resource: a, skipDefeated: true});\n}\nui.combat.updateTrackedResources();\n","author":"y5gmtwxmW3A5ZuOP","img":"icons/svg/dice-target.svg","actorIds":[]}
{"name":"Auto Script","type":"script","author":"y5gmtwxmW3A5ZuOP","img":"icons/svg/dice-target.svg","scope":"global","command":"/*\n *  Author: tylers1st <https://github.com/tylers1st>\n *  Version: 0.1\n *\n *  Desc: This is a macro designed to automate a set of lines from a journal into a token as chat bubbles\n *  Setup: Make a journal with a unique name. Then make the script (be sure to create a new line for each line. For those\n *  who would like to know, it's split by \"</p>\"). The formatting is \n *  <token's name>:\n *  <token's name>: \n * \n *  Once you've created the journal and the script using the above formatting, you can either select tokens on the currently viewed scene\n *  and actvate the macro, then enter the journal's name, or if you don't select any tokens, you can manually add their names separated by a comma and no spaces\n *  \n *  After that the only thing left to do is confirm that everything is correct and press \"Confirm\"\n *  A small window will show up for each token that was selected and every time you press the button, the next line will be said by the token. \n *\n *\n *  If you can't get this to work, first be sure that it is formatted correctly. \n *  1. The token's name in the journal and the token itself must be exactly the same. It is case sensitive\n *  2. In the journal, immediately following the token's name on each line must be a colon\n *  3. If this still doesn't work, I have a discord server https://discord.gg/FXYbq7kjcH for if you have any questions\n */\n\n\n// checking if there are any controlled tokens in the currently viewed scene\nif (canvas.tokens.controlled.length < 1){\n  let d = new Dialog({\n    title: 'Auto Script Reader',\n    content: `\n      <form class=\"flexcol\">\n        <div class=\"form-group\">\n          <label for=\"tokenNameInput\">Token Name</label>\n          <input type=\"text\" name=\"tokenNameInput\" placeholder=\"Enter Token's Name\">\n        </div>\n        <div class=\"form-group\">\n          <label for=\"journalInput\">Journal Name</label>\n          <input type=\"text\" name=\"journalInput\" placeholder=\"Enter Journal\">\n        </div>\n      </form>\n      `,\n      buttons: {\n        cancel: {\n          icon: '<i class=\"fas fa-times\"></i>',\n          label: 'Cancel'\n        },\n        confirm: {\n          icon: '<i class=\"fas fa-check\"></i>',\n          label: 'Confirm',\n          callback: (html) => {\n            let tokenInput = html.find(`[name=\"tokenNameInput\"]`).val();\n            let journalName = html.find('[name=\"journalInput\"]').val();\n            console.log(tokenInput, journalName);\n            tokenInput = tokenInput.split(\",\");\n            var spkr; //The object\n            for (const tokenNameAtIndex of tokenInput){\n              console.log(tokenNameAtIndex.name + \" is current speaker in for loop\");\n              spkr = canvas.tokens.objects.children.find(e => e.name === tokenNameAtIndex); // Finds a token on the current screen with the same name as the dialog input\n\n              let messageIndex = 0;\n              let messageList = game.journal.getName(journalName).data.content.split(`<p>${spkr.name}:`);\n              console.log(`attempted to load \\n\\`game.journal.getName(${journalName}).data.content.split(\\`<p>${spkr.name}:\\`)`);\n              let messageArr = []; //This will be the actual list of messages to send\n              let arrTemp; //temporary array delcaration\n\n              for(let i = 0; i < messageList.length; i++){ // for each message in the original list, phase out text past the next </p>\n                arrTemp = messageList[i].split(`</p>`);\n                console.log(`Attempted to tokenize phrase \\\"${messageList[i]}\\\" \\n|| -----AND GOT----- ||\\n \\\"${arrTemp}\\\"`);\n                messageArr[i] = i == 0 ? arrTemp[1] : arrTemp[0];\n                if (i == 0) console.log(`added \\\"${arrTemp[1]}\\\" to message array`);\n                else console.log(`added \\\"${arrTemp[0]}\\\" to message array`);\n              }\n              console.log(`||messageIndex|| = ${messageIndex}\\n||messageArr|| = ${messageArr}`);\n\n              tokenUpdaterFunction(spkr,messageArr,messageIndex+1);\n              }\n            }\n          }\n        },\n    default: 'yes',\n    close: () => {\n      console.log('Example Dialog Closed');\n    },\n  }).render(true);\n}\nelse if (canvas.tokens.controlled.length >= 1){\n  let d = new Dialog({\n    title: 'Auto Script Reader',\n    content: `\n      <form class=\"flexcol\">\n        <div class=\"form-group\">\n          <label for=\"journalInput\">Journal Name</label>\n          <input type=\"text\" name=\"journalInput\" placeholder=\"Enter Journal\">\n          </div>\n      </form>\n      `,\n      buttons: {\n        cancel: {\n          icon: '<i class=\"fas fa-times\"></i>',\n          label: 'Cancel'\n        },\n        confirm: {\n          icon: '<i class=\"fas fa-check\"></i>',\n          label: 'Confirm',\n          callback: (html) => {\n            let controlledTokens = canvas.tokens.controlled;\n            let journalName = html.find('[name=\"journalInput\"]').val();\n            console.log(controlledTokens, journalName);\n            var spkr;\n\n            for (const tokenNameAtIndex of controlledTokens){\n              console.log(tokenNameAtIndex.name + \" is current speaker in for loop\");\n              spkr = tokenNameAtIndex; // Finds a token on the current screen with dialog input\n\n              let messageIndex = 0;\n              let messageList = game.journal.getName(journalName).data.content.split(`<p>${spkr.name}:`);\n              console.log(`attempted to load \\n\\`game.journal.getName(${journalName}).data.content.split(\\`<p>${spkr.name}:\\`)`);\n              let messageArr = []; //This will be the actual list of messages to send\n              let arrTemp;\n\n              for(let i = 0; i < messageList.length; i++){ //for each message in the original list, phase out text past the next </p>\n                arrTemp = messageList[i].split(`</p>`);\n                console.log(`Attempted to tokenize phrase \\\"${messageList[i]}\\\" \\n|| and got ||\\n \\\"${arrTemp}\\\"`);\n                messageArr[i] = i == 0 ? arrTemp[1] : arrTemp[0];\n                if (i == 0) console.log(`added \\\"${arrTemp[1]}\\\" to message array`);\n                  else console.log(`added \\\"${arrTemp[0]}\\\" to message array`);\n                }\n                console.log(`||messageIndex|| = ${messageIndex}\\n ||messageArr|| = ${messageArr}`);\n\n                tokenUpdaterFunction(spkr,messageArr,messageIndex+1);\n              }\n          }\n        }\n      },\n    default: 'yes',\n    close: () => {\n      console.log('Example Dialog Closed');\n    },\n  }).render(true);\n}\n/**\n * @param {Object} tokenObject The token you wish to use\n * @param {(string|string[])} messageArray The array of messages tokenObject is mean to speak\n * @param {number} messagIndexParam The messageArray index to start on\n *\n */\nasync function tokenUpdaterFunction(speaker, messageArray,messageIndexParam){\n  let tokenUpdater = new Dialog({\n    title: `${speaker.name}`,\n    content: 'Do you want to continue to the next line?',\n    buttons: {\n      Next:{\n        label: \"<p>Next</p>\",\n        callback: () => {\n          canvas.hud.bubbles.say(speaker, messageArray[messageIndexParam]);\n          console.log(`speaker = ${speaker.name} || messageArray[messageIndexParam] = ${messageArray[messageIndexParam+1]}`);\n          messageIndexParam++;\n          if (messageIndexParam < messageArray.length){\n            tokenUpdater.render(true);\n          }\n        }\n      }\n    },\n    },\n    {\n      id: 'updater'\n    }\n  ).render(true);\n}","folder":null,"sort":0,"permission":{"default":0,"y5gmtwxmW3A5ZuOP":3},"flags":{"core":{"sourceId":"Macro.43dreAJcceAuyLIg"}},"_id":"BT9KV43ln8Ey0xQE"}
{"_id":"BqcD9aq88kWU67Uf","name":"Equip Unequip Shield","type":"script","author":"y5gmtwxmW3A5ZuOP","img":"icons/svg/dice-target.svg","scope":"global","command":"/**\n * D&D5e biased, paths may be wrong in other systems!\n * Equips/unequips an item. Make sure you change the variables at the top (as required).\n * This script will also error check to make sure items exist and tokens are select. \n * Chat and token icon display options can be set as desired.\n * Author: Zapgun, Freeze#2689 (fix for v9)\n */\n\nconst itemName = 'Shield'; // <--- Change this to the *exact* item name (capitals count!)\nconst sendToChat = true; // <--- Change to 'true' or 'false' to display a chat message about equipping\nconst displayIcon = true; // <--- Change to 'true' or 'false' to display an effect icon when equipped\nconst effectIconPath = 'icons/svg/shield.svg'; // <--- Add the effect icon you want to appear when equipped\n\nlet toggleResult = false;\n\nif (!actor) {\n\tui.notifications.warn('You need to select a token before using this macro!');\n} else {\n\n\tconst myItem = actor.items.getName(itemName);\n\tif (myItem) {\n\t\tlet item = actor.items.get(myItem.id);\n\t\tlet attr = \"data.equipped\";\n\t\tlet equipped = getProperty(item.data, attr);\n\t\tif (sendToChat) {\n\t\t\tif (!equipped) {\n\t\t\t\tchatMessage(actor.name + ' <b>equips</b> their <i>' + ' ' + itemName + '</i>');\n\t\t\t} else {\n\t\t\t\tchatMessage(actor.name + ' <b>un-equips</b> their <i>' + ' ' + itemName + '</i>');\n\t\t\t}\n\t\t}\n\t\titem.update({ [attr]: !getProperty(item.data, attr) });\n\n\t\t// mark/unmark character's token with an effect icon when displayToken is true\n\t\t(async () => {\n\t\t\tif (displayIcon) {\n\t\t\t\ttoggleResult = await token.toggleEffect(effectIconPath, { active: !equipped });\n\t\t\t\t//\tif (toggleResult == equipped) token.toggleEffect(effectIconPath, {active: equipped});  \n\t\t\t}\n\t\t})();\n\n\t} else {\n\t\tui.notifications.warn(\"No item named '\" + itemName + \"' found on character!\");\n\t}\n}\n\nfunction chatMessage(messageContent) {\n\t// create the message\n\tif (messageContent !== '') {\n\t\tlet chatData = {\n\t\t\tuser: game.user.id,\n\t\t\tspeaker: ChatMessage.getSpeaker(),\n\t\t\tcontent: messageContent,\n\t\t};\n\t\tChatMessage.create(chatData, {});\n\t}\n}","folder":null,"sort":0,"permission":{"default":0,"y5gmtwxmW3A5ZuOP":3},"flags":{}}
{"name":"Announce Round Number","permission":{"default":0,"y5gmtwxmW3A5ZuOP":3},"type":"script","flags":{"core":{"sourceId":"Macro.V1p6LWoKnv7croAd"}},"scope":"global","command":"let messageContent = `<hr><div style=\"color: black; font-size: 1.75em; font-weight: bold;\">ROUND ${game.combat.round}</div><hr>`\nChatMessage.create({content: messageContent});","author":"y5gmtwxmW3A5ZuOP","img":"icons/svg/dice-target.svg","actorIds":[],"_id":"CVbowNiiiwqmADGY"}
{"_id":"Cp6zQmvC9KSCEo1s","name":"Toggle Playlist","type":"script","author":"y5gmtwxmW3A5ZuOP","img":"icons/svg/dice-target.svg","scope":"global","command":"// Get all playlists from contents and prepare choices\n\nlet optionsText = game.playlists.reduce((acc, e) => acc += `<option value=\"${e.id}\">${e.name}</option>`, ``);\nlet _applyChanges = false;\n\nlet d = new Dialog({\n    title: \"Playlist Toggle\",\n    content: `\n        <form>\n            <div class=\"form-group\">\n                <label>Select Playlist:</label>\n                <select id=\"playlist-selection\" name=\"playlist-selection\">` + optionsText + `</select>\n            </div>\n        </form>\n        `,\n    buttons: {\n        one: {\n            icon: '<i class=\"fas fa-check\"></i>',\n            label: \"Playlist Toggle\",\n            callback: () => _applyChanges = true\n        },\n        two: {\n            icon: '<i class=\"fas fa-times\"></i>',\n            label: \"Cancel\",\n            callback: () => _applyChanges = false\n        }\n    },\n    default: \"Cancel\",\n    close: html => {\n        if (_applyChanges) {\n            let _plId = html.find('[name=playlist-selection]')[0].value;\n            let _pl = game.playlists.get(_plId);\n            if(_pl) {\n                if (_pl.playing) {\n                    // turn off\n                    _pl.stopAll();\n                } else {\n                    // turn on\n                    _pl.playAll();\n                }\n            }\n            else {\n                ui.notifications.error(`No valid playlist selected.`);\n            }            \n        }\n    }\n}).render(true);","folder":null,"sort":0,"permission":{"default":0,"y5gmtwxmW3A5ZuOP":3},"flags":{}}
{"_id":"JV1pRTUy2LuaAh0L","name":"Folder to Compendium","permission":{"default":0,"y5gmtwxmW3A5ZuOP":3},"type":"script","flags":{},"scope":"global","command":"/**\n * Import folder into writable compendium. Locked compendiums will not show as an option.\n * Folder type is optional, however will help if you have the same folder name across multiple system types.\n * Also contains options to store subfolder contents, update existing records (or only add new), and delete duplicate records.\n * Author: KrishMero#1792\n */\n\nlet packOptions = game.packs.filter(pack => !pack.locked).map(pack => `<option value=\"${pack.collection}\">${pack.title}</option>`);\nlet entityType = COMPENDIUM_ENTITY_TYPES.map(type => `<option value=\"${type}\">${type}</option>`);\nconst form = `\n  <div style=\"display: inline-block; width: 100px\">Folder:</div>\n  <input type=\"string\" id=\"folderName\">\n  <br />\n\n  <div style=\"display: inline-block; width: 100px\">Folder Type:</div>\n  <select id=\"entityType\" />\n    <option value=\"\">--</option>\n    ${entityType}\n  </select>\n  <br />\n\n  <div style=\"display: inline-block; width: 100px\">Compendium:</div>\n  <select id=\"destinationPack\" />\n    ${packOptions}\n  </select>\n  <br />\n\n  <label>\n    <input type=\"checkbox\" id=\"recurse\" checked/>\n    Store subfolders too\n  </label>\n  <br />\n\n  <label>\n    <input type=\"checkbox\" id=\"update\" checked/>\n    Update existing records (unchecked = only add new)\n  </label>\n  <br />\n\n  <label>\n    <input type=\"checkbox\" id=\"delete\" checked/>\n    Delete duplicates\n  </label>\n`;\n\nconst dialog = new Dialog({\n  title: \"Store folder in compendium\",\n  content: form,\n  buttons: {\n    use: {\n      label: \"Apply\",\n      callback: storeFolder\n    }\n  }\n}).render(true);\n\nfunction storeFolder(html) {\n  const folderName = html.find(`input#folderName`)[0].value;\n  const folderType = html.find(`select#entityType`)[0].value;\n  const destinationPack = html.find(`select#destinationPack`)[0].value;\n  const recurse = html.find(`input#recurse`)[0].checked;\n  const update = html.find(`input#update`)[0].checked;\n  const deleteRecords = html.find(`input#delete`)[0].checked;\n  \n  let folders = game.folders.filter(f => f.name === folderName);\n  if (folderType) {\n    folders = folders.filter(f => f.type === folderType);\n  }\n  if (folders.length === 0) {\n    ui.notifications.error(`Your world does not have any folders named '${folderName}'.`);\n  }\n  else if(folders.length > 1) {\n    ui.notifications.error(`Your world has more than one folder named ${folderName}`) \n  }\n  else {\n    console.log(`storing in ${destinationPack}`);\n    let packObject = game.packs.get(destinationPack);\n    storeRecursively(folders[0], packObject, recurse, update, deleteRecords);\n    ui.notifications.notify(`'${folderName}' stored successfully in '${packObject.title}'.`);\n  }\n}\n\nfunction storeRecursively(currentFolder, packObject, recurse, update, deleteRecords) {\n  console.log('store recursively for ' + currentFolder.name);\n  if (currentFolder.content) {\n    currentFolder.content.map(item => {\n      console.debug(\"  Item:\", item.data.name);\n      let existingRecords = packObject.index.filter(i => i.name === item.data.name);\n      if (item.data.name === 'Augury') {\n        console.log(existingRecords);\n        console.log(existingRecords.length);\n      }\n\n      // Delete all but the first duplicate.\n      if(existingRecords.length > 1) {\n        if (deleteRecords) {\n          console.log(existingRecords);\n          existingRecords.shift();\n          existingRecords.map(record => packObject.deleteEntity(record._id));\n        } else {\n          console.log(`Skipped: ${existingRecords[0].name}`)\n          ui.notifications.error(`Can't store '${existingRecords[0].name}' as multiple records were found. Delete the extras or check 'Delete duplicates'. Logged to console.`);\n        }\n      }\n\n      if (existingRecords.length === 1 && update) {\n        packObject.updateEntity(existingRecords[0]);\n      } else if (!existingRecords.length) {\n        packObject.createEntity(item);\n      }\n      \n    });\n  }\n\n  if (currentFolder.children && recurse) {\n    currentFolder.children.map(({ data }) => {\n      storeRecursively(\n        game.folders.entities.filter(f => f.data._id == data._id)[0],\n        packObject,\n        recurse, \n        update,\n        deleteRecords\n      );\n    });\n  }\n}\n","author":"y5gmtwxmW3A5ZuOP","img":"icons/svg/dice-target.svg","actorIds":[]}
{"_id":"QTDeg4HOYCAmr4dK","name":"Whisper Players","permission":{"default":0,"y5gmtwxmW3A5ZuOP":3},"type":"script","flags":{},"scope":"global","command":"/** \n * Provides a dialog to whisper specific players. If you have tokens selected, it will automatically default to try and whisper those players.\n * @Author: Nelson#3570\n */\n\nlet applyChanges = false;\n\nlet users = game.users.filter(user => user.active);\nlet checkOptions = \"\"\nlet playerTokenIds = users.map(u => u.character?.id).filter(id => id !== undefined);\nlet selectedPlayerIds = canvas.tokens.controlled.map(token => {\n  if (playerTokenIds.includes(token.actor.id)) return token.actor.id;\n});\n\n// Build checkbox list for all active players\nusers.forEach(user => {\n  let checked = !!user.character && selectedPlayerIds.includes(user.character.id) && 'checked';\n  checkOptions+=`\n    <br>\n    <input type=\"checkbox\" name=\"${user.id}\" id=\"${user.id}\" value=\"${user.name}\" ${checked}>\\n\n    <label for=\"${user.id}\">${user.name}</label>\n  `\n});\n\nnew Dialog({\n  title:\"Whisper\",\n  content:`Whisper To: ${checkOptions} <br>\n    <label for=\"message\">Message:</label>\n    <textarea id=\"message\" name=\"message\" rows=\"4\" cols=\"50\"></textarea><br>`,\n  buttons:{\n    whisper:{   \n      label:\"Whisper\",\n      callback: (html) => createMessage(html)\n    }\n  }\n}).render(true);\n\nfunction createMessage(html) {\n  var targets = [];\n  // build list of selected players ids for whispers target\n  for ( let user of users ) {\n    if (html.find('[name=\"'+user.id+'\"]')[0].checked){\n      applyChanges=true;\n      targets.push(user.id);\n    }\n    var messageText = html.find('[name=\"message\"]')[0].value\n  }\nif(!applyChanges)return;\n  ChatMessage.create({\n    content: messageText,\n    whisper: targets\n  });\n}","author":"y5gmtwxmW3A5ZuOP","img":"icons/svg/dice-target.svg","actorIds":[]}
{"_id":"Rd6O7mlOv0EIaviE","name":"Max NPC HP","type":"script","author":"y5gmtwxmW3A5ZuOP","img":"icons/svg/dice-target.svg","scope":"global","command":"// A simple macro for maximizing NPC HP\n\n// Choose one of the following to update by uncommenting one of the two lines below\n//const actors = game.actors; // update all actors in the sidebar\nconst actors = canvas.tokens.controlled.map((t) => t.actor); // update all selected tokens\n\nactors\n  .filter((actor) => actor.type === \"npc\")\n  .forEach(async (actor) => {\n    const formula = actor.data.data?.attributes?.hp?.formula;\n    if (!formula) return;\n\n    const roll = await new Roll(formula).roll({ maximize: true });\n    const data = {\n      \"data.attributes.hp.value\": roll.total,\n      \"data.attributes.hp.max\": roll.total,\n    };\n    await actor.update(data);\n  });","folder":null,"sort":0,"permission":{"default":0,"y5gmtwxmW3A5ZuOP":3},"flags":{"core":{"sourceId":"Macro.rrLvfkbrPDDoaG7H"}}}
{"name":"Draw Walls Around Drawing","type":"script","scope":"global","author":"wCsoNxA9I9elUaGF","img":"icons/svg/dice-target.svg","command":"/**\n * Macro to draw walls around Rectangles, Ellipses and Polygons.\n * Just select one or multiple drawings and klick the marcro.\n */\n/** Constants */\nconst NUMPOINTS = 15; //Number of points for drawing a wall around an ellipse (NUMPOINTS is for one quarter of the ellipse)\n\nlet drawings = canvas.drawings.controlled;\ndrawings = drawings.map(drawing =>{\n    switch (drawing.type) {\n        case \"p\": { // In case of the drawing being a polygon\n            let { _id, rotation, x, y} = drawing;\n            let flatPoints = drawing.document.shape.points;\n            let points = []\n            for (let i = 0; i != flatPoints.length; i+=2){\n                points.push([flatPoints[i], flatPoints[i+1]])\n            }\n            points.push([flatPoints[0], flatPoints[1]])\n            \n            let { width, height } = drawing.shape;\n            return { id: _id, valid: true, points, rotation, x, y, width, height };\n        }\n        case \"r\": { // In case of the drawing being a rectangle\n            let { _id, rotation, x, y} = drawing;\n            let { width, height } = drawing.shape;\n            let strokeWidth = drawing.document.strokeWidth;\n            const points = [\n                [0 + (strokeWidth / 2), 0 + (strokeWidth / 2)],\n                [width - (strokeWidth / 2), 0 + (strokeWidth / 2)],\n                [width - (strokeWidth / 2), height - (strokeWidth / 2)],\n                [0 + (strokeWidth / 2), height - (strokeWidth / 2)],\n                [0 + (strokeWidth / 2), 0 + (strokeWidth / 2)],\n            ];\n            return { id: _id, valid: true, points, rotation, x, y, width, height };\n        }\n        case \"e\" : { // In case of the drawing being an ellipse\n            let {width, height} = drawing.shape;\n            let {_id, rotation, x, y} = drawing\n            let hw = Math.max(Math.abs(width/2), 0);\n            let hh = Math.max(Math.abs(height/2), 0);\n            let center = [hw, hh];\n            let points = [];\n            //Generate lower right quarter\n            for (let i = 0; i != NUMPOINTS-1; i++){\n                let Theta = Math.PI/2 * i / NUMPOINTS;\n                Fi = Math.PI/2 - Math.atan(Math.tan(Theta) * center[0]/center[1]);\n                x1 = center[0] + Math.round(center[0] * Math.cos(Fi));\n                y1 = center[1] + Math.round(center[1] * Math.sin(Fi));\n                points.push([x1,y1]);\n            }\n\n            let pointsQ = [...points];\n            points.push([hw*2, hh])\n            \n            // Mirror up\n            pointsQ.reverse().forEach(function(p){\n                points.push([p[0], hh*2-p[1]]);\n            })\n            pointsQ = [...points];\n            pointsQ.pop();\n            // Mirrior left\n            pointsQ.reverse().forEach(function(p){\n                points.push([hw*2-p[0], p[1]]);\n            })\n            \n            return { id: _id, valid: true, points, rotation, x, y, width, height };\n        }\n        default:\n            return { id: drawing._id, valid: false };\n    }\n}).filter(drawing => {  // Check if a drawing came out as valid for processing.\n    if (!drawing.valid) {\n        ui.notifications.warn(`Drawing \"${drawing.id}\" is not a valid drawing type!`);\n        return false;\n    }\n    return true;\n});\n\nif (drawings.length) {\n    const newWalls = drawings.flatMap((drawing) => {\n        const { x, y, width, height } = drawing;\n        const xCenterOffset = width / 2;\n        const yCenterOffset = height / 2;\n        \n        const θ = Math.toRadians(drawing.rotation);\n        const cosθ = Math.cos(θ);\n        const sinθ = Math.sin(θ);\n        \n        const points = drawing.points.map((point) => {\n            const offsetX = point[0] - xCenterOffset;\n            const offsetY = point[1] - yCenterOffset;\n            const rotatedX = (offsetX * cosθ - offsetY * sinθ);\n            const rotatedY = (offsetY * cosθ + offsetX * sinθ);\n            return [rotatedX + x + xCenterOffset, rotatedY + y + yCenterOffset];\n        });\n        \n        return points\n            .slice(0, points.length - 1)\n            .map((point, i) => ({ c: point.concat(points[i + 1]) }));\n    });\n    canvas.scene.createEmbeddedDocuments(\"Wall\", newWalls); // Create Walls\n    canvas.walls.activate(); // Activate Walls layer\n} else {\n    ui.notifications.error(\"No drawings selected!\");\n}\n\n/**\n * TODO\n * - Check if there is already a wall for a drawing to recreate it instead of creating a second one. Might be possible with IDs.\n * - Add free had wall drawing to the functions, to convert a free drawing to a wall.\n */","ownership":{"default":0,"wCsoNxA9I9elUaGF":3},"flags":{"core":{"sourceId":"Macro.MmDC4LH92vnqglvG"}},"_stats":{"systemId":"dnd5e","systemVersion":"2.0.3","coreVersion":"10.288","createdTime":1666377592539,"modifiedTime":1666377611546,"lastModifiedBy":"wCsoNxA9I9elUaGF"},"folder":null,"sort":0,"_id":"UIs8L0VCxgplAFdP"}
{"_id":"Vhj3ctf5cAufQMnM","name":"Lock and Unlock Players","type":"script","author":"y5gmtwxmW3A5ZuOP","img":"icons/svg/dice-target.svg","scope":"global","command":"async function updateRoles(fromRole, toRole) {\n    const updates = game.users.filter(u => u.role === fromRole).map(u => ({_id: u.id, role: toRole}))\n    await User.updateDocuments(updates)\n}\nnew Dialog({\n    title: `Lock or unlock all players?`,\n    default: 'cancel',\n    buttons: {\n        unlock: {\n            icon: '<i class=\"fas fa-unlock\"></i>',\n            label: 'Unlock',\n            callback: () => updateRoles(CONST.USER_ROLES.NONE, CONST.USER_ROLES.PLAYER)\n        },\n        lock: {\n            icon: '<i class=\"fas fa-lock\"></i>',\n            label: 'Lock',\n            callback: () => updateRoles(CONST.USER_ROLES.PLAYER, CONST.USER_ROLES.NONE)\n        },\n        cancel: {\n            icon: '<i class=\"fas fa-eject\"></i>',\n            label: 'Cancel',\n            callback: () => {}\n        }\n    }\n}).render(true)","folder":null,"sort":0,"permission":{"default":0,"y5gmtwxmW3A5ZuOP":3},"flags":{"core":{"sourceId":"Macro.VhzAqG5Abes21JD9"}}}
{"_id":"XNQSxkffgHApZf4A","name":"Import from Compendium","type":"script","author":"y5gmtwxmW3A5ZuOP","img":"icons/svg/dice-target.svg","scope":"global","command":"/** \n * Import all the entries from a compendium into the desired folder.\n * @Author: KrishMero#1702\n */\n \nlet packOptions = game.packs.map(pack => `<option value=\"${pack.collection}\">${pack.title}</option>`);\nconst form = `\n  <div style=\"display: inline-block; width: 100px\">Folder:</div>\n  <input type=\"string\" id=\"folderName\">\n  <br />\n  <div style=\"font-size: 80%\">leave blank to create a folder after the compendium name</div>\n  <br />\n\n  <div style=\"display: inline-block; width: 100px\">Compendium:</div>\n  <select id=\"destinationPack\" />\n    ${packOptions}\n  </select>\n  <br />\n\n  <label>\n    <input type=\"checkbox\" id=\"delete\"/>\n    Clear destination first\n  </label>\n`;\n\nconst dialog = new Dialog({\n  title: \"Import data from compendium\",\n  content: form,\n  buttons: {\n    use: {\n      label: \"Apply\",\n      callback: importCompendium\n    }\n  }\n}).render(true);\n\nasync function importCompendium(html) {\n  const folderName = html.find(`input#folderName`)[0].value;\n  const packName = html.find(`select#destinationPack`)[0].value;\n  const remove = html.find(`input#delete`)[0].checked;\n\n  const pack = game.packs.get(packName);\n  const doc = pack.documentName;\n  let folder = folderName ? findFolder(folderName, doc) : await createFolder(pack, doc);\n  \n  if (!folder) return ui.notifications.error(`Your world does not have any ${doc} folders named '${folderName}'.`);\n  console.log(folder.id)\n  if (remove) removeDataFirst(folder.id, doc);\n  if (folder) importPack(pack, doc, folder.id)\n}\n\nasync function importPack(pack, doc, folderId) {\n  const docClass = CONFIG[doc].documentClass;\n  const content = await pack.getDocuments();\n  const createData = content.map(c => {\n    let data = c.toObject();\n    data.folder = folderId;\n    return data;\n  });\n  docClass.createDocuments(createData);\n}\n\nasync function removeDataFirst(folderId, doc) {\n  let type = getDocType(doc);\n  const removeableData = game[type].filter(t => t.data.folder === folderId);\n  CONFIG[doc].documentClass.deleteDocuments(removeableData.map(e=>e.id));\n  // if (typeof removeableData.delete !== \"undefined\") {\n  //   removeableData.delete();\n  // } else {\n  //   removeableData.map(d => d.delete());\n  // }\n}\n\nasync function createFolder(pack, type) {\n  let name = pack.metadata.label;\n  if(game.folders.getName(name)) return game.folders.getName(name);\n  let folder = await Folder.createDocuments([{ name, type, parent: null}]);\n  return folder[0];\n}\n\nfunction findFolder(folderName, doc)\n{\n  return game.folders.find(f => f.name === folderName && f.type === doc)\n}\n\nfunction getDocType(doc) {\n  switch (doc) {\n    case 'JournalEntry': return 'journal';\n    case 'RollTable': return 'tables';\n    default: return doc.toLowerCase() + 's';\n  }\n}","folder":null,"sort":0,"permission":{"default":0,"y5gmtwxmW3A5ZuOP":3},"flags":{}}
{"name":"Actor to  Combat","type":"script","author":"wCsoNxA9I9elUaGF","img":"icons/svg/dice-target.svg","scope":"global","command":"/*\nDisplay a prompt which allows you to select actors to add to the current combat encounter.\nThis is especially useful if you are running an encounter without a scene or tokens.\nYou can see it in action here: https://cdn.discordapp.com/attachments/960551198342139995/966856419787833384/Peek_2022-04-21_20-21.mp4\n*/\n\nDialog.confirm({\n    title: \"Who would you like to add to the current combat?\",\n    content: `<template><div style=\"display: flex; gap: 1em; align-items: center;\"><input type=\"number\" style=\"width: 3em;\" value=\"0\" min=\"0\"></input><p style=\"margin: .5em 0;\"><slot name=\"name\"></slot> [<slot name=\"id\"></slot>]</p></div></template><section></section>`,\n    render: html => {\n        const section = html[0].querySelector(\"section\");\n        const template = html[0].querySelector(\"template\");\n        \n        for (const actor of game.actors) {\n            const item = document.createElement(\"div\");\n            item.style.margin = \".5em 0\";\n            \n            const name = document.createElement(\"span\");\n            name.slot = \"name\";\n            name.textContent = actor.name;\n            item.append(name);\n\n            const id = document.createElement(\"code\");\n            id.slot = \"id\";\n            id.textContent = actor.id;\n            item.append(id);\n\n            const shadowRoot = item.attachShadow({ mode: \"open\" });\n            shadowRoot.appendChild(template.content.cloneNode(true));\n            \n            section.append(item);\n        }\n    },\n    yes: html => {\n        const updates = [];\n        html[0].querySelectorAll(\"template ~ section > div\").forEach(el => {\n            const id = el.querySelector(\"code\").textContent;\n            let quantity = el.shadowRoot.querySelector(\"input\").value;\n            while (quantity > 0) {\n                updates.push({ \"actorId\": id });\n                quantity--;\n            }\n        });\n        game.combat?.createEmbeddedDocuments(\"Combatant\", updates);\n    },\n});","folder":null,"sort":0,"permission":{"default":0,"wCsoNxA9I9elUaGF":3},"flags":{"core":{"sourceId":"Macro.iAfz2Ld4b0IXhGRP"}},"_id":"a9TMIoWwDZ4u6vPa"}
{"_id":"bD3UuA4ikwbCwtKX","name":"Tile XY Adjust","type":"script","author":"y5gmtwxmW3A5ZuOP","img":"icons/svg/dice-target.svg","scope":"global","command":"//Simple macro to loop through ALL SELECTED TILES and adjust their position by a set amount\n//Questions? Ask in Foundry VTT Discord #macro-polo channel. If absolutely needed, ping @Norc$5108\n\nasync function adjustTilesXY(tiles, xAdjust, yAdjust ) {\n    const updates = tiles.map(tile => ({\n        _id: tile.id,\n        x: tile.x + xAdjust,\n        y: tile.y + yAdjust,\n    }));\n    await canvas.scene.updateEmbeddedDocuments(\"Tile\", updates)\n}\n\nconst tiles = canvas.background.controlled.length ? canvas.background.controlled : canvas.foreground.controlled;\nif(!tiles.length) return ui.notifications.info(\"No tiles selected.\")\n//loop through all selected tiles\n//REPLACE THE \"1\" VALUES BELOW AS NEEDED\n    //The first number controls side-to-side position:\n        //Positive values move tiles to the right\n        //Negative values move tiles to the left\n        //If you enter 0, tiles will not move side to side at all.\n    //The second number controls up-and-down position:\n        //Positive values move tiles down\n        //Negative values move tiles up\n        //If you enter 0, tiles will not move up or down at all.\nawait adjustTilesXY(tiles, 1, 1);","folder":null,"sort":0,"permission":{"default":0,"y5gmtwxmW3A5ZuOP":3},"flags":{}}
{"_id":"cbvoXlwrSGOFFybV","name":"Delete All Templates","type":"script","author":"y5gmtwxmW3A5ZuOP","img":"icons/svg/dice-target.svg","scope":"global","command":"/**\n * Deletes all templates on the current scene\n */\n \n// no dialog. Just delete all templates.\ncanvas.scene.deleteEmbeddedDocuments(\"MeasuredTemplate\", canvas.templates.placeables.map(o =>o.id));\n\n// Get a dialog confirmation before deleting all templates on the scene:\n// canvas.templates.deleteAll()","folder":null,"sort":0,"permission":{"default":0,"y5gmtwxmW3A5ZuOP":3},"flags":{}}
{"_id":"dgSOPUXWUK1701PV","name":"Find Lights By Color","type":"script","author":"y5gmtwxmW3A5ZuOP","img":"icons/svg/dice-target.svg","scope":"global","command":"// Courtesy of @FloRad, Updated by scooper4711, updated for v9 by Freeze#2689, updated for v9.268 by Wim De Cat \n// This macro is intended to perform a batch update\n// of all lights in the current scene e.g. after\n// importing from Unversal Battle Map importer,\n// allowing you to set e.g. all wall torches identically.\n\n// Convert certain color lights to torch\n\n;(async () => {\n    let foundLights = [];\n    let markingColor = \"#ffff00\"\n    let newColor = \"#dd0000\"\n    let scene = game.scenes.active;\n\n    canvas.lighting.placeables.forEach(l => { if (l.data.config.color === markingColor && l.scene === scene) foundLights.push(l.id) })\n\n    const updates = []\n    foundLights.forEach(id => {\n        updates.push({ _id: id, \n            config: {\n                color: newColor,\n                dim: 16,\n                bright: 8,\n                animation: {              \n                        type: 'torch',\n                        speed: 1,\n                        intensity: 3,\n                        reverse: false\n                }   \n            }\n        });\n    })\n\n    await scene.updateEmbeddedDocuments(\"AmbientLight\", updates);\n\n    console.log(foundLights)\n})()\n\n\n// Convert all lights to torch not touching the color\n\n;(async () => {\n    let foundLights = [];\n    let scene = game.scenes.active;\n\n    canvas.lighting.placeables.forEach(l => { if (l.scene === scene) foundLights.push(l.id) })\n\n    const updates = []\n    foundLights.forEach(id => {\n        updates.push({ _id: id,\n            config: {\n                dim: 16,\n                bright: 8,\n                animation: {              \n                        type: 'pulse',\n                        speed: 1,\n                        intensity: 3,\n                        reverse: false\n                }   \n            }\n        });\n    })\n\n    await scene.updateEmbeddedDocuments(\"AmbientLight\", updates);\n\n    console.log(foundLights)\n})()","folder":null,"sort":0,"permission":{"default":0,"y5gmtwxmW3A5ZuOP":3},"flags":{}}
{"_id":"e25oI8hASMY8bgu6","name":"Hex Crawler Helper","type":"script","author":"y5gmtwxmW3A5ZuOP","img":"icons/svg/dice-target.svg","scope":"global","command":"/*\nRequired Rollable Tables:\n*Wilderness Encounters*\n    coast\n    jungle1\n    jungle2\n    jungle3\n    mountains\n    rivers\n    ruins\n    swamp\n    wasteland\n\n*Other Tables*\n    weather\n    directions\n\n    cache\n    deadexplorers\n\nCache and Deadexplorers are not mandatory, but if you don't want them search the file for // CACHE LINES or // DEAD EXPLORER LINES and comment out the 2 lines below the comments\n\nExplanation of those tables:\nIf you have an encounter table that has the word cache in it, the cache table will be rolled automatically.\n    <br/><span id=\"cache\">The party finds a cache: </span>\nIf you have an encounter table that has DeadExplorers in it, the dead explorer table will be rolled automatically.\n    <br/><span id=\"DeadExplorers\">The party finds: </span> \n\n\nYou can have an automatic moving \"Actual Location\" Marker by creating a Token named \"Actual Location\" and placing it on your hex grid.\nThis will move if the players are \"Lost\". If the players are not lost it will not move.\n\n\n\n*/\n\n\n// Macro requires selecting a token to roll the survival check\n\nfunction hexCrawl() {\n    if (canvas.tokens.controlled.length === 0)\n        return ui.notifications.error(\"Please select the token of the Navigator!\");\n\n    const playerMarker = canvas.scene.data.tokens.find(a => a.name === 'Player Location');\n    const locationMarker = canvas.scene.data.tokens.find(a => a.name === 'Actual Location');\n\n    const gridSize = canvas.grid.size;\n    const vertical = gridSize * 0.866666;\n    const diagVertical = gridSize * 0.433333;\n    const diagHorizontal = gridSize * 0.75;\n\n    // The option values below are the names of your rollable tables for each hex type. If these get changed here you will need to change them in the Survival Check DC section too!\n\n    let pace = 'none';\n    new Dialog({\n        title: `Hex Crawl Helper`,\n        content: `\n        <form>\n            <div class=\"form-group\">\n                <label>Hex Type:</label>\n                <select id=\"hex-type\" name=\"hex-type\">\n                    <option value=\"coast\">Coast</option>\n                    <option value=\"jungle1\">Jungle: No Undead</option>\n                    <option value=\"jungle2\">Jungle: Lesser Undead</option>\n                    <option value=\"jungle3\">Jungle: Greater Undead</option>\n                    <option value=\"mountains\">Mountains</option>\n                    <option value=\"rivers\">River</option>\n                    <option value=\"ruins\">Ruins</option>\n                    <option value=\"swamp\">Swamp</option>\n                    <option value=\"wasteland\">Wasteland</option>\n                </select>\n            </div>\n            <div class=\"form-group\">\n                <label>Travel Direction:</label>\n                <select id=\"travel-direction\" name=\"travel-direction\">\n                    <option value=\"North\">North</option>\n                    <option value=\"Northeast\">Northeast</option>\n                    <option value=\"Southeast\">Southeast</option>\n                    <option value=\"South\">South</option>\n                    <option value=\"Southwest\">Southwest</option>\n                    <option value=\"Northwest\">Northwest</option>\n                </select>\n            </div>\n            <div class=\"form-group\">\n                <label>Travel Type:</label>\n                <select id=\"travel-type\" name=\"travel-type\">\n                    <option value=\"on-foot\">On Foot</option>\n                    <option value=\"canoe\">By Canoe</option>\n                </select>\n            </div>\n        </form>\n        `,\n        buttons: {\n            slow: {\n                icon: \"<i class='fas fa-user-ninja'></i>\",\n                label: `Slow Pace`,\n                callback: () => pace = 'slow'\n            },\n            average: {\n                icon: \"<i class='fas fa-hiking'></i>\",\n                label: `Average Pace`,\n                callback: () => pace = 'average'\n            },\n            fast: {\n                icon: \"<i class='fas fa-running'></i>\",\n                label: `Fast Pace`,\n                callback: () => pace = 'fast'\n            }\n        },\n        default: \"average\",\n        close: async (html) => {\n            // set variables\n            let hexType = html.find('[name=\"hex-type\"]')[0].value;\n            let travelType = html.find('[name=\"travel-type\"]')[0].value;\n            let playerDirection = html.find('[name=\"travel-direction\"]')[0].value;\n            const weatherTable = game.tables.getName(\"weather\");\n            const directionTable = game.tables.getName(\"directions\");\n            const cacheTable = game.tables.getName(\"cache\");\n            const deadExplorerTable = game.tables.getName(\"deadexplorers\");\n            const encounterTable = game.tables.getName(hexType);\n            let weatherRoll = (await weatherTable.roll()).results[0].data.text;\n            let lostDirection = (await directionTable.roll()).results[0].data.text;\n            let msgContent = '<strong>Weather</strong> ' + weatherRoll + '<br/><br/>';\n            let navigator = Actors.instance.get(canvas.tokens.controlled[0].data.actorId);\n            let wis = navigator.data.data.abilities.wis.mod;\n            let survival = (await new Roll(`1d20`).roll({async: true})).total + wis;\n            let slowPace = (await new Roll(`1d4`).roll({async: true})).total;\n            let fastPace = (await new Roll(`1d2`).roll({async: true})).total;\n            let hexesMoved = 1;\n            let encounter = '';\n            let hexText = 'hexes';\n\n            if (travelType === 'canoe') {\n                hexesMoved++;\n            }\n\n            // build pace message and hex movement\n            if (pace === 'slow') {\n                if (slowPace === 1)\n                    hexesMoved--;\n                if (hexesMoved === 1)\n                    hexText = 'hex';\n                msgContent += '<strong>Slow pace:</strong> Can hide from encounters or approach stealthily.<br/><br/><strong>Party can move:</strong> ' + hexesMoved + ' ' + hexText + '.<br/><br/>';\n                survival += 5;\n            } else if (pace === 'average') {\n                if (hexesMoved === 1)\n                    hexText = 'hex';\n                msgContent += '<strong>Average pace:</strong> For rivers, upstream and downstream have no effect, and waterfalls occur every 10 to 20 miles (requiring portage of canoes).<br/><br/><strong>Party can move:</strong> ' + hexesMoved + ' ' + hexText + '.<br/><br/>';\n            } else if (pace === 'fast') {\n                if (fastPace === 1)\n                    hexesMoved++;\n                if (hexesMoved === 1)\n                    hexText = 'hex';\n                msgContent += '<strong>Fast pace:</strong> -5 to passive Perception.<br/><br/><strong>Party can move:</strong> ' + hexesMoved + ' ' + hexText + '.<br/><br/>';\n                survival -= 5;\n            } else {\n                return;\n            }\n\n            // Survival Check DC for each hex type. If selected token rolls under DC the party is lost!\n            if (((hexType === 'coast' || hexType === 'ruins') && survival < 10) || ((hexType === 'jungle1' || hexType === 'jungle2' || hexType === 'jungle3' || hexType === 'mountains' || hexType === 'rivers' || hexType === 'swamp' || hexType === 'wasteland') && survival < 15)) {\n                msgContent += '<strong>Party is Lost:</strong> Move actual location ' + hexesMoved + ' ' + hexText + ' to the ' + lostDirection + '<br/><br/>';\n                if (locationMarker) {\n                    const locToken = canvas.tokens.get(locationMarker.id);\n                    switch (lostDirection) {\n                        case 'South':\n                            locToken.document.update({\n                                x: locToken.x,\n                                y: locToken.y + (vertical * hexesMoved)\n                            });\n                            break;\n\n                        case 'Southwest':\n                            locToken.document.update({\n                                x: locToken.x - (diagHorizontal * hexesMoved),\n                                y: locToken.y + (diagVertical * hexesMoved)\n                            });\n                            break;\n\n                        case 'Southeast':\n                            locToken.document.update({\n                                x: locToken.x + (diagHorizontal * hexesMoved),\n                                y: locToken.y + (diagVertical * hexesMoved)\n                            });\n                            break;\n\n                        case 'North':\n                            locToken.document.update({\n                                x: locToken.x,\n                                y: locToken.y - (vertical * hexesMoved)\n                            });\n                            break;\n\n                        case 'Northwest':\n                            locToken.document.update({\n                                x: locToken.x - (diagHorizontal * hexesMoved),\n                                y: locToken.y - (diagVertical * hexesMoved)\n                            });\n                            break;\n\n                        case 'Northeast':\n                            locToken.document.update({\n                                x: locToken.x + (diagHorizontal * hexesMoved),\n                                y: locToken.y - (diagVertical * hexesMoved)\n                            });\n                            break;\n\n                        default:\n                            break;\n                    }\n                }\n                if (playerMarker) {\n                    const playerToken = canvas.tokens.get(playerMarker.id);\n                    switch (playerDirection) {\n                        case 'South':\n                            playerToken.document.update({\n                                x: playerToken.x,\n                                y: playerToken.y + (vertical * hexesMoved)\n                            });\n                            break;\n\n                        case 'Southwest':\n                            playerToken.document.update({\n                                x: playerToken.x - (diagHorizontal * hexesMoved),\n                                y: playerToken.y + (diagVertical * hexesMoved)\n                            });\n                            break;\n\n                        case 'Southeast':\n                            playerToken.document.update({\n                                x: playerToken.x + (diagHorizontal * hexesMoved),\n                                y: playerToken.y + (diagVertical * hexesMoved)\n                            });\n                            break;\n\n                        case 'North':\n                            playerToken.document.update({\n                                x: playerToken.x,\n                                y: playerToken.y - (vertical * hexesMoved)\n                            });\n                            break;\n\n                        case 'Northwest':\n                            playerToken.document.update({\n                                x: playerToken.x - (diagHorizontal * hexesMoved),\n                                y: playerToken.y - (diagVertical * hexesMoved)\n                            });\n                            break;\n\n                        case 'Northeast':\n                            playerToken.document.update({\n                                x: playerToken.x + (diagHorizontal * hexesMoved),\n                                y: playerToken.y - (diagVertical * hexesMoved)\n                            });\n                            break;\n\n                        default:\n                            break;\n                    }\n                }\n            } else {\n                if (playerMarker && locationMarker) {\n                    const locToken = canvas.tokens.get(locationMarker.id);\n                    const playerToken = canvas.tokens.get(playerMarker.id);\n\n                    switch (playerDirection) {\n                        case 'South':\n                            playerToken.document.update({\n                                x: locToken.x,\n                                y: locToken.y + (vertical * hexesMoved)\n                            });\n                            locToken.document.update({\n                                x: locToken.x,\n                                y: locToken.y + (vertical * hexesMoved)\n                            });\n                            break;\n\n                        case 'Southwest':\n                            playerToken.document.update({\n                                x: locToken.x - (diagHorizontal * hexesMoved),\n                                y: locToken.y + (diagVertical * hexesMoved)\n                            });\n                            locToken.document.update({\n                                x: locToken.x - (diagHorizontal * hexesMoved),\n                                y: locToken.y + (diagVertical * hexesMoved)\n                            });\n                            break;\n\n                        case 'Southeast':\n                            playerToken.document.update({\n                                x: locToken.x + (diagHorizontal * hexesMoved),\n                                y: locToken.y + (diagVertical * hexesMoved)\n                            });\n                            locToken.document.update({\n                                x: locToken.x + (diagHorizontal * hexesMoved),\n                                y: locToken.y + (diagVertical * hexesMoved)\n                            });\n                            break;\n\n                        case 'North':\n                            playerToken.document.update({\n                                x: locToken.x,\n                                y: locToken.y - (vertical * hexesMoved)\n                            });\n                            locToken.document.update({\n                                x: locToken.x,\n                                y: locToken.y - (vertical * hexesMoved)\n                            });\n                            break;\n\n                        case 'Northwest':\n                            playerToken.document.update({\n                                x: locToken.x - (diagHorizontal * hexesMoved),\n                                y: locToken.y - (diagVertical * hexesMoved)\n                            });\n                            locToken.document.update({\n                                x: locToken.x - (diagHorizontal * hexesMoved),\n                                y: locToken.y - (diagVertical * hexesMoved)\n                            });\n                            break;\n\n                        case 'Northeast':\n                            playerToken.document.update({\n                                x: locToken.x + (diagHorizontal * hexesMoved),\n                                y: locToken.y - (diagVertical * hexesMoved)\n                            });\n                            locToken.document.update({\n                                x: locToken.x + (diagHorizontal * hexesMoved),\n                                y: locToken.y - (diagVertical * hexesMoved)\n                            });\n                            break;\n\n                        default:\n                            break;\n                    }\n                }\n            }\n\n            msgContent += '<strong>Morning Encounter:</strong> ';\n\n            if ((await new Roll(`1d20`).roll({async: true})).total > 15) {\n                encounter = (await encounterTable.roll()).results[0].data.text;\n                msgContent += encounter;\n                // CACHE LINES comment out the next 2 lines if you don't want to use a cache table!\n                if (encounter.indexOf('cache') > -1)\n                    msgContent += (await cacheTable.roll()).results[0].data.text + '<br/><br/>';\n                // DEAD EXPLORER LINES comment out the next 2 lines if you don't want to use a dead explorer table!\n                if (encounter.indexOf('DeadExplorers') > -1)\n                    msgContent += (await deadExplorerTable.roll()).results[0].data.text + '<br/><br/>';\n                msgContent += '<strong>Afternoon Encounter:</strong> ';\n            } else {\n                msgContent += 'None.<br/><br/><strong>Afternoon Encounter:</strong> ';\n            }\n\n            if ((await new Roll(`1d20`).roll({async: true})).total > 15) {\n                encounter = (await encounterTable.roll()).results[0].data.text;\n                msgContent += encounter;\n                // CACHE LINES comment out the next 2 lines if you don't want to use a cache table!\n                if (encounter.indexOf('cache') > -1)\n                    msgContent += (await cacheTable.roll()).results[0].data.text + '<br/><br/>';\n                // DEAD EXPLORER LINES comment out the next 2 lines if you don't want to use a dead explorer table!\n                if (encounter.indexOf('DeadExplorers') > -1)\n                    msgContent += (await deadExplorerTable.roll()).results[0].data.text + '<br/><br/>';\n                msgContent += '<strong>Evening Encounter:</strong> ';\n            } else {\n                msgContent += 'None.<br/><br/><strong>Evening Encounter:</strong> ';\n            }\n\n            if (new Roll(`1d20`).roll().total > 15) {\n                encounter = (await encounterTable.roll()).results[0].data.text;\n                msgContent += encounter;\n                // CACHE LINES comment out the next 2 lines if you don't want to use a cache table!\n                if (encounter.indexOf('cache') > -1)\n                    msgContent += (await cacheTable.roll()).results[0].data.text + '<br/><br/>';\n                // DEAD EXPLORER LINES comment out the next 2 lines if you don't want to use a dead explorer table!\n                if (encounter.indexOf('DeadExplorers') > -1)\n                    msgContent += (await deadExplorerTable.roll()).results[0].data.text + '<br/><br/>';\n            } else {\n                msgContent += 'None.';\n            }\n\n            // create the message\n            let chatData = {\n                content: msgContent,\n                whisper: ChatMessage.getWhisperRecipients(\"GM\")\n            };\n            ChatMessage.create(chatData, {});\n        }\n    }).render(true);\n}\n\nhexCrawl();","folder":null,"sort":0,"permission":{"default":0,"y5gmtwxmW3A5ZuOP":3},"flags":{}}
{"_id":"fYT65nJz51J74ymJ","name":"Jukebox","permission":{"default":0,"y5gmtwxmW3A5ZuOP":3},"type":"script","flags":{},"scope":"global","command":"/**\n * Quickly play from a list of sound effects and set their audio level. (does not loop)\n * Author: Rockshow\n */\n\nlet playlist = {\n  'twigs breaking': 'audio/twigs_1.mp3',\n  'door opening': 'sounds/lock.wav',\n};\n\nlet optionList;\nfor (let [key, value] of Object.entries(playlist)) {\n  optionList += `<option value=\"${value}\">${key}</option>`;\n}\n\nlet applyChanges = false;\nnew Dialog({\n  title: `Audio chosing form`,\n  content: `\n    <form>\n      <div class=\"form-group\">\n        <label>Canzone:</label>\n        <select id=\"idcanzone\" name=\"idcanzone\">\n          ${optionList}\n        </select>\n      </div>\n   \n        <div class=\"form-group\">\n        <label for=\"vol\">Volume:</label>\n           <div class=\"form-fields\">\n            <input type=\"range\" id=\"vol\" name=\"vol\" min=\"0\" max=\"8\" value=\"1\" step=\"0.2\" data-dtype=\"Number\">\n            <span class=\"range-value\" id=\"demo\">1</span>\n           </div>\n        </div>\n </form> \n<script>\nvar slider = document.getElementById(\"vol\");\nvar output = document.getElementById(\"demo\");\noutput.innerHTML = slider.value;\n\nslider.oninput = function() {\n  output.innerHTML = this.value;\n}\n</script>\n          `,\n  buttons: {\n    no: {\n      icon: \"<i class='fas fa-times'></i>\",\n      label: `Cancel Changes`\n        },\n    yes: {\n      icon: \"<i class='fas fa-check'></i>\",\n      label: `Apply Changes`,\n      callback: () => applyChanges = true\n         },\n           },\n  default: \"yes\",\n  close: html => {\n    if (applyChanges) {\n    let canzone= html.find('[name=\"idcanzone\"]')[0].value || \"none\";\n    let vol1= html.find('[name=\"vol\"]')[0].value || \"none\";\n    AudioHelper.play({src: canzone, volume:vol1, autoplay: true, loop: false}, true);\n                      }\n                 }\n  }).render(true);\n","author":"y5gmtwxmW3A5ZuOP","img":"icons/svg/dice-target.svg","actorIds":[]}
{"_id":"fdXN3rcX29ZkRRL2","name":"Tile Toggle Locked Status","type":"script","author":"y5gmtwxmW3A5ZuOP","img":"icons/svg/dice-target.svg","scope":"global","command":"//Simple macro to loop through ALL SELECTED TILES and toggle their locked status.\n//In other words:\n    //If an individual tile is unlocked, this macro will lock it.\n    //If an individual tile is locked, this macro will unlock it.\n\nconst tiles = canvas.background.controlled.length ? canvas.background.controlled : canvas.foreground.controlled;\nconst updates = tiles.map(tile => ({ _id: tile.id, locked: !tile.data.locked }));\ncanvas.scene.updateEmbeddedDocuments(\"Tile\", updates);","folder":null,"sort":0,"permission":{"default":0,"y5gmtwxmW3A5ZuOP":3},"flags":{}}
{"name":"Scale Grid Size To Inches","permission":{"default":0,"y5gmtwxmW3A5ZuOP":3},"type":"script","flags":{},"scope":"global","command":"/**\nAuthor: @stan#1549 (github.com/janssen-io)\n\nDescription:\nThe first time you click the macro, it will prompt you for your screen size (diagonal).\nClicking the macro a second time will automatically scale to 1\"/grid unit (square/hex).\nShift-click the macro to update this value.\n\nNote:\nThe screen size is saved per client. So opening the macro on another device for the first time, will make it prompt for the screen size again.\n */\n\nfunction showDialog(inches, resolve) {\n  new Dialog({\n    content: `Screen size (inches): <input type=\"number\" min=\"10\" max=\"200\" value=\"${inches}\" />`,\n    default: 'scale',\n    buttons: {\n      scale: {\n        label: 'Scale',\n        callback: html => resolve(+html.find('input').val())\n      }\n    }\n  }).render(true);\n}\n\nfunction scale(screenSizeInches) {\n  const diagonal = Math.sqrt(screen.width ** 2 + screen.height ** 2);\n  const ppi = diagonal / screenSizeInches;\n  console.log(`PPI: ${screenSizeInches}\" screen | ${canvas.grid.size}px per grid unit | ${ppi}px per inch | Scaling to: ${ppi / canvas.grid.size}`);\n  canvas.animatePan({ scale: ppi / canvas.grid.size });\n}\n\nconst key = 'stan#1549.scale.screenSize';\nconst storedScreenSize = localStorage.getItem(key);\nconst shouldUpdatePPI = !storedScreenSize || event.shiftKey;\n\nconst getScreenSize = new Promise(resolve => {\n  if (shouldUpdatePPI) {\n    showDialog(storedScreenSize || 42, resolve);\n  } else {\n    resolve(storedScreenSize);\n  }\n});\n\ngetScreenSize.then(inches => {\n  scale(inches);\n  localStorage.setItem(key, inches);\n});\n\n\n","author":"y5gmtwxmW3A5ZuOP","img":"icons/svg/dice-target.svg","actorIds":[],"_id":"gq8UDK94ykfMViNT"}
{"_id":"iLlJKBjrtOMNxlv6","name":"Tile Toggle Hidden Status","type":"script","author":"y5gmtwxmW3A5ZuOP","img":"icons/svg/dice-target.svg","scope":"global","command":"// Simple macro to loop through ALL SELECTED TILES and toggle whether or not they are hidden.\n// Uncomment line 8 or 9 to change behavior to hide / show all tiles instead of toggle\nconst tiles = canvas.background.controlled.length ? canvas.background.controlled : canvas.foreground.controlled;\nconst updates = tiles.map(tile => {\n    let v;\n    v = !tile.data.hidden; // Toggle visibility for each tile\n    // v = false;          // Hide all selected tiles\n    // v = true;           // Show all selected tiles\n    return{ _id: tile.id, hidden: v };\n});\ncanvas.scene.updateEmbeddedDocuments(\"Tile\", updates);","folder":null,"sort":0,"permission":{"default":0,"y5gmtwxmW3A5ZuOP":3},"flags":{}}
{"name":"Rebind Token Actors","type":"script","author":"y5gmtwxmW3A5ZuOP","img":"icons/svg/dice-target.svg","scope":"global","command":"// Rebinds the actor for all selected tokens.\n// Requirements: \n//  - the actor must be present in the \"Actor Directory\"\n//  - actor name can't contain either '/' or '.'\n\n// Any Token with an altered name and an img path attached \n// will look up the default actor name via provided URL.\n\nconst dir = new ActorDirectory();\n\nfor (const token of canvas.tokens.controlled) {\n   tname = token.name;\n   results = dir.documents.filter(obj => {if(obj.data.name === tname){return obj;}})\n   if(results.length === 0){\n       if(token.data.img){\n//      Possible optimization: regEx look-up for any word character pre '.' and post '/'\n        str = token.data.img;\n        arr = str.split('/');\n        tname = arr[arr.length-1].split('.')[0];\n        results = dir.documents.filter(obj => {if(obj.data.name === tname){return obj;}})\n       }\n   }\n   if(results.length > 0){\n        await token.update({'actorId':results[0].data._id});\n   }\n}","folder":null,"sort":0,"flags":{"core":{"sourceId":"Macro.T6rBYAF9cEQs1Tvj"}},"_id":"ie5zQi7onuxJezxN","ownership":{"default":0,"y5gmtwxmW3A5ZuOP":3},"_stats":{"systemId":"dnd5e","systemVersion":"2.0.3","coreVersion":"10.291","createdTime":null,"modifiedTime":1670654636695,"lastModifiedBy":"QMyNqXGlX06pnWfY"}}
{"_id":"lPEdDL4uqxRFfW9x","name":"Format All Scene Notes","type":"script","author":"y5gmtwxmW3A5ZuOP","img":"icons/svg/dice-target.svg","scope":"global","command":"const updates = canvas.notes.placeables.map(n => ({\n    _id: n.id,\n     \n     /* READ THIS MESSAGE!**format_all_scene_notes.js**\nconst updates = canvas.notes.placeables.map(n => ({\n    _id: n.id,\n     \n     /* READ THIS MESSAGE!\n        Define new note properties\n        double right-click a map pin for a list of valid fonts, icons, etc.  \n        remove the // from front of the line to allow that setting to be updated.   \n    */\n\n    //fontFamily: \"Signika\",       \n    //fontSize: 48,\n    //icon: \"icons/svg/anchor.svg\", // replace the name of the icon, for example, the anchor would be \"icons/svg/anchor.svg\" \n    //iconSize: 40,\n    //iconTint: null, // if not white hex code like: \"#AB8345\"\n    //textAnchor: CONST.TEXT_ANCHOR_POINTS.CENTER, // textAnchor controls the location of the text in relation to the icon. other options are .BOTTOM, .TOP. LEFT . RIGHT\n    //textColor: \"#FFFFFF\",\n    //x: 2450,  // absolute location on the canvas.\n    //y: 1250,  // absolute location on the canvas.\n}));\ncanvas.scene.updateEmbeddedDocuments(\"Note\", updates);\n        Define new note properties\n        double right-click a map pin for a list of valid fonts, icons, etc.  \n        remove the // from front of the line to allow that setting to be updated.   \n    */\n\n    //fontFamily: \"Signika\",       \n    //fontSize: 48,\n    //icon: \"icons/svg/anchor.svg\", // replace the name of the icon, for example, the anchor would be \"icons/svg/anchor.svg\" \n    //iconSize: 40,\n    //iconTint: null, // if not white hex code like: \"#AB8345\"\n    //textAnchor: CONST.TEXT_ANCHOR_POINTS.CENTER, // textAnchor controls the location of the text in relation to the icon. other options are .BOTTOM, .TOP. LEFT . RIGHT\n    //textColor: \"#FFFFFF\",\n    //x: 2450,  // absolute location on the canvas.\n    //y: 1250,  // absolute location on the canvas.\n}));\ncanvas.scene.updateEmbeddedDocuments(\"Note\", updates);","folder":null,"sort":0,"permission":{"default":0,"y5gmtwxmW3A5ZuOP":3},"flags":{"core":{"sourceId":"Macro.yBeuLYd6wNuX6JHQ"}}}
{"_id":"mzkDNKmsOb9WwpIO","name":"Fine Tile Control","type":"script","author":"y5gmtwxmW3A5ZuOP","img":"icons/svg/dice-target.svg","scope":"global","command":"// Fine Tile Control //\n\n// This is a series of 6 macros that you must paste individually into a new\n// Hot Bar Macro Sheet and save. The Hot Bar number is used to activate the macro.\n// Hold down the Control key to halve the distance increment from 1 to 0.5.\n// CAUTION: If the ctrl key doesn‘t check your operating system and/or move the\n// macro to another cell.\n// NOTE: Any locked tiles are ignored.\n\n// Move Up\n// By @cole$9640\n\nconst amount = event.ctrlKey ? -0.5 : -1;\nconst tiles = canvas.background.controlled.length === 0 ? canvas.foreground.controlled : canvas.background.controlled;\nif (tiles.length) {\n  const updates = tiles\n    .filter((tile) => !tile.data.locked)\n    .map((tile) => ({\n      _id: tile.id,\n      y: tile.y + amount,\n    }));\n  canvas.scene.updateEmbeddedDocuments(\"Tile\", updates);\n} else {\n  ui.notifications.notify(\"Please select at least one tile.\");\n}\n\n// Move Down\n// By @cole$9640\n\nconst amount = event.ctrlKey ? 0.5 : 1;\nconst tiles = canvas.background.controlled.length === 0 ? canvas.foreground.controlled : canvas.background.controlled;\nif (tiles.length) {\n  const updates = tiles\n    .filter((tile) => !tile.data.locked)\n    .map((tile) => ({\n      _id: tile.id,\n      y: tile.y + amount,\n    }));\n  canvas.scene.updateEmbeddedDocuments(\"Tile\", updates);\n} else {\n  ui.notifications.notify(\"Please select at least one tile.\");\n}\n\n// Move Right\n// By @cole$9640\n\nconst amount = event.ctrlKey ? 0.5 : 1;\nconst tiles = canvas.background.controlled.length === 0 ? canvas.foreground.controlled : canvas.background.controlled;\nif (tiles.length) {\n  const updates = tiles\n    .filter((tile) => !tile.data.locked)\n    .map((tile) => ({\n      _id: tile.id,\n      x: tile.x + amount,\n    }));\n  canvas.scene.updateEmbeddedDocuments(\"Tile\", updates);\n} else {\n  ui.notifications.notify(\"Please select at least one tile.\");\n}\n\n// Move Left\n// By @cole$9640\n\nconst amount = event.ctrlKey ? -0.5 : -1;\nconst tiles = canvas.background.controlled.length === 0 ? canvas.foreground.controlled : canvas.background.controlled;\nif (tiles.length) {\n  const updates = tiles\n    .filter((tile) => !tile.data.locked)\n    .map((tile) => ({\n      _id: tile.id,\n      x: tile.x + amount,\n    }));\n  canvas.scene.updateEmbeddedDocuments(\"Tile\", updates);\n} else {\n  ui.notifications.notify(\"Please select at least one tile.\");\n}\n\n// Rotate Left\n// Original by @Norc$5108, updated and refined by @cole$9640 & @Drunemeton$7955\n\nconst amount = event.ctrlKey ? -0.5 : -1;\nconst tiles = canvas.background.controlled.length === 0 ? canvas.foreground.controlled : canvas.background.controlled;\nif (tiles.length) {\n  const updates = tiles\n  .filter((tile) => !tile.data.locked)\n  .map((tile) => ({\n    _id: tile.id, \n    rotation: tile.data.rotation + amount \n  }));\n  canvas.scene.updateEmbeddedDocuments(\"Tile\", updates);\n} else {\n  ui.notifications.notify(\"Please select at least one tile.\");\n}\n\n// Rotate Right\n// Original by @Norc$5108, updated and refined by @cole$9640 & @Drunemeton$7955\n\nconst amount = event.ctrlKey ? 0.5 : 1;\nconst tiles = canvas.background.controlled.length === 0 ? canvas.foreground.controlled : canvas.background.controlled;\nif (tiles.length) {\n  const updates = tiles\n  .filter((tile) => !tile.data.locked)\n  .map((tile) => ({\n    _id: tile.id, \n    rotation: tile.data.rotation + amount \n  }));\n  canvas.scene.updateEmbeddedDocuments(\"Tile\", updates);\n} else {\n  ui.notifications.notify(\"Please select at least one tile.\");\n}","folder":null,"sort":0,"permission":{"default":0,"y5gmtwxmW3A5ZuOP":3},"flags":{}}
{"_id":"qcWEVrOYfJAOa5Rr","name":"Rolltables","type":"script","author":"y5gmtwxmW3A5ZuOP","img":"icons/svg/dice-target.svg","scope":"global","command":"/* \n * Macro: GeekDad's Table Roller\n * Version: 2\n * Updated: 23-12-2021 by Freeze\n * Description: A nice friendly Better Tables compatible table roller that can draw mass quantities from tables much faster than the UI.\n*/\n\nfunction getTableNames() {\n let tables = [];\n game.tables.forEach(table => {\n  tables.push({ key: table.id, name: table.name });\n });\n\n return tables;\n}\n\nasync function rollOnTable(tableKey, numRolls, betterTableState) {\n  let table = game.tables.get(tableKey);\n  await table.reset();\n  if (game.betterTables) {\n   let tableType = table.getFlag(\"better-rolltables\", \"table-type\");\n   let originalAmount = table.data[\"loot-rolls-amount-input\"];\n   await table.update({\"loot-rolls-amount-input\": numRolls});\n   switch (betterTableState) {\n    case 1:\n      await game.betterTables.generateLoot(table);\n     break;\n    case 2:\n     await game.betterTables.addLootToSelectedToken(table);\n     break;\n    default:\n     if (tableType === \"loot\") {\n      await game.betterTables.generateChatLoot(table);\n     } else {\n      await game.betterTables.betterTableRoll(table);\n     }\n     break;\n   }\n   await table.update({\"loot-rolls-amount-input\": originalAmount});\n  } else {\n   table.drawMany(numRolls);\n  }\n}\n\nlet tables = getTableNames();\n\nlet content = `<form><div style=\"display: inline-block; width: 100%; margin-bottom: 10px\">\n  <label for=\"output-tableKey\" style=\"vertical-align: top; margin-right: 10px;\">Table Name:</label>\n<br /><select name=\"output-tableKey\" id=\"output-tableKey\">`\n\ntables.forEach(table => {\n content += `<option value='${table.key}'>${table.name}</option>`;\n});\n\ncontent += `</select><br /><label for=\"output-numberRolls\">Number of Rolls:</label><input name=\"output-numberRolls\" value=\"1\" /><br />`\n\nif (game.betterTables) {\n content += `<p>Better Tables Options</p>\n <input type=\"radio\" name=\"output-addToActor\" id=\"onlyToChat\" value=\"onlyToChat\" checked />\n <label for=\"onlyToChat\">Just output to chat</label><br />\n <input type=\"radio\" name=\"output-addToActor\" id=\"tableActor\" value=\"tableActor\" />\n <label for=\"tableActor\">Add To Table Actor</label><br />\n <input type=\"radio\" name=\"output-addToActor\" id=\"selectedToken\" value=\"selectedToken\" />\n <label for=\"selectedToken\">Add To Selected Token</label><br /> \n`\n}\n\ncontent += `</div><br /></form>`\n\n new Dialog({\n  title: `GeekDad's Table Roller`,\n  content: content,\n  buttons: {\n   yes: {\n    icon: \"<i class='fas fa-check'></i>\",\n    label: \"Roll it\",\n    callback: (html) => {\n     let tableKey = html.find(\"select[name='output-tableKey']\").val();\n     let numRolls = html.find(\"input[name='output-numberRolls']\").val();\n     let betterTableState = 0;\n     if (html.find(\"input[name='output-addToActor']:checked\").length > 0) {\n      let radioVal = html.find(\"input[name='output-addToActor']:checked\").val();\n      betterTableState = radioVal == \"onlyToChat\" ? 0 : \"tableActor\" ? 1 : 2;\n     }\n     rollOnTable(tableKey, numRolls, betterTableState);\n    }\n   },\n   no: {\n    icon: \"<i class='fas fa-times'></i>\",\n    label: 'Cancel'\n   }\n  },\n  default: \"yes\"\n }).render(true);","folder":null,"sort":0,"permission":{"default":0,"y5gmtwxmW3A5ZuOP":3},"flags":{"core":{"sourceId":"Macro.u3zoCoIPIcBWb0wO"}}}
{"_id":"qlx6N8QD6QliPQbu","name":"Create Ambient Light","type":"script","author":"y5gmtwxmW3A5ZuOP","img":"icons/svg/dice-target.svg","scope":"global","command":"// Create a (pre-configured) lightsource on the current scene. \n// This example is a blue light for \"activating a stargate.\"\n\ncanvas.scene.createEmbeddedDocuments(\"AmbientLight\", [{\n    t: \"l\", // l for local. The other option is g for global.\n    x: 1500, // horizontal positioning\n    y: 1150, // vertical positioning\n    rotation: 0, // the beam direction of the light in degrees (if its angle is less than 360 degrees.) \n    config: { \n        dim: 20.50, // the total radius of the light, including where it is dim.\n        bright: 19.00, // the bright radius of the light\n        angle: 360, // the coverage of the light. (Try 30 for a \"spotlight\" effect.)\n        \n                    // Oddly, degrees are counted from the 6 o'clock position.\n        color: \"#0080FF\", // Light coloring.\n        alpha: 0.5\n    } // Light opacity (or \"brightness,\" depending on how you think about it.) \n}]);","folder":null,"sort":0,"permission":{"default":0,"y5gmtwxmW3A5ZuOP":3},"flags":{}}
{"_id":"r8G0g61ikT9mJJwF","name":"Move Walls","permission":{"default":0,"y5gmtwxmW3A5ZuOP":3},"type":"script","flags":{},"scope":"global","command":"/* From: @(Busy) Gen Kitty (she/her)\nTo move each node on both axes, you need all 4 parameters listed. \nIn this case, he wanted to move all the walls up and to the left and \nthe foundry grid is sorta vertically flipped to what you'd expect, \nwhich is why all of the operators are \"-=\" If you wanted to move them \nin different directions it'd just be a matter of changing the operator \nnext to the equals sign.\n\nEach argument is a node's X or Y position, and each wall segment has two nodes. \n0 = Node 1 X \n1 = Node 1 Y \n2 = Node 2 X \n3 = Node 2 Y\n*/\n\nlet walls = canvas.scene.data.walls.map(w => {\n  w = duplicate(w);\n  w.c[0] -= 50;\n  w.c[1] -= 50;\n  w.c[2] -= 50;\n  w.c[3] -= 50;\n  return w;\n});\ncanvas.scene.update({walls: walls});\n","author":"y5gmtwxmW3A5ZuOP","img":"icons/svg/dice-target.svg","actorIds":[]}
{"name":"Delete Items Not In Folders","permission":{"default":0,"y5gmtwxmW3A5ZuOP":3},"type":"script","flags":{},"scope":"global","command":"/**\n * Clears the actors entity of any entries not in a folder.\n * Change 'actors' to another game entity such as tables, items, macros, etc... to clear items not in directory for those places.\n * Author: KrishMero#1792\n */\n \n game.actors.forEach(t => {\n  if (!t.data.folder) {\n    t.delete();\n  }\n});","author":"y5gmtwxmW3A5ZuOP","img":"icons/svg/dice-target.svg","actorIds":[],"_id":"rhnCyrHldOsjdAQN"}
{"name":"Compendium Set Lock and Visibility","type":"script","author":"y5gmtwxmW3A5ZuOP","img":"icons/svg/dice-target.svg","scope":"global","command":"/* \n* Made by foundry discor user: Freeze#2689\n* this Macro is for people that want to change the visibility and/or lock on their Compendium,\n* or all of their Compendia at once.\n* As always when doing mass changes to your world. MAKE A BACKUP, you were warned.\n* That said I anticipate no issues, just put this code in a macro on your hotbar and click.\n*/\n\nasync function changeSetting(lock, priv, key){\n    let value = game.settings.get(\"core\", \"compendiumConfiguration\");\n    value[key] = {private: priv, locked: lock};\n    await game.settings.set(\"core\", \"compendiumConfiguration\", value);\n}\nasync function changeAllSettings(lock, priv) {\n    let value = {};\n    for(let pack of game.packs) {\n        value[pack.collection] = {private: priv, locked: lock};\n    }\n    await game.settings.set(\"core\", \"compendiumConfiguration\", value);\n}\n\n\n\nfunction onChange(html) {\n    let pack = game.packs.get(html.value);\n    // console.log(pack)\n    if(pack.private){\n        if (!$(\"#compendia-changer-dialog .private-checkbox\").prop(\"checked\")){\n            $(\"#compendia-changer-dialog .private-checkbox\").prop(\"checked\", true);\n        }\n    }\n    else {\n        if ($(\"#compendia-changer-dialog .private-checkbox\").prop(\"checked\")){\n            $(\"#compendia-changer-dialog .private-checkbox\").prop(\"checked\", false);\n        }\n    }\n    if(pack.locked){\n        if (!$(\"#compendia-changer-dialog .locked-checkbox\").prop(\"checked\")){\n            $(\"#compendia-changer-dialog .locked-checkbox\").prop(\"checked\", true);\n        }\n    }\n    else {\n        if ($(\"#compendia-changer-dialog .locked-checkbox\").prop(\"checked\")){\n            $(\"#compendia-changer-dialog .locked-checkbox\").prop(\"checked\", false);\n        }\n    }\n    \n}\n\n\nlet packs = game.packs.contents;\nlet options = packs.reduce((acc, p) => acc += `<option value=\"${p.collection}\">${p.metadata.label}</option>`, ``);\nlet checkedPrivate = packs[0].private ? \"checked\" : \"\";\nlet checkedLocked = packs[0].locked ? \"checked\" : \"\";\nconst content = `<form>\n                    <div class=\"form-group\">\n                        <label>Pack name: </label>\n                        <select name=\"pack-key\" class=\"compendium-select\">${options}</select>\n                    </div>\n                    <div class=\"form-group\">\n                        <label>Private ?</label>\n                        <input type=\"checkbox\" class=\"private-checkbox\" name=\"private-setting\" ${checkedPrivate}>\n                    </div>\n                    <div class=\"form-group\">\n                        <label>Locked ?</label>\n                        <input type=\"checkbox\" class=\"locked-checkbox\"name=\"locked-setting\" ${checkedLocked}>\n                    </div>\n                </form>`;\n\nnew Dialog({\n    title: \"Set locked / private for Compendia\",\n    content,\n    buttons: {\n        change: {\n            label: \"Change!\",\n            callback: (html) => {\n                const lock = html.find(\"[name=locked-setting]\")[0].checked;\n                const priv = html.find(\"[name=private-setting\")[0].checked;\n                const key =  html.find(\"[name=pack-key]\")[0].value;\n                changeSetting(lock, priv, key);\n            }\n        },\n        changeAll: {\n            label: \"Change ALL!\",\n            callback: (html) => {\n                const lock = html.find(\"[name=locked-setting]\")[0].checked;\n                const priv = html.find(\"[name=private-setting\")[0].checked;\n                changeAllSettings(lock, priv);\n            }\n        },\n        cancel: {\n            label: \"Cancel\"\n        }\n    },\n    default: \"cancel\"\n},\n{\n    id: \"compendia-changer-dialog\"\n}).render(true);\n\nawait new Promise(resolve => {setTimeout(resolve, 150)});\n$(document).ready(function () {\n    $(\"#compendia-changer-dialog .compendium-select\").change(function (){\n        onChange(this);\n    });\n});","folder":null,"sort":0,"permission":{"default":0,"y5gmtwxmW3A5ZuOP":3},"flags":{"core":{"sourceId":"Macro.jkc0erfMqxJAciN0"}},"_id":"tSqe0A9bUTbsJsgI"}
{"name":"Show Modules","permission":{"default":0,"y5gmtwxmW3A5ZuOP":3},"type":"script","flags":{},"scope":"global","command":"/**\n * Show Modules - Shows currently installed modules in foundry. Added on behalf of @vance\n */\nlet mods = '';\ngame.modules.forEach(m => {\n  let a = m.active ? 'Enabled' : 'Disabled';\n  mods = mods.concat(`${m.id}: ${a}\\n`);\n});\n\nlet d = new Dialog({\n  title: `Enabled Mods`,\n  content: `<textarea style=\"height: 500px;\" type=\"text\" id=\"modslist\" name=\"modslist\">${mods}</textarea>`,\n  buttons: {\n    copy: {\n      label: `Copy to clipboard`,\n      callback: () => {\n        $(\"#modslist\").select();\n        document.execCommand('copy');\n      }\n    },\n    close: {\n      icon: \"<i class='fas fa-tick'></i>\",\n      label: `Close`\n    },\n  },\n  default: \"close\",\n  close: () => {}\n});\n\nd.render(true);","author":"y5gmtwxmW3A5ZuOP","img":"icons/svg/dice-target.svg","actorIds":[],"_id":"u71xIHwO8uVaLS8o"}
{"_id":"wosXzUFEMQLD84so","name":"Ambient Light Quick Edit","permission":{"default":0,"y5gmtwxmW3A5ZuOP":3},"type":"script","flags":{},"scope":"global","command":"let macroName = \"AmbientLight QuickEditor\"\nlet macroEndLog = \"---------------------------------------------\"\n\nlet i=0;\nlet lights = canvas.lighting.objects.children;\nlet lightSelected = lights[0];\nlet selectOptions = \"\";\nlet lightSelectedAngle = 0;\nlet lightSelectedBright = 0;\nlet lightSelectedDim = 0;\nlet lightSelectedRotation = 0;\nlet lightSelectedTintAlpha = 1;\nlet lightSelectedTintColor = \"\";\n\nconsole.log(\"---------------------------------------------\");\nconsole.log(`${macroName} by PaperPunk`);\nconsole.log(\"---------------------------------------------\");\nconsole.log(`${macroName} | Start`);\n\nconst drawingDetails = {\n      author: game.user._id,\n      fillAlpha: 0,\n      fillColor: \"#808080\",\n      fillType: 1,\n      fontFamily: \"FontAwesome\",\n      fontSize: 24,\n      height: 48,\n      hidden: false,\n      locked: false,\n      rotation: 0,\n      strokeAlpha: 1,\n      strokeColor: \"#000000\",\n      strokeWidth: 2,\n      text: i,\n      textAlpha: 1,\n      textColor: \"#ffffff\",\n      type: \"r\",\n      width: 48,\n      //x: 250,\n      x: lightSelected.x-24,\n      //y: 250\n      y: lightSelected.y+25\n};\n\n//let d = Drawing.create(drawingDetails);\n//d.update({\"x\": lights[i].x-24, \"y\": lights[i].y+25, \"text\": i});\n\nfor (i= 0; i< lights.length; i++) {\n selectOptions += `<option value=\"${i}\">AmbientLight ${i}</option>`;\n}\n\nconst htmlLightSelection = `\n    <form>\n      <h2>Select your light.</h2>\n      <div class=\"form-group\">\n        <label>Light:</label>\n        <select id=\"light-selector\" name=\"light-selector\">\n          ${selectOptions}\n        </select>\n      </div>\n    </form>\n    `;\n\nlet dialogSelector = new Dialog({\n  title: `${macroName}`,\n  content: htmlLightSelection,\n  buttons: {\n    confirm: {\n      icon: \"<i class='fas fa-tick'></i>\",\n      label: `Confirm`,\n      callback: htmlLightSelection => { \n        lightSelected = (htmlLightSelection.find('[name=\"light-selector\"]')[0].value)\n        lightSelectedAngle = lights[lightSelected].data.angle;\n        lightSelectedBright = lights[lightSelected].data.bright;\n        lightSelectedDim = lights[lightSelected].data.dim;\n        lightSelectedRotation = lights[lightSelected].data.rotation;\n        lightSelectedTintAlpha = lights[lightSelected].data.tintAlpha;\n        lightSelectedTintColor = lights[lightSelected].data.tintColor;\n        //console.log(`${macroName} | lightSelected = ${lightSelected}`);\n        //console.log(`${macroName} | lightSelectedBright = ${lightSelectedBright}`);\n        dialogEditor.render(true);\n      }\n    },\n    cancel: {\n      icon: \"<i class='fas fa-times'></i>\",\n      label: `Cancel`,\n      callback: () => {\n        console.log(`${macroName} | Goodbye`);\n        console.log(macroEndLog);\n      }\n    },\n  },\n  default: \"cancel\",\n  //close: () => console.log(\"AmbientLight QuickEditor | Dialog Window Closed\")\n});\n\nlet dialogEditor = new Dialog({\n  title: `${macroName}`,\n  content: `<h2>Edit your light.</h2>\n      <p>Emission Angle: ${lightSelectedAngle}</p>\n      <p>Bright light distance: ${lightSelectedBright}</p>\n      <p>Dim light distance: ${lightSelectedDim}</p>\n      <p>Rotation CW from down: ${lightSelectedRotation}</p>\n      <p>Tint Alpha: ${lightSelectedAngle}</p>\n      <p>Tint Color HexCode: ${lightSelectedAngle}</p>`,\n  buttons: {\n    rot5cw: {\n      icon: \"<i class='fas fa-redo'></i>\",\n      label: `Rotate 5* CW`,\n      callback: () => { \n        let rot = lights[lightSelected].data.rotation;\n        lights[lightSelected].update({\"rotation\":rot+5});\n        dialogEditor.render(true);\n      }\n    },\n    rot15cw: {\n      icon: \"<i class='fas fa-redo'></i>\",\n      label: `Rotate 15* CW`,\n      callback: () => { \n        let rot = lights[lightSelected].data.rotation;\n        lights[lightSelected].update({\"rotation\":rot+15});\n        dialogEditor.render(true);\n      }\n    },\n    rot45cw: {\n      icon: \"<i class='fas fa-redo'></i>\",\n      label: `Rotate 45* CW`,\n      callback: () => { \n        let rot = lights[lightSelected].data.rotation;\n        lights[lightSelected].update({\"rotation\":rot+45});\n        dialogEditor.render(true);\n      }\n    },\n    rot5ccw: {\n      icon: \"<i class='fas fa-undo'></i>\",\n      label: `Rotate 5* CCW`,\n      callback: () => { \n        let rot = lights[lightSelected].data.rotation;\n        lights[lightSelected].update({\"rotation\":rot-5});\n        dialogEditor.render(true);\n      }\n    },\n    rot15ccw: {\n      icon: \"<i class='fas fa-undo'></i>\",\n      label: `Rotate 15* CCW`,\n      callback: () => { \n        let rot = lights[lightSelected].data.rotation;\n        lights[lightSelected].update({\"rotation\":rot-15});\n        dialogEditor.render(true);\n      }\n    },\n    rot45ccw: {\n      icon: \"<i class='fas fa-undo'></i>\",\n      label: `Rotate 45* CCW`,\n      callback: () => { \n        let rot = lights[lightSelected].data.rotation;\n        lights[lightSelected].update({\"rotation\":rot-45});\n        dialogEditor.render(true);\n      }\n    },\n    brightup: {\n      icon: \"<i class='fas fa-circle'></i>\",\n      label: `Increase Bright by 5`,\n      callback: () => { \n        let bright = lights[lightSelected].data.bright;\n        lights[lightSelected].update({\"bright\":bright+5});\n        dialogEditor.render(true);\n      }\n    },\n    brightdown: {\n      icon: \"<i class='fas fa-circle'></i>\",\n      label: `Decrease Bright by 5`,\n      callback: () => { \n        let bright = lights[lightSelected].data.bright;\n        lights[lightSelected].update({\"bright\":bright-5});\n        dialogEditor.render(true);\n      }\n    },\n    brightoff: {\n      icon: \"<i class='fas fa-circle'></i>\",\n      label: `Remove Bright Light`,\n      callback: () => { \n        lights[lightSelected].update({\"bright\":0});\n        dialogEditor.render(true);\n      }\n    },\n    dimup: {\n      icon: \"<i class='fas fa-dot-circle'></i>\",\n      label: `Increase Dim by 5`,\n      callback: () => { \n        let dim = lights[lightSelected].data.dim;\n        lights[lightSelected].update({\"dim\":dim+5});\n        dialogEditor.render(true);\n      }\n    },\n    dimdown: {\n      icon: \"<i class='fas fa-dot-circle'></i>\",\n      label: `Decrease Dim by 5`,\n      callback: () => { \n        let dim = lights[lightSelected].data.dim;\n        lights[lightSelected].update({\"dim\":dim-5});\n        dialogEditor.render(true);\n      }\n    },\n    dimoff: {\n      icon: \"<i class='fas fa-dot-circle'></i>\",\n      label: `Remove Dim Light`,\n      callback: () => { \n        lights[lightSelected].update({\"dim\":0});\n        dialogEditor.render(true);\n      }\n    },\n    emit15: {\n      icon: \"<i class='fas fa-rss'></i>\",\n      label: `Emission Angle 15*`,\n      callback: () => { \n        lights[lightSelected].update({\"angle\":15});\n        dialogEditor.render(true);\n      }\n    },\n    emit45: {\n      icon: \"<i class='fas fa-rss'></i>\",\n      label: `Emission Angle 45*`,\n      callback: () => { \n        lights[lightSelected].update({\"angle\":45});\n        dialogEditor.render(true);\n      }\n    },\n    emit90: {\n      icon: \"<i class='fas fa-rss'></i>\",\n      label: `Emission Angle 90*`,\n      callback: () => { \n        lights[lightSelected].update({\"angle\":90});\n        dialogEditor.render(true);\n      }\n    },\n    emit180: {\n      icon: \"<i class='fas fa-rss'></i>\",\n      label: `Emission Angle 180*`,\n      callback: () => { \n        lights[lightSelected].update({\"angle\":180});\n        dialogEditor.render(true);\n      }\n    },\n    emit270: {\n      icon: \"<i class='fas fa-rss'></i>\",\n      label: `Emission Angle 270*`,\n      callback: () => { \n        lights[lightSelected].update({\"angle\":270});\n        dialogEditor.render(true);\n      }\n    },\n    emit360: {\n      icon: \"<i class='fas fa-rss'></i>\",\n      label: `Emission Angle 360*`,\n      callback: () => { \n        lights[lightSelected].update({\"angle\":360});\n        dialogEditor.render(true);\n      }\n    },\n    back: {\n      icon: \"<i class='fas fa-reply'></i>\",\n      label: `Back`,\n      callback: () => dialogSelector.render(true)\n    },\n    close: {\n      icon: \"<i class='fas fa-tick'></i>\",\n      label: `Close`\n    },\n  },\n  default: \"close\",\n  close: () => {\n    console.log(`${macroName} | Goodbye`);\n    console.log(macroEndLog);\n  }\n});\n\ndialogSelector.render(true);\n","author":"y5gmtwxmW3A5ZuOP","img":"icons/svg/dice-target.svg","actorIds":[]}
{"_id":"zsAzgwdGPAeArcIJ","name":"Lock All Doors","type":"script","author":"y5gmtwxmW3A5ZuOP","img":"icons/svg/dice-target.svg","scope":"global","command":"/**\n * Locks all closed doors on the canvas\n * Author: orcnog\n */\n \nawait canvas.walls.updateAll(w => ({ds: w.data.ds === CONST.WALL_DOOR_STATES.CLOSED ? CONST.WALL_DOOR_STATES.LOCKED : CONST.WALL_DOOR_STATES.CLOSED}), w => w.data.door === CONST.WALL_DOOR_TYPES.DOOR && (w.data.ds ===  CONST.WALL_DOOR_STATES.LOCKED || w.data.ds ===  CONST.WALL_DOOR_STATES.CLOSED));","folder":null,"sort":0,"permission":{"default":0,"y5gmtwxmW3A5ZuOP":3},"flags":{"core":{"sourceId":"Macro.sSGS2FhGOqiTIpRV"}}}
