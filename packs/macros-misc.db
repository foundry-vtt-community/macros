{"_id":"3byKEzTIX7jnn0DX","name":"Folder To Rollable Table","permission":{"default":0,"y5gmtwxmW3A5ZuOP":3},"type":"script","flags":{},"scope":"global","command":"// Take the entries of a folder and turn it into a rollable table.\n// NOTE: you must click the \"Normalize Result Weights\" button (scale icon) after import.\n// Author: @Atropos#3814\n\n// name of folder whos entities you wish to push into a rollable table.\nconst folder = game.folders.getName(\"Herbalism & Alchemy\");\n// name of table you will be overwriting\nconst table = game.tables.getName(\"Common Ingredients\");\n// change this to match the entity type you are importing.\n// Actor, Item, Scene, JournalEntry, Macro, RollTable, Playlist\nconst entityType = \"Item\"\n\nconst items = folder.entities;\nconst results = folder.entities.map(i => {\n  return {\n    text: i.data.name,\n    type: 1,\n    collection: \"Item\",\n    resultId: i.data._id,\n    img: i.data.img,\n    weight: 1,\n    range: [1, 1],\n    drawn: false\n  }\n});\nawait table.createEmbeddedEntity(\"TableResult\", results);\n","author":"y5gmtwxmW3A5ZuOP","img":"icons/svg/dice-target.svg","actorIds":[]}
{"_id":"525JVjJGyjIH5gv2","name":"Log Troubleshooting MSG To Console","permission":{"default":0,"y5gmtwxmW3A5ZuOP":3},"type":"script","flags":{},"scope":"global","command":"// Courtesy of @fohswe\n// Logs a troubleshooting message to the browser console.\n// (You can usually view the browser console using F12.)\n\nconst gl = canvas.app.renderer.context.gl;\n\nconsole.log(\n`=== Start of troubleshooting ===\nBackground image: ${canvas.background.img.width}x${canvas.background.img.height}\nNumber of walls: ${canvas.scene.data.walls.length}\nNumber of selected vision sources: ${canvas.sight.sources.vision.size}\nNumber of light sources: ${canvas.sight.sources.lights.size}\nWebGL MAX_TEXTURE_SIZE: ${gl.getParameter(gl.MAX_TEXTURE_SIZE)}\n`\n);","author":"y5gmtwxmW3A5ZuOP","img":"icons/svg/dice-target.svg","actorIds":[]}
{"_id":"5XA28twwaRBUFEjC","name":"Breathing Lights","permission":{"default":0,"y5gmtwxmW3A5ZuOP":3},"type":"script","flags":{},"scope":"global","command":"// Courtesy of @ohporter\n// Cause lightsources to \"breathe,\" expanding and contracting.\n(async () => {\n    let min = 5;\n    let max = 10;\n    if (game.pulsatingLights) {\n      game.pulsatingLights = false;\n    } else {\n      game.pulsatingLights = true;\n      let glyphLights = [];\n      let glyphColor = \"#5940b5\"\n      let scene = game.scenes.active;\n  \n      canvas.lighting.placeables.forEach(l => { if (l.data.tintColor === glyphColor && l.scene === scene) glyphLights.push(l.id) })\n  \n      const updates = []\n  \n      let radius = min;\n      let increment = true;\n      let interval = setInterval(async () => {\n        glyphLights.forEach(id => {\n          updates.push({ _id: id, dim: radius, bright: radius/2});\n        })\n        await scene.updateEmbeddedEntity(\"AmbientLight\", updates);\n  \n        if (increment) {radius += 1} else {radius -= 1};\n        if (radius === max) {increment = false};\n        if (radius === min) {increment = true};\n        if (!scene.active || !game.pulsatingLights) {\n          // Reset to default glow\n          glyphLights.forEach(id => {\n            updates.push({ _id: id, dim: min, bright: 0});\n          })\n          await scene.updateEmbeddedEntity(\"AmbientLight\", updates);\n          clearInterval(interval);\n        }\n      }, 200);\n    }\n  })()","author":"y5gmtwxmW3A5ZuOP","img":"icons/svg/dice-target.svg","actorIds":[]}
{"_id":"8iEx21HSVOmkbBFE","name":"Combat Tracker AC HP","permission":{"default":0,"y5gmtwxmW3A5ZuOP":3},"type":"script","flags":{},"scope":"global","command":"// Adds the actor's AC to the combat tracker. Then toggles between HP and AC\nconst a = \"attributes.ac.value\";\nconst b = \"attributes.hp.value\";\n\nif (game.combat.settings.resource == a) {\n  game.settings.set('core', 'combatTrackerConfig', {resource: b, skipDefeated: true});\n} else {\n  game.settings.set('core', 'combatTrackerConfig', {resource: a, skipDefeated: true});\n}\nui.combat.updateTrackedResources();\n","author":"y5gmtwxmW3A5ZuOP","img":"icons/svg/dice-target.svg","actorIds":[]}
{"_id":"Cp6zQmvC9KSCEo1s","name":"Toggle Playlist","permission":{"default":0,"y5gmtwxmW3A5ZuOP":3},"type":"script","flags":{},"scope":"global","command":"// get actual pl data from entries\nlet _playlistArray = game.playlists.entries;\nlet _applyChanges = false;\nlet _raw = `\n\n<form>\n    <div class=\"form-group\">\n        <label>Select Playlist:</label>\n        <select id=\"playlist-selection\" name=\"playlist-selection\">\n        {{#each this}}\n            <option> {{this.data.name}} </option>\n        {{/each}}\n        </select>\n    </div>\n</form>\n`\nlet _html = Handlebars.compile(_raw)\nlet d = new Dialog({\n    title: \"Playlist Toggle\",\n    content: _html(_playlistArray),\n    buttons: {\n        toggle: {\n            icon: '<i class=\"fas fa-check\"></i>',\n            label: \"Toggle Selected Playlist\",\n            callback: () => _applyChanges = true\n        },\n    },\n    default: \"toggle\",\n    close: html => {\n        if (_applyChanges) {\n            let _plName = html.find('[name=\"playlist-selection\"]')[0].value || \"none\";\n            let _pl = game.playlists.getName(_plName);\n            if (_pl.playing) {\n                // turn off\n                _pl.stopAll();\n            } else {\n                // turn on\n                _pl.playAll();\n            }\n        }\n    }\n}).render(true);\n","author":"y5gmtwxmW3A5ZuOP","img":"icons/svg/dice-target.svg","actorIds":[]}
{"_id":"PJVvR31x5PNkdWFr","name":"Close All Doors","permission":{"default":0,"y5gmtwxmW3A5ZuOP":3},"type":"chat","flags":{},"scope":"global","command":"/**\n * Closes all doors on the canvas\n * Author: @Atropos#3814\n */\n \ncanvas.walls.updateMany(canvas.scene.data.walls.map(w => {\n  return {_id: w._id, ds: w.ds === 1 ? 0 : w.ds};\n}));\n","author":"y5gmtwxmW3A5ZuOP","img":"icons/svg/dice-target.svg","actorIds":[]}
{"_id":"VXTRsUfomoFN9PVP","name":"Folder Permission","permission":{"default":0,"y5gmtwxmW3A5ZuOP":3},"type":"script","flags":{},"scope":"global","command":"// Provides a prompt to set global permissions to all items within a folder.\n// Prompts the user for the folder name (case sensitive) and the permission level.\n\nconst form = `\n  <div style=\"display: inline-block; width: 100px\">Folder:</div>\n  <input type=\"string\" id=\"folderName\">\n  <br />\n\n  <div style=\"display: inline-block; width: 100px\">Permission:</div>\n  <select id=\"desiredPermission\" />\n    <option value=\"0\">None</option>\n    <option value=\"1\">Limited</option>\n    <option value=\"2\">Observer</option>\n    <option value=\"3\">Owner</option>\n  </select>\n  <br />\n\n  <label>\n  \t<input type=\"checkbox\" id=\"recurse\" checked/>\n    Recurse into subfolders\n\t</label>\n`;\n\nconst dialog = new Dialog({\n  title: \"Set desired permission\",\n  content: form,\n  buttons: {\n    use: {\n      label: \"Apply permissions\",\n      callback: applyPermissions\n    }\n  }\n}).render(true);\n\nfunction applyPermissions(html) {\n  const folderName = html.find(`input#folderName`)[0].value;\n  const permission = html.find(`select#desiredPermission`)[0].value;\n  const recurse = html.find(`input#recurse`)[0].checked;\n  \n  const folders = game.folders.filter(f => f.name === folderName);\n  if (folders.length === 0) {\n    ui.notifications.error(`Your world does not have any folders named '${folderName}'.`);\n  }\n  else if(folders.length > 1) {\n   ui.notifications.error(`Your world has more than one folder named ${folderName}`) \n  }\n  else {\n    repermission(folders[0], permission, recurse);\n    ui.notifications.notify(`Desired permissions were set successfully for  '${folderName}'.`);\n  }\n}\n\nfunction repermission(currentFolder, desiredPermission, recurse) {\n  console.debug(\"Repermissioning: \", currentFolder.name);\n  \n  if (currentFolder.content) {\n    currentFolder.content.map(item => {\n      let newPermissions = duplicate(item.data.permission);\n      newPermissions.default = desiredPermission;\n      console.debug(\"  Item:\", item.data.name);\n      item.update({ permission: newPermissions });\n    });\n  }\n\n  if (currentFolder.children && recurse) {\n    currentFolder.children.map(({ data }) => {\n      repermission(\n        game.folders.entities.filter(f => f.data._id == data._id)[0],\n        desiredPermission,\n        recurse);\n    });\n  }\n}\n","author":"y5gmtwxmW3A5ZuOP","img":"icons/svg/dice-target.svg","actorIds":[]}
{"_id":"bRBhm24NyQELbDti","name":"Create Chat Message","permission":{"default":0,"y5gmtwxmW3A5ZuOP":3},"type":"script","flags":{},"scope":"global","command":"// Courtesy of @errational\n// Creates a chat message.\nconst content = `<p>Monster attacks ${controlledToken.name}</p>`;\n\nChatMessage.create({\n  speaker: ChatMessage.getSpeaker(controlledToken),\n  content: content,\n  type: CONST.CHAT_MESSAGE_TYPES.OTHER\n});","author":"y5gmtwxmW3A5ZuOP","img":"icons/svg/dice-target.svg","actorIds":[]}
{"_id":"dgSOPUXWUK1701PV","name":"Find Lights By Color","permission":{"default":0,"y5gmtwxmW3A5ZuOP":3},"type":"script","flags":{},"scope":"global","command":"// Courtesy of @FloRad\n// Right here's a macro that looks for lights of a certain color, \n// sets a different color and then logs out the ids of the \n// lights it previously found using the marker color\n(async () => {\n    let foundLights = [];\n    let markingColor = \"#00ff00\"\n    let newColor = \"#bbb\"\n    let scene = game.scenes.active;\n\n    canvas.lighting.placeables.forEach(l => { if (l.data.tintColor === markingColor && l.scene === scene) foundLights.push(l.id) })\n\n    const updates = []\n    foundLights.forEach(id => {\n        updates.push({ _id: id, tintColor: newColor });\n    })\n\n    await scene.updateEmbeddedEntity(\"AmbientLight\", updates);\n\n    console.log(foundLights)\n})()","author":"y5gmtwxmW3A5ZuOP","img":"icons/svg/dice-target.svg","actorIds":[]}
{"_id":"e25oI8hASMY8bgu6","name":"Hex Crawler Helper","permission":{"default":0,"y5gmtwxmW3A5ZuOP":3},"type":"script","flags":{},"scope":"global","command":"/*\nRequired Rollable Tables:\n*Wilderness Encounters*\n    coast\n    jungle1\n    jungle2\n    jungle3\n    mountains\n    rivers\n    ruins\n    swamp\n    wasteland\n\n*Other Tables*\n    weather\n    directions\n\n    cache\n    deadexplorers\n\nCache and Deadexplorers are not mandatory, but if you don't want them search the file for // CACHE LINES or // DEAD EXPLORER LINES and comment out the 2 lines below the comments\n\nExplanation of those tables:\nIf you have an encounter table that has the word cache in it, the cache table will be rolled automatically.\n    <br/><span id=\"cache\">The party finds a cache: </span>\nIf you have an encounter table that has DeadExplorers in it, the dead explorer table will be rolled automatically.\n    <br/><span id=\"DeadExplorers\">The party finds: </span> \n\n\nYou can have an automatic moving \"Actual Location\" Marker by creating a Token named \"Actual Location\" and placing it on your hex grid.\nThis will move if the players are \"Lost\". If the players are not lost it will not move.\n\n\n\n*/\n\n\n// Macro requires selecting a token to roll the survival check\n\nlet hexCrawl() => {\n    if (canvas.tokens.controlled.length === 0)\n        return ui.notifications.error(\"Please select the token of the Navigator!\");\n\n    const playerMarker = canvas.scene.data.tokens.find(a => a.name === 'Player Location');\n    const locationMarker = canvas.scene.data.tokens.find(a => a.name === 'Actual Location');\n\n    const gridSize = canvas.grid.size;\n    const vertical = gridSize * 0.866666;\n    const diagVertical = gridSize * 0.433333;\n    const diagHorizontal = gridSize * 0.75;\n\n    // The option values below are the names of your rollable tables for each hex type. If these get changed here you will need to change them in the Survival Check DC section too!\n\n    let pace = 'none';\n    new Dialog({\n        title: `Hex Crawl Helper`,\n        content: `\n        <form>\n            <div class=\"form-group\">\n                <label>Hex Type:</label>\n                <select id=\"hex-type\" name=\"hex-type\">\n                    <option value=\"coast\">Coast</option>\n                    <option value=\"jungle1\">Jungle: No Undead</option>\n                    <option value=\"jungle2\">Jungle: Lesser Undead</option>\n                    <option value=\"jungle3\">Jungle: Greater Undead</option>\n                    <option value=\"mountains\">Mountains</option>\n                    <option value=\"rivers\">River</option>\n                    <option value=\"ruins\">Ruins</option>\n                    <option value=\"swamp\">Swamp</option>\n                    <option value=\"wasteland\">Wasteland</option>\n                </select>\n            </div>\n            <div class=\"form-group\">\n                <label>Travel Direction:</label>\n                <select id=\"travel-direction\" name=\"travel-direction\">\n                    <option value=\"North\">North</option>\n                    <option value=\"Northeast\">Northeast</option>\n                    <option value=\"Southeast\">Southeast</option>\n                    <option value=\"South\">South</option>\n                    <option value=\"Southwest\">Southwest</option>\n                    <option value=\"Northwest\">Northwest</option>\n                </select>\n            </div>\n            <div class=\"form-group\">\n                <label>Travel Type:</label>\n                <select id=\"travel-type\" name=\"travel-type\">\n                    <option value=\"on-foot\">On Foot</option>\n                    <option value=\"canoe\">By Canoe</option>\n                </select>\n            </div>\n        </form>\n        `,\n        buttons: {\n            slow: {\n                icon: \"<i class='fas fa-user-ninja'></i>\",\n                label: `Slow Pace`,\n                callback: () => pace = 'slow'\n            },\n            average: {\n                icon: \"<i class='fas fa-hiking'></i>\",\n                label: `Average Pace`,\n                callback: () => pace = 'average'\n            },\n            fast: {\n                icon: \"<i class='fas fa-running'></i>\",\n                label: `Fast Pace`,\n                callback: () => pace = 'fast'\n            }\n        },\n        default: \"average\",\n        close: html => {\n            // set variables\n            let hexType = html.find('[name=\"hex-type\"]')[0].value;\n            let travelType = html.find('[name=\"travel-type\"]')[0].value;\n            let playerDirection = html.find('[name=\"travel-direction\"]')[0].value;\n            const weatherTable = game.tables.entities.find(t => t.name === \"weather\");\n            const directionTable = game.tables.entities.find(t => t.name === \"directions\");\n            const cacheTable = game.tables.entities.find(t => t.name === \"cache\");\n            const deadExplorerTable = game.tables.entities.find(t => t.name === \"deadexplorers\");\n            const encounterTable = game.tables.entities.find(t => t.name === hexType);\n            let weatherRoll = weatherTable.roll()[1].text;\n            let lostDirection = directionTable.roll()[1].text;\n            let msgContent = '<strong>Weather</strong> ' + weatherRoll + '<br/><br/>';\n            let navigator = Actors.instance.get(canvas.tokens.controlled[0].data.actorId);\n            let wis = navigator.data.data.abilities.wis.mod;\n            let survival = new Roll(`1d20`).roll().total + wis;\n            let slowPace = new Roll(`1d4`).roll().total;\n            let fastPace = new Roll(`1d2`).roll().total;\n            let hexesMoved = 1;\n            let encounter = '';\n            let hexText = 'hexes';\n\n            if (travelType === 'canoe') {\n                hexesMoved++;\n            }\n\n            // build pace message and hex movement\n            if (pace === 'slow') {\n                if (slowPace === 1)\n                    hexesMoved--;\n                if (hexesMoved === 1)\n                    hexText = 'hex';\n                msgContent += '<strong>Slow pace:</strong> Can hide from encounters or approach stealthily.<br/><br/><strong>Party can move:</strong> ' + hexesMoved + ' ' + hexText + '.<br/><br/>';\n                survival += 5;\n            } else if (pace === 'average') {\n                if (hexesMoved === 1)\n                    hexText = 'hex';\n                msgContent += '<strong>Average pace:</strong> For rivers, upstream and downstream have no effect, and waterfalls occur every 10 to 20 miles (requiring portage of canoes).<br/><br/><strong>Party can move:</strong> ' + hexesMoved + ' ' + hexText + '.<br/><br/>';\n            } else if (pace === 'fast') {\n                if (fastPace === 1)\n                    hexesMoved++;\n                if (hexesMoved === 1)\n                    hexText = 'hex';\n                msgContent += '<strong>Fast pace:</strong> -5 to passive Perception.<br/><br/><strong>Party can move:</strong> ' + hexesMoved + ' ' + hexText + '.<br/><br/>';\n                survival -= 5;\n            } else {\n                return;\n            }\n\n            // Survival Check DC for each hex type. If selected token rolls under DC the party is lost!\n            if (((hexType === 'coast' || hexType === 'ruins') && survival < 10) || ((hexType === 'jungle1' || hexType === 'jungle2' || hexType === 'jungle3' || hexType === 'mountains' || hexType === 'rivers' || hexType === 'swamp' || hexType === 'wasteland') && survival < 15)) {\n                msgContent += '<strong>Party is Lost:</strong> Move actual location ' + hexesMoved + ' ' + hexText + ' to the ' + lostDirection + '<br/><br/>';\n                if (locationMarker) {\n                    const locToken = canvas.tokens.get(locationMarker._id);\n                    switch (lostDirection) {\n                        case 'South':\n                            locToken.update({\n                                x: locToken.x,\n                                y: locToken.y + (vertical * hexesMoved)\n                            });\n                            break;\n\n                        case 'Southwest':\n                            locToken.update({\n                                x: locToken.x - (diagHorizontal * hexesMoved),\n                                y: locToken.y + (diagVertical * hexesMoved)\n                            });\n                            break;\n\n                        case 'Southeast':\n                            locToken.update({\n                                x: locToken.x + (diagHorizontal * hexesMoved),\n                                y: locToken.y + (diagVertical * hexesMoved)\n                            });\n                            break;\n\n                        case 'North':\n                            locToken.update({\n                                x: locToken.x,\n                                y: locToken.y - (vertical * hexesMoved)\n                            });\n                            break;\n\n                        case 'Northwest':\n                            locToken.update({\n                                x: locToken.x - (diagHorizontal * hexesMoved),\n                                y: locToken.y - (diagVertical * hexesMoved)\n                            });\n                            break;\n\n                        case 'Northeast':\n                            locToken.update({\n                                x: locToken.x + (diagHorizontal * hexesMoved),\n                                y: locToken.y - (diagVertical * hexesMoved)\n                            });\n                            break;\n\n                        default:\n                            break;\n                    }\n                }\n                if (playerMarker) {\n                    const playerToken = canvas.tokens.get(playerMarker._id);\n                    switch (playerDirection) {\n                        case 'South':\n                            playerToken.update({\n                                x: playerToken.x,\n                                y: playerToken.y + (vertical * hexesMoved)\n                            });\n                            break;\n\n                        case 'Southwest':\n                            playerToken.update({\n                                x: playerToken.x - (diagHorizontal * hexesMoved),\n                                y: playerToken.y + (diagVertical * hexesMoved)\n                            });\n                            break;\n\n                        case 'Southeast':\n                            playerToken.update({\n                                x: playerToken.x + (diagHorizontal * hexesMoved),\n                                y: playerToken.y + (diagVertical * hexesMoved)\n                            });\n                            break;\n\n                        case 'North':\n                            playerToken.update({\n                                x: playerToken.x,\n                                y: playerToken.y - (vertical * hexesMoved)\n                            });\n                            break;\n\n                        case 'Northwest':\n                            playerToken.update({\n                                x: playerToken.x - (diagHorizontal * hexesMoved),\n                                y: playerToken.y - (diagVertical * hexesMoved)\n                            });\n                            break;\n\n                        case 'Northeast':\n                            playerToken.update({\n                                x: playerToken.x + (diagHorizontal * hexesMoved),\n                                y: playerToken.y - (diagVertical * hexesMoved)\n                            });\n                            break;\n\n                        default:\n                            break;\n                    }\n                }\n            } else {\n                if (playerMarker && locationMarker) {\n                    const locToken = canvas.tokens.get(locationMarker._id);\n                    const playerToken = canvas.tokens.get(playerMarker._id);\n\n                    switch (playerDirection) {\n                        case 'South':\n                            playerToken.update({\n                                x: locToken.x,\n                                y: locToken.y + (vertical * hexesMoved)\n                            });\n                            locToken.update({\n                                x: locToken.x,\n                                y: locToken.y + (vertical * hexesMoved)\n                            });\n                            break;\n\n                        case 'Southwest':\n                            playerToken.update({\n                                x: locToken.x - (diagHorizontal * hexesMoved),\n                                y: locToken.y + (diagVertical * hexesMoved)\n                            });\n                            locToken.update({\n                                x: locToken.x - (diagHorizontal * hexesMoved),\n                                y: locToken.y + (diagVertical * hexesMoved)\n                            });\n                            break;\n\n                        case 'Southeast':\n                            playerToken.update({\n                                x: locToken.x + (diagHorizontal * hexesMoved),\n                                y: locToken.y + (diagVertical * hexesMoved)\n                            });\n                            locToken.update({\n                                x: locToken.x + (diagHorizontal * hexesMoved),\n                                y: locToken.y + (diagVertical * hexesMoved)\n                            });\n                            break;\n\n                        case 'North':\n                            playerToken.update({\n                                x: locToken.x,\n                                y: locToken.y - (vertical * hexesMoved)\n                            });\n                            locToken.update({\n                                x: locToken.x,\n                                y: locToken.y - (vertical * hexesMoved)\n                            });\n                            break;\n\n                        case 'Northwest':\n                            playerToken.update({\n                                x: locToken.x - (diagHorizontal * hexesMoved),\n                                y: locToken.y - (diagVertical * hexesMoved)\n                            });\n                            locToken.update({\n                                x: locToken.x - (diagHorizontal * hexesMoved),\n                                y: locToken.y - (diagVertical * hexesMoved)\n                            });\n                            break;\n\n                        case 'Northeast':\n                            playerToken.update({\n                                x: locToken.x + (diagHorizontal * hexesMoved),\n                                y: locToken.y - (diagVertical * hexesMoved)\n                            });\n                            locToken.update({\n                                x: locToken.x + (diagHorizontal * hexesMoved),\n                                y: locToken.y - (diagVertical * hexesMoved)\n                            });\n                            break;\n\n                        default:\n                            break;\n                    }\n                }\n            }\n\n            msgContent += '<strong>Morning Encounter:</strong> ';\n\n            if (new Roll(`1d20`).roll().total > 15) {\n                encounter = encounterTable.roll()[1].text;\n                msgContent += encounter;\n                // CACHE LINES comment out the next 2 lines if you don't want to use a cache table!\n                if (encounter.indexOf('cache') > -1)\n                    msgContent += cacheTable.roll()[1].text + '<br/><br/>';\n                // DEAD EXPLORER LINES comment out the next 2 lines if you don't want to use a dead explorer table!\n                if (encounter.indexOf('DeadExplorers') > -1)\n                    msgContent += deadExplorerTable.roll()[1].text + '<br/><br/>';\n                msgContent += '<strong>Afternoon Encounter:</strong> ';\n            } else {\n                msgContent += 'None.<br/><br/><strong>Afternoon Encounter:</strong> ';\n            }\n\n            if (new Roll(`1d20`).roll().total > 15) {\n                encounter = encounterTable.roll()[1].text;\n                msgContent += encounter;\n                // CACHE LINES comment out the next 2 lines if you don't want to use a cache table!\n                if (encounter.indexOf('cache') > -1)\n                    msgContent += cacheTable.roll()[1].text + '<br/><br/>';\n                // DEAD EXPLORER LINES comment out the next 2 lines if you don't want to use a dead explorer table!\n                if (encounter.indexOf('DeadExplorers') > -1)\n                    msgContent += deadExplorerTable.roll()[1].text + '<br/><br/>';\n                msgContent += '<strong>Evening Encounter:</strong> ';\n            } else {\n                msgContent += 'None.<br/><br/><strong>Evening Encounter:</strong> ';\n            }\n\n            if (new Roll(`1d20`).roll().total > 15) {\n                encounter = encounterTable.roll()[1].text;\n                msgContent += encounter;\n                // CACHE LINES comment out the next 2 lines if you don't want to use a cache table!\n                if (encounter.indexOf('cache') > -1)\n                    msgContent += cacheTable.roll()[1].text + '<br/><br/>';\n                // DEAD EXPLORER LINES comment out the next 2 lines if you don't want to use a dead explorer table!\n                if (encounter.indexOf('DeadExplorers') > -1)\n                    msgContent += deadExplorerTable.roll()[1].text + '<br/><br/>';\n            } else {\n                msgContent += 'None.';\n            }\n\n            // create the message\n            let chatData = {\n                content: msgContent,\n                whisper: game.users.entities.filter(u => u.isGM).map(u => u._id)\n            };\n            ChatMessage.create(chatData, {});\n        }\n    }).render(true);\n}\n\nhexCrawl();","author":"y5gmtwxmW3A5ZuOP","img":"icons/svg/dice-target.svg","actorIds":[]}
{"_id":"fYT65nJz51J74ymJ","name":"Jukebox","permission":{"default":0,"y5gmtwxmW3A5ZuOP":3},"type":"script","flags":{},"scope":"global","command":"/**\n * Quickly play from a list of sound effects and set their audio level. (does not loop)\n * Author: Rockshow\n */\n\nlet playlist = {\n  'twigs breaking': 'audio/twigs_1.mp3',\n  'door opening': 'sounds/lock.wav',\n};\n\nlet optionList;\nfor (let [key, value] of Object.entries(playlist)) {\n  optionList += `<option value=\"${value}\">${key}</option>`;\n}\n\nlet applyChanges = false;\nnew Dialog({\n  title: `Audio chosing form`,\n  content: `\n    <form>\n      <div class=\"form-group\">\n        <label>Canzone:</label>\n        <select id=\"idcanzone\" name=\"idcanzone\">\n          ${optionList}\n        </select>\n      </div>\n   \n        <div class=\"form-group\">\n        <label for=\"vol\">Volume:</label>\n           <div class=\"form-fields\">\n            <input type=\"range\" id=\"vol\" name=\"vol\" min=\"0\" max=\"8\" value=\"1\" step=\"0.2\" data-dtype=\"Number\">\n            <span class=\"range-value\" id=\"demo\">1</span>\n           </div>\n        </div>\n </form> \n<script>\nvar slider = document.getElementById(\"vol\");\nvar output = document.getElementById(\"demo\");\noutput.innerHTML = slider.value;\n\nslider.oninput = function() {\n  output.innerHTML = this.value;\n}\n</script>\n          `,\n  buttons: {\n    no: {\n      icon: \"<i class='fas fa-times'></i>\",\n      label: `Cancel Changes`\n        },\n    yes: {\n      icon: \"<i class='fas fa-check'></i>\",\n      label: `Apply Changes`,\n      callback: () => applyChanges = true\n         },\n           },\n  default: \"yes\",\n  close: html => {\n    if (applyChanges) {\n    let canzone= html.find('[name=\"idcanzone\"]')[0].value || \"none\";\n    let vol1= html.find('[name=\"vol\"]')[0].value || \"none\";\n    AudioHelper.play({src: canzone, volume:vol1, autoplay: true, loop: false}, true);\n                      }\n                 }\n  }).render(true);\n","author":"y5gmtwxmW3A5ZuOP","img":"icons/svg/dice-target.svg","actorIds":[]}
{"_id":"mPIqhwFL3h5W9d2t","name":"Share Image Via URL","permission":{"default":0,"y5gmtwxmW3A5ZuOP":3},"type":"script","flags":{},"scope":"global","command":"/**\n * Share an image to all players when you have an image URL\n * Author: @Krishmero#1792\n */\n\nlet imagePopup = (imageUrl) => {\n\t// Display the image popout and share it.\n\tconst ip = new ImagePopout(imageUrl);\n\tip.render(true);\n\tip.shareImage();\n};\n\nlet chatDialog = (imageUrl) => {\n\tChatMessage.create({\n\t\tuser: game.user._id,\n\t\tcontent: `<img src=\"${imageUrl}\" />`,\n\t\ttype: CONST.CHAT_MESSAGE_TYPES.OOC\n\t});\n};\n\nlet selectOptions = game.user.isGM ? `\n<div style=\"display: inline-block; width: 100%; margin-bottom: 10px\">\n\t<label for=\"output-options\" style=\"margin-right: 10px\">Output Options:</label>\n\t<select id=\"output-options\" />\n\t\t<option value=\"popup\">Popup</option>\n\t\t<option value=\"chat\">Chat</option>\n\t\t<option value=\"both\">Both</option>\n\t</select>\n</div>\n<br />\n` : '';\n\nnew Dialog({\n\ttitle: `Share Image via URL`,\n\tcontent: `\n\t\t<form>\n\t\t\t${selectOptions}\n\t\t\t<div style=\"display: flex; width: 100%; margin-bottom: 10px\">\n\t\t\t\t<label for=\"image-url\" style=\"white-space: nowrap; margin-right: 10px; padding-top:4px\">Image URL:</label>\n\t\t\t\t<input type=\"text\" id=\"image-url\" name=\"image-url\" />\n\t\t\t</div>\n\t\t</form>\n\t`,\n\tbuttons: {\n\t\tyes: {\n\t\t\ticon: \"<i class='fas fa-check'></i>\",\n\t\t\tlabel: `Share`,\n\t\t\tcallback: (html) => {\n\t\t\t\tlet imageUrl = html.find('#image-url').val();\n\t\t\t\tlet permission = html.find('select#output-options')[0]?.value || null;\n\t\t\t\tif (!imageUrl) {\n\t\t\t\t\treturn ui.notifications.info(\"You did not provide a valid image.\");\n\t\t\t\t}\n\t\t\t\tif (game.user.isGM && ['popup', 'both'].includes(permission)) {\n\t\t\t\t\timagePopup(imageUrl);\n\t\t\t\t}\n\t\t\t\tif (!game.user.isGM || ['chat', 'both'].includes(permission)) {\n\t\t\t\t\tchatDialog(imageUrl);\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\t\tno: {\n\t\t\ticon: \"<i class='fas fa-times'></i>\",\n\t\t\tlabel: `Cancel`\n\t\t},\n\t},\n\tdefault: \"yes\"\n}).render(true)\n","author":"y5gmtwxmW3A5ZuOP","img":"icons/svg/dice-target.svg","actorIds":[]}
{"_id":"qlx6N8QD6QliPQbu","name":"Create Ambient Light","permission":{"default":0,"y5gmtwxmW3A5ZuOP":3},"type":"script","flags":{},"scope":"global","command":"// Create a (pre-configured) lightsource on the current scene. \n// This example is a blue light for \"activating a stargate.\"\n\nAmbientLight.create({\n  t: \"l\", // l for local. The other option is g for global.\n  x: 1100, // horizontal positioning\n  y: 1150, // vertical positioning\n  dim: 20.50, // the total radius of the light, including where it is dim.\n  bright: 19.00, // the bright radius of the light\n  angle: 360, // the coverage of the light. (Try 30 for a \"spotlight\" effect.)\n  rotation: 0, // the beam direction of the light in degrees (if its angle is less than 360 degrees.) \n               // Oddly, degrees are counted from the 6 o'clock position.\n  tintColor: \"#0080FF\", // Light coloring.\n  tintAlpha: 0.5 // Light opacity (or \"brightness,\" depending on how you think about it.) \n});\n","author":"y5gmtwxmW3A5ZuOP","img":"icons/svg/dice-target.svg","actorIds":[]}
{"_id":"r8G0g61ikT9mJJwF","name":"Move Walls","permission":{"default":0,"y5gmtwxmW3A5ZuOP":3},"type":"script","flags":{},"scope":"global","command":"/* From: @(Busy) Gen Kitty (she/her)\nTo move each node on both axes, you need all 4 parameters listed. \nIn this case, he wanted to move all the walls up and to the left and \nthe foundry grid is sorta vertically flipped to what you'd expect, \nwhich is why all of the operators are \"-=\" If you wanted to move them \nin different directions it'd just be a matter of changing the operator \nnext to the equals sign.\n\nEach argument is a node's X or Y position, and each wall segment has two nodes. \n0 = Node 1 X \n1 = Node 1 Y \n2 = Node 2 X \n3 = Node 2 Y\n*/\n\nlet walls = canvas.scene.data.walls.map(w => {\n  w = duplicate(w);\n  w.c[0] -= 50;\n  w.c[1] -= 50;\n  w.c[2] -= 50;\n  w.c[3] -= 50;\n  return w;\n});\ncanvas.scene.update({walls: walls});\n","author":"y5gmtwxmW3A5ZuOP","img":"icons/svg/dice-target.svg","actorIds":[]}
{"name":"Hide Video Boxes","permission":{"default":0,"y5gmtwxmW3A5ZuOP":3},"type":"script","flags":{},"scope":"global","command":"// Hides the camera boxes. If you just want to collapse the boxes to the name, change \"camera-views\" to \"video-container\"\n// Note: this has to be re-ran when the UI refreshes.\n\nlet cameras = document.getElementById(\"camera-views\");\ncameras.style.display = cameras.style.display === \"none\" ? \"flex\" : \"none\";\n","author":"y5gmtwxmW3A5ZuOP","img":"icons/svg/dice-target.svg","actorIds":[],"_id":"ra2KPziISGyrVcK2"}
{"_id":"wosXzUFEMQLD84so","name":"Ambient Light Quick Edit","permission":{"default":0,"y5gmtwxmW3A5ZuOP":3},"type":"script","flags":{},"scope":"global","command":"let macroName = \"AmbientLight QuickEditor\"\nlet macroEndLog = \"---------------------------------------------\"\n\nlet i=0;\nlet lights = canvas.lighting.objects.children;\nlet lightSelected = lights[0];\nlet selectOptions = \"\";\nlet lightSelectedAngle = 0;\nlet lightSelectedBright = 0;\nlet lightSelectedDim = 0;\nlet lightSelectedRotation = 0;\nlet lightSelectedTintAlpha = 1;\nlet lightSelectedTintColor = \"\";\n\nconsole.log(\"---------------------------------------------\");\nconsole.log(`${macroName} by PaperPunk`);\nconsole.log(\"---------------------------------------------\");\nconsole.log(`${macroName} | Start`);\n\nconst drawingDetails = {\n      author: game.user._id,\n      fillAlpha: 0,\n      fillColor: \"#808080\",\n      fillType: 1,\n      fontFamily: \"FontAwesome\",\n      fontSize: 24,\n      height: 48,\n      hidden: false,\n      locked: false,\n      rotation: 0,\n      strokeAlpha: 1,\n      strokeColor: \"#000000\",\n      strokeWidth: 2,\n      text: i,\n      textAlpha: 1,\n      textColor: \"#ffffff\",\n      type: \"r\",\n      width: 48,\n      //x: 250,\n      x: lightSelected.x-24,\n      //y: 250\n      y: lightSelected.y+25\n};\n\n//let d = Drawing.create(drawingDetails);\n//d.update({\"x\": lights[i].x-24, \"y\": lights[i].y+25, \"text\": i});\n\nfor (i= 0; i< lights.length; i++) {\n selectOptions += `<option value=\"${i}\">AmbientLight ${i}</option>`;\n}\n\nconst htmlLightSelection = `\n    <form>\n      <h2>Select your light.</h2>\n      <div class=\"form-group\">\n        <label>Light:</label>\n        <select id=\"light-selector\" name=\"light-selector\">\n          ${selectOptions}\n        </select>\n      </div>\n    </form>\n    `;\n\nlet dialogSelector = new Dialog({\n  title: `${macroName}`,\n  content: htmlLightSelection,\n  buttons: {\n    confirm: {\n      icon: \"<i class='fas fa-tick'></i>\",\n      label: `Confirm`,\n      callback: htmlLightSelection => { \n        lightSelected = (htmlLightSelection.find('[name=\"light-selector\"]')[0].value)\n        lightSelectedAngle = lights[lightSelected].data.angle;\n        lightSelectedBright = lights[lightSelected].data.bright;\n        lightSelectedDim = lights[lightSelected].data.dim;\n        lightSelectedRotation = lights[lightSelected].data.rotation;\n        lightSelectedTintAlpha = lights[lightSelected].data.tintAlpha;\n        lightSelectedTintColor = lights[lightSelected].data.tintColor;\n        //console.log(`${macroName} | lightSelected = ${lightSelected}`);\n        //console.log(`${macroName} | lightSelectedBright = ${lightSelectedBright}`);\n        dialogEditor.render(true);\n      }\n    },\n    cancel: {\n      icon: \"<i class='fas fa-times'></i>\",\n      label: `Cancel`,\n      callback: () => {\n        console.log(`${macroName} | Goodbye`);\n        console.log(macroEndLog);\n      }\n    },\n  },\n  default: \"cancel\",\n  //close: () => console.log(\"AmbientLight QuickEditor | Dialog Window Closed\")\n});\n\nlet dialogEditor = new Dialog({\n  title: `${macroName}`,\n  content: `<h2>Edit your light.</h2>\n      <p>Emission Angle: ${lightSelectedAngle}</p>\n      <p>Bright light distance: ${lightSelectedBright}</p>\n      <p>Dim light distance: ${lightSelectedDim}</p>\n      <p>Rotation CW from down: ${lightSelectedRotation}</p>\n      <p>Tint Alpha: ${lightSelectedAngle}</p>\n      <p>Tint Color HexCode: ${lightSelectedAngle}</p>`,\n  buttons: {\n    rot5cw: {\n      icon: \"<i class='fas fa-redo'></i>\",\n      label: `Rotate 5* CW`,\n      callback: () => { \n        let rot = lights[lightSelected].data.rotation;\n        lights[lightSelected].update({\"rotation\":rot+5});\n        dialogEditor.render(true);\n      }\n    },\n    rot15cw: {\n      icon: \"<i class='fas fa-redo'></i>\",\n      label: `Rotate 15* CW`,\n      callback: () => { \n        let rot = lights[lightSelected].data.rotation;\n        lights[lightSelected].update({\"rotation\":rot+15});\n        dialogEditor.render(true);\n      }\n    },\n    rot45cw: {\n      icon: \"<i class='fas fa-redo'></i>\",\n      label: `Rotate 45* CW`,\n      callback: () => { \n        let rot = lights[lightSelected].data.rotation;\n        lights[lightSelected].update({\"rotation\":rot+45});\n        dialogEditor.render(true);\n      }\n    },\n    rot5ccw: {\n      icon: \"<i class='fas fa-undo'></i>\",\n      label: `Rotate 5* CCW`,\n      callback: () => { \n        let rot = lights[lightSelected].data.rotation;\n        lights[lightSelected].update({\"rotation\":rot-5});\n        dialogEditor.render(true);\n      }\n    },\n    rot15ccw: {\n      icon: \"<i class='fas fa-undo'></i>\",\n      label: `Rotate 15* CCW`,\n      callback: () => { \n        let rot = lights[lightSelected].data.rotation;\n        lights[lightSelected].update({\"rotation\":rot-15});\n        dialogEditor.render(true);\n      }\n    },\n    rot45ccw: {\n      icon: \"<i class='fas fa-undo'></i>\",\n      label: `Rotate 45* CCW`,\n      callback: () => { \n        let rot = lights[lightSelected].data.rotation;\n        lights[lightSelected].update({\"rotation\":rot-45});\n        dialogEditor.render(true);\n      }\n    },\n    brightup: {\n      icon: \"<i class='fas fa-circle'></i>\",\n      label: `Increase Bright by 5`,\n      callback: () => { \n        let bright = lights[lightSelected].data.bright;\n        lights[lightSelected].update({\"bright\":bright+5});\n        dialogEditor.render(true);\n      }\n    },\n    brightdown: {\n      icon: \"<i class='fas fa-circle'></i>\",\n      label: `Decrease Bright by 5`,\n      callback: () => { \n        let bright = lights[lightSelected].data.bright;\n        lights[lightSelected].update({\"bright\":bright-5});\n        dialogEditor.render(true);\n      }\n    },\n    brightoff: {\n      icon: \"<i class='fas fa-circle'></i>\",\n      label: `Remove Bright Light`,\n      callback: () => { \n        lights[lightSelected].update({\"bright\":0});\n        dialogEditor.render(true);\n      }\n    },\n    dimup: {\n      icon: \"<i class='fas fa-dot-circle'></i>\",\n      label: `Increase Dim by 5`,\n      callback: () => { \n        let dim = lights[lightSelected].data.dim;\n        lights[lightSelected].update({\"dim\":dim+5});\n        dialogEditor.render(true);\n      }\n    },\n    dimdown: {\n      icon: \"<i class='fas fa-dot-circle'></i>\",\n      label: `Decrease Dim by 5`,\n      callback: () => { \n        let dim = lights[lightSelected].data.dim;\n        lights[lightSelected].update({\"dim\":dim-5});\n        dialogEditor.render(true);\n      }\n    },\n    dimoff: {\n      icon: \"<i class='fas fa-dot-circle'></i>\",\n      label: `Remove Dim Light`,\n      callback: () => { \n        lights[lightSelected].update({\"dim\":0});\n        dialogEditor.render(true);\n      }\n    },\n    emit15: {\n      icon: \"<i class='fas fa-rss'></i>\",\n      label: `Emission Angle 15*`,\n      callback: () => { \n        lights[lightSelected].update({\"angle\":15});\n        dialogEditor.render(true);\n      }\n    },\n    emit45: {\n      icon: \"<i class='fas fa-rss'></i>\",\n      label: `Emission Angle 45*`,\n      callback: () => { \n        lights[lightSelected].update({\"angle\":45});\n        dialogEditor.render(true);\n      }\n    },\n    emit90: {\n      icon: \"<i class='fas fa-rss'></i>\",\n      label: `Emission Angle 90*`,\n      callback: () => { \n        lights[lightSelected].update({\"angle\":90});\n        dialogEditor.render(true);\n      }\n    },\n    emit180: {\n      icon: \"<i class='fas fa-rss'></i>\",\n      label: `Emission Angle 180*`,\n      callback: () => { \n        lights[lightSelected].update({\"angle\":180});\n        dialogEditor.render(true);\n      }\n    },\n    emit270: {\n      icon: \"<i class='fas fa-rss'></i>\",\n      label: `Emission Angle 270*`,\n      callback: () => { \n        lights[lightSelected].update({\"angle\":270});\n        dialogEditor.render(true);\n      }\n    },\n    emit360: {\n      icon: \"<i class='fas fa-rss'></i>\",\n      label: `Emission Angle 360*`,\n      callback: () => { \n        lights[lightSelected].update({\"angle\":360});\n        dialogEditor.render(true);\n      }\n    },\n    back: {\n      icon: \"<i class='fas fa-reply'></i>\",\n      label: `Back`,\n      callback: () => dialogSelector.render(true)\n    },\n    close: {\n      icon: \"<i class='fas fa-tick'></i>\",\n      label: `Close`\n    },\n  },\n  default: \"close\",\n  close: () => {\n    console.log(`${macroName} | Goodbye`);\n    console.log(macroEndLog);\n  }\n});\n\ndialogSelector.render(true);\n","author":"y5gmtwxmW3A5ZuOP","img":"icons/svg/dice-target.svg","actorIds":[]}
