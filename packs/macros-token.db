{"_id":"3NUj7EzuLPgRIhBk","name":"Bulk Change Initiative","type":"script","author":"y5gmtwxmW3A5ZuOP","img":"icons/svg/dice-target.svg","scope":"global","command":"//for the selected tokens, adjust their initiative by X.  Use with selective-select to modify all enemies, friendlies\n\nlet applyChanges = false;\n\nnew Dialog({\n    title: `Bulk change initiative`,\n    content: `\n      <form>\n        <div class=\"form-group\">\n          <label>Initiative adjustment:</label>\n          <input id=\"init-adjust\" name=\"init-adjust\" type=\"number\" step=\"1\" value=\"0\"/>\n        </div>\n      </form>\n      `,\n    buttons: {\n        yes: {\n            icon: \"<i class='fas fa-check'></i>\",\n            label: `Apply Changes`,\n            callback: () => applyChanges = true\n        },\n        no: {\n            icon: \"<i class='fas fa-times'></i>\",\n            label: `Cancel Changes`\n        },\n    },\n    default: \"yes\",\n    close: html => {\n        if (applyChanges) {\n            if(!game.combat) return;\n            const initadjust = parseInt(html.find('[name=\"init-adjust\"]')[0].value || \"0\");\n            const updates = canvas.tokens.controlled.reduce((acc, t) => {\n                if(!t.combatant) return acc;\n                acc.push({_id: t.combatant.id, initiative: initadjust});\n                return acc;  \n            },[]);\n            game.combat.updateEmbeddedDocuments(\"Combatant\", updates)\n        }\n    }   \n}).render(true);","folder":null,"sort":0,"permission":{"default":0,"y5gmtwxmW3A5ZuOP":3},"flags":{"core":{"sourceId":"Macro.dZ7vEAaKXJcpnL68"}}}
{"name":"Token Reiconize","permission":{"default":0,"y5gmtwxmW3A5ZuOP":3},"type":"script","flags":{"core":{"sourceId":"Macro.cRA2xgOGCm81mqfu"}},"scope":"global","command":"/*\nThe purpose of this macro is to trigger VTTA-Iconizer to update icons on tokens. This macro goes through\nevery actor in the game and changes the name of every item, feature, spell, etc. by adding a '~' to the end\nthen removing the '~' from the end. This does NOT update actors in a compendium.\n\nThis was developed primarily to update actors after updating a custom dictionary used by VTTA-Iconizer.\n\nA dialog will be displayed to allow you to go forward with the update or cancel. Once the update starts, a\nnew dialog will be shown with a cancel button. That cancel button is stupid and doesn't like to be clicked.\nYou'll have to click it a bunch to convince it to stop looping.\n*/\n\nlet canceled = false\nlet totalItemsProcessed = 0\nlet totalActorsProcessed = 0\n\nfunction CancelTouching() {\n    canceled = true\n}\nDialogQuery()\n\nfunction DialogResults() {\n    let dialog = new Dialog({\n        content: `<p>Processing of ${totalActorsProcessed} actors and ${totalItemsProcessed} items complete</p>`,\n        title: 'Reiconizer Done',\n        buttons: {\n            one: {\n                label: \"Done\"\n            },\n        },\n    })\n    dialog.render(true)\n}\n\nasync function DialogQuery() {\n    return new Dialog({\n        title: `Reiconizer`,\n        content: `<p>Is your world backed up? Do you wish to activate Iconizer?</p>`,\n        buttons: {\n            one: {\n                icon: `<i class=\"fas fa-check\"></i>`,\n                label: \"Continue\",\n                callback: async() => {\n                    await TouchActors()\n                    DialogResults()\n                }\n            },\n            two: {\n                icon: `<i class=\"fas fa-times\"></i>`,\n                label: \"Cancel\",\n                callback: () => {}\n            }\n        },\n        default: \"Cancel\",\n    }).render(true);\n}\n\nfunction DialogWorking() {\n    let dialog = new Dialog({\n        title: `Reiconizer Working`,\n        content: `<p>Task in progress</p>`,\n        buttons: {\n            one: {\n                icon: `<i class=\"fas fa-times\"></i>`,\n                label: \"Cancel (You might have to click me a bunch)\",\n                callback: () => {\n                    CancelTouching()\n                }\n            },\n        },\n    })\n\n    dialog.position.height = 'Auto'\n    dialog.render(true)\n    return dialog\n}\n\nasync function TouchActors() {\n    let working = DialogWorking()\n    let remaining = game.actors.entries.length\n    for (let _actor of game.actors.entries) {\n        if (!canceled) {\n            try {\n                for (let item of _actor.items.entries) {\n                    if (!canceled) {\n                        working.data.content = `<p>Processing: ${_actor.name}</p><p>Remaining: ${remaining}</p><p>Item: ${item.name}</p>`\n                        working.render(true)\n                        let update = {\n                            _id: item._id,\n                            name: item.name + '~'\n                        }\n                        await _actor.updateEmbeddedEntity('OwnedItem', update)\n                        update.name = update.name.slice(0, -1)\n                        await _actor.updateEmbeddedEntity('OwnedItem', update)\n                        totalItemsProcessed++\n                    }\n                }\n            } catch (err) {\n                console.log(`Error processing ${_actor.name}, ERROR: ${err}`)\n            }\n            remaining--\n            totalActorsProcessed++\n        }\n    }\n\n    working.close()\n}","author":"y5gmtwxmW3A5ZuOP","img":"icons/svg/dice-target.svg","actorIds":[],"_id":"ChZwQULAXvLnylbC"}
{"_id":"Cro7DdjJpepCX22U","name":"Light Picker","type":"script","author":"y5gmtwxmW3A5ZuOP","img":"icons/svg/dice-target.svg","scope":"global","command":"function tokenUpdate(data) {\n  canvas.tokens.controlled.map(token => token.document.update({light: data}));\n}\n\nlet torchAnimation = {\"type\": \"torch\", \"speed\": 1, \"intensity\": 1, \"reverse\": false};\n\nlet dialogEditor = new Dialog({\n  title: `Token Light Picker`,\n  content: `Pick the light source the selected token is holding.`,\n  buttons: {\n    none: {\n      label: `None`,\n      callback: () => {\n        tokenUpdate({\"dim\": 0, \"bright\": 0, \"angle\": 360, \"luminosity\": 0.5});\n        dialogEditor.render(true);\n      }\n    },\n    torch: {\n      label: `Torch`,\n      callback: () => {\n        tokenUpdate({\"dim\": 40, \"bright\": 20, \"angle\": 360, \"luminosity\": 0.5, \"animation\": torchAnimation});\n        dialogEditor.render(true);\n      }\n    },\n    light: {\n      label: `Light cantrip`,\n      callback: () => {\n        tokenUpdate({\"dim\": 40, \"bright\": 20, \"angle\": 360, \"luminosity\": 0.5, \"animation\": {\"type\": \"none\"}});\n        dialogEditor.render(true);\n      }\n    },\n    lamp: {\n      label: `Lamp`,\n      callback: () => {\n        tokenUpdate({\"dim\": 45, \"bright\": 15, \"angle\": 360, \"luminosity\": 0.5, \"animation\": torchAnimation});\n        dialogEditor.render(true);\n      }\n    },\n    bullseye: {\n      label: `Bullseye Lantern`,\n      callback: () => {\n        tokenUpdate({\"dim\": 120, \"bright\": 60, \"angle\": 45, \"luminosity\": 0.5, \"animation\": torchAnimation});\n        dialogEditor.render(true);\n      }\n    },\n    hoodedOpen: {\n      label: `Hooded Lantern (Open)`,\n      callback: () => {\n        tokenUpdate({\"dim\": 60, \"bright\": 30, \"angle\": 360, \"luminosity\": 0.5, \"animation\": torchAnimation});\n        dialogEditor.render(true);\n      }\n    },\n    hoodedClosed: {\n      label: `Hooded Lantern (Closed)`,\n      callback: () => {\n        tokenUpdate({\"dim\": 5, \"bright\": 0, \"angle\": 360, \"luminosity\": 0.5, \"animation\": torchAnimation});\n        dialogEditor.render(true);\n      }\n    },\n    darkness: {\n      label: `Darkness spell`,\n      callback: () => {\n        tokenUpdate({\"dim\": 0, \"bright\": 15, \"angle\": 360, \"luminosity\": -0.5, \"animation\": {\"type\": \"none\"}});\n        dialogEditor.render(true);\n      }\n    },\n    close: {\n      icon: \"<i class='fas fa-tick'></i>\",\n      label: `Close`\n    },\n  },\n  default: \"close\",\n  close: () => {}\n});\n\ndialogEditor.render(true)","folder":null,"sort":0,"permission":{"default":0,"y5gmtwxmW3A5ZuOP":3},"flags":{}}
{"_id":"F4KqUssiXZNULUFU","name":"Mirror Token Image","type":"script","author":"y5gmtwxmW3A5ZuOP","img":"icons/svg/dice-target.svg","scope":"global","command":"// Flips the selected token image along the Y axis.\n// Change mirrorY to mirrorX to flip across the X axis\nconst updates = canvas.tokens.controlled.map(t => ({_id: t.id, mirrorY: !t.data.mirrorY}));\nawait canvas.scene.updateEmbeddedDocuments(\"Token\", updates);","folder":null,"sort":0,"permission":{"default":0,"y5gmtwxmW3A5ZuOP":3},"flags":{}}
{"_id":"IKx2ap2YfZtAYLDv","name":"Remove Conditions","type":"script","author":"y5gmtwxmW3A5ZuOP","img":"icons/svg/dice-target.svg","scope":"global","command":"(async () => {\n  for ( let token of canvas.tokens.controlled ) {\n    let effectsToDelete = token.actor.effects.filter(e => e.sourceName === \"None\")\n      .map(e => { return e.id }); // documents api expects array of ids\n    await token.actor.deleteEmbeddedDocuments(\"ActiveEffect\", effectsToDelete);\n}})();","folder":null,"sort":0,"permission":{"default":0,"y5gmtwxmW3A5ZuOP":3},"flags":{}}
{"_id":"MYDuEhqg3ke8fnMo","name":"Link Token To Actor","type":"script","author":"y5gmtwxmW3A5ZuOP","img":"icons/svg/dice-target.svg","scope":"global","command":"const unlinked = canvas.scene.data.tokens.map(t => {\n    const actor = game.actors.find(a => a.name === t.name);\n    if (actor) {\n        return {\n            _id: t.id,\n            actorId: actor.id\n        }\n    } else { // this may include actors who's actor name is not the same as the token name (see Starter Heroes)\n        console.log(t.name);\n        return {\n            _id: t.id,\n            actorId: \"\"\n        }\n    }\n});\nconst updates = duplicate(unlinked);\ncanvas.scene.updateEmbeddedDocuments(\"Token\", updates);\n\nui.notifications.info('Tokens linked to actors.');\n//console.log(updates);","folder":null,"sort":0,"permission":{"default":0,"y5gmtwxmW3A5ZuOP":3},"flags":{}}
{"name":"Select Token In Stack","permission":{"default":0,"y5gmtwxmW3A5ZuOP":3},"type":"script","flags":{},"scope":"global","command":"/**\n * Lets the user select one token to control from a list of selected tokens.\n * Useful when tokens are stacked atop one another in the scene.\n * (The user is expected to select the tokens before calling this macro.)\n */\nfunction templateForOptions()\n{\n    let template = `<p>Select one token to control from the selected group.</p>\n    <div class=\"form-group\">\n        <label for=\"selected\">Pick Token:</label>\n        <select id=\"selected\" name=\"selected\">`\n            for ( let token of canvas.tokens.controlled ) {\n                template += `<option value=\"${token.id}\">${token.name}</option>`;    \n            };\n\n    template += `\n        </select>\n    </div>`;\n    return template;\n}\n\nif (canvas.tokens.controlled.length > 1)\n{\n    let applyChanges = false;\n    let tokenPicker = new Dialog({\n        title: `Token Picker`,\n        content: templateForOptions(),\n        buttons: {\n            pick: { \n                icon: \"<i class='fas fa-check'></i>\",\n                label: \"Pick\", \n                callback: () => applyChanges = true },\n            cancel: {                    \n                icon: \"<i class='fas fa-times'></i>\",\n                label: \"Cancel\", \n                callback: () => applyChanges = false }\n        },\n        close: html => {\n            if (applyChanges) {\n                let selectedID = html.find('#selected')[0].value;\n                canvas.tokens.selectObjects([]);\n                const observable = canvas.tokens.placeables.filter(t => t.id === selectedID);\n                if (observable !== undefined)\n                    observable[0].control();\n        }}\n    });\n    \n    tokenPicker.render(true);\n}\nelse\n    ui.notifications.warn(\"Select a group of tokens to pick from.\");\n","author":"y5gmtwxmW3A5ZuOP","img":"icons/svg/dice-target.svg","actorIds":[],"_id":"NmRaLrEqTr0b12mK"}
{"_id":"Ou2x4SEW35uHCvDh","name":"Randomize Wildcard Tokens","type":"script","author":"y5gmtwxmW3A5ZuOP","img":"icons/svg/dice-target.svg","scope":"global","command":"for(let nextToken of canvas.tokens.placeables) {\n            if (nextToken.actor.data.token.randomImg) {\n                let tokenImgArray = await game.actors.get(nextToken.actor.id).getTokenImages();\n                let imageChoice = Math.floor(Math.random() * tokenImgArray.length);\n                let image = tokenImgArray[imageChoice]\n            await nextToken.document.update({ \"img\": image })\n            }\n        }","folder":null,"sort":0,"permission":{"default":0,"y5gmtwxmW3A5ZuOP":3},"flags":{"core":{"sourceId":"Macro.BSlgjKB4i6nMVS9e"}}}
{"_id":"PDyK75mjK8sG7SAF","name":"End Turn","type":"script","author":"y5gmtwxmW3A5ZuOP","img":"icons/svg/dice-target.svg","scope":"global","command":"/*\nAuthor: willisrocks\nDescription: \n\nEnds the current actors turn in a combat encounter. Useful when you don't pop out your combat tracker\nand want to end the turn from your hotbar.\n\nIf the user is a gamemaster, it will always end the current turn. For players, it will only end \nthe turn when the current actor in the turn order is owned by you. \n\nBased on the work of reddit user serrag97: https://www.reddit.com/r/FoundryVTT/comments/j1b8gs/next_turn_shortcut/\n*/\n\n// check if the user is a GM\nconst isGM = game.user.isGM;\n// check if the user owns the combatant whose turn it is\nconst isOwner = game.combat.combatant.isOwner;\n\nif (isGM || isOwner) {\n  game.combat.nextTurn();\n} else {\n  ui.notifications.info(\"As a player you can only advance your turn\");\n}","folder":null,"sort":0,"permission":{"default":0,"y5gmtwxmW3A5ZuOP":3},"flags":{"core":{"sourceId":"Macro.EPdQjOlpTWwBKx9e"}}}
{"name":"Token Behavior","type":"script","author":"wCsoNxA9I9elUaGF","img":"icons/svg/dice-target.svg","scope":"global","command":"const version = 'v1.0';\n\nmain();\n\n\nfunction main() {\n  // Add Vision Type only if the Game Master is using the Macro\n  let dialogue_content = `\n    <form>\n      <div class=\"form-group\">\n        <label>Name:</label>\n        <select id=\"light-source\" name=\"light-source\">\n          <option value=\"NONE\">None</option>\n          <option value=\"ALWAYS\">ALWAYS</option>\n          <option value=\"CONTROL\">CONTROL</option>\n          <option value=\"HOVER\">HOVER</option>\n          <option value=\"OWNER\">OWNER</option>\n          <option value=\"OWNER_HOVER\">OWNER_HOVER</option>\n        </select>\n      </div>\n    </form>\n`;\n\n  let applyChanges = false;\n  let dialogButtons = {\n    yes: {\n      icon: \"<i class='fas fa-check'></i>\",\n      label: `Apply Changes`,\n      callback: (html) => {\n        changeName(html);\n      }\n    },\n    no: {\n      icon: \"<i class='fas fa-times'></i>\",\n      label: `Cancel Changes`\n    }   \n  }  \n  \n  // Main Dialogue    \n  new Dialog({\n    title: `Token Name - ${version}`,\n    content: dialogue_content,\n    buttons: dialogButtons,\n    default: \"yes\",\n  }).render(true);\n}\n\nasync function changeName(html) {\n  let nameBehavior = html.find('[name=\"light-source\"]')[0].value || \"none\";\n  let nameConst;\n  // Update all tokens on the map so that the name shows on hover and the bars always show.\n  // Display Modes: ALWAYS, CONTROL, HOVER, NONE, OWNER, OWNER_HOVER\n\n  switch(nameBehavior) {\n    case 'NONE':\n      nameConst = CONST.TOKEN_DISPLAY_MODES.NONE\n      break;\n    case 'ALWAYS':\n      nameConst = CONST.TOKEN_DISPLAY_MODES.ALWAYS\n      break;\n    case 'CONTROL':\n      nameConst = CONST.TOKEN_DISPLAY_MODES.CONTROL\n      break;\n    case 'HOVER':\n      nameConst = CONST.TOKEN_DISPLAY_MODES.HOVER\n      break;\n    case 'OWNER':\n      nameConst = CONST.TOKEN_DISPLAY_MODES.OWNER\n      break;\n    case 'OWNER_HOVER':\n      nameConst = CONST.TOKEN_DISPLAY_MODES.OWNER_HOVER\n      break;\n    default:\n      nameConst = CONST.TOKEN_DISPLAY_MODES.NONE\n  }  \n  \n  const tokens = canvas.tokens.placeables.map(token => {\n  return {\n    _id: token.id,\n    \"displayName\": nameConst\n  };\n  });\n\n  canvas.scene.updateEmbeddedDocuments('Token', tokens)\n}","folder":null,"sort":0,"permission":{"default":0,"wCsoNxA9I9elUaGF":3},"flags":{"core":{"sourceId":"Macro.b2Iw4OB6yRuuKOZe"}},"_id":"RGqDDYI4ad0UB88r"}
{"_id":"T628s8yTqSLz3KcF","name":"Apply Prototype","type":"script","author":"y5gmtwxmW3A5ZuOP","img":"icons/svg/dice-target.svg","scope":"global","command":"/**\n * Apply Prototype Token to all placed tokens of that actor.\n *\n * @author Forien#2130\n * @url https://www.patreon.com/foundryworkshop\n * @licence MIT\n */\n \n// Optionally modify it to select specific actor. \n// By default takes actor of selected token, or if none is selected, then linked character\n// let actor = ...;\n\n\nif (!actor) return;\nlet tokens = actor.getActiveTokens();\n\nlet updates = tokens.map(t => {\n  let token = duplicate(t.data);\n  return mergeObject(token, actor.data.token);\n});\n\nif (updates.length)\n  canvas.scene.updateEmbeddedDocuments(\"Token\", updates);","folder":null,"sort":0,"permission":{"default":0,"y5gmtwxmW3A5ZuOP":3},"flags":{}}
{"_id":"XrxqpluWdtnNLlmq","name":"Shrink Or Enlarge","type":"script","author":"y5gmtwxmW3A5ZuOP","img":"icons/svg/dice-target.svg","scope":"global","command":"// Update selected tokens to flip between a 1x1 or a 2x2 grid.\n\nconst updates = [];\nfor (let token of canvas.tokens.controlled) {\n  let newSize = (token.data.height == 1 && token.data.width == 1) ? 2 : 1;\n  updates.push({\n    _id: token.id,\n    height: newSize,\n    width: newSize\n  });\n};\n\n// use `canvas.tokens.updateMany` instead of `token.update` to prevent race conditions\ncanvas.scene.updateEmbeddedDocuments(\"Token\", updates);","folder":null,"sort":0,"permission":{"default":0,"y5gmtwxmW3A5ZuOP":3},"flags":{}}
{"_id":"Z6jXfvUlnILKcy4n","name":"Light Picker Color","type":"script","author":"y5gmtwxmW3A5ZuOP","img":"icons/svg/dice-target.svg","scope":"global","command":"function tokenUpdate(data) {\n    canvas.tokens.controlled.map(token => token.document.update({ light: data }));\n}\n\nconst isGM = game.user.isGM;\n\nlet color = \"#ffffff\";\nlet alpha = 1.0;\nlet tokens = canvas.tokens.controlled;\nif (tokens.length === 1) {\n    color = tokens[0].data.light.color ?? color;\n    alpha = tokens[0].data.light.alpha ?? alpha;\n}\n\nconst torchAnimation = {type: \"torch\", speed: 1, intensity: 1};\nconst energyShield = {type: \"energy\", speed: 1, intensity: 1};\nconst lights = {\n    none: {\n        label: \"None\",\n        data: {dim: null, bright: null, angle: 360}\n    },\n    torch: {\n        label: \"Torch\",\n        data: {dim: 40, bright: 20, angle: 360, animation: torchAnimation}\n    },\n    light: {\n        label: \"Light cantrip\",\n        data: {dim: 40, bright: 20, angle: 360, animation: {type: \"none\"}}\n    },\n    lamp: {\n        label: \"Lamp\",\n        data: {dim: 45, bright: 15, angle: 360, animation: torchAnimation}\n    },\n    shield: {\n        label: \"Shield\",\n        data: {dim: 0.5, bright: 0, angle: 360, animation: energyShield}\n    },\n    bullseye: {\n        label: \"Bullseye Lantern\",\n        data: {dim: 120, bright: 60, angle: 45, animation: torchAnimation}\n    }\n};\n\nfunction getLights() {\n    let lightButtons = {};\n    Object.entries(lights).forEach(([key, light]) => {\n        lightButtons[key] = {\n            label: light.label,\n            callback: (html) => {\n                const newColor = html.find(\"#color\").val();\n                const newAlpha = Number(html.find(\"#alpha\").val());\n                var data = light.data;\n                tokenUpdate(Object.assign(data, {color: newColor, alpha: newAlpha}));\n            }\n        }\n    });\n\n    lightButtons = Object.assign(lightButtons, {\n        close: {\n            icon: \"<i class='fas fa-tick'></i>\",\n            label: `Close`\n        }\n    });\n\n    return lightButtons;\n}\n\nnew Dialog({\n    title: `Token Light Picker`,\n    content: `\n        <form>\n            <div style=\"display: flex; align-content: center;\">\n            <label for=\"color\" style=\"line-height: 25px;\">Color:</label>\n            <input type=\"color\" value=\"${color}\" id=\"color\" style=\"margin-left: 10px;\">\n            ${isGM ? '<label for=\"alpha\" style=\"line-height: 25px;\">Intensity:</label>' : ''}\n            <input type=\"${isGM ? 'range' : 'hidden'}\" value=\"${alpha}\" id=\"alpha\" style=\"margin-left: 10px;\" min=\"0.0\" max=\"1.0\" step=\"0.05\">\n            </div>\n        </form>`,\n    buttons: getLights(),\n    default: \"close\",\n    close: () => {}\n}).render(true);","folder":null,"sort":0,"permission":{"default":0,"y5gmtwxmW3A5ZuOP":3},"flags":{"core":{"sourceId":"Macro.BDiFqNriafOCkqJv"}}}
{"_id":"d7GncKN4hQNl2XLd","name":"Set Name and Bars","type":"script","author":"y5gmtwxmW3A5ZuOP","img":"icons/svg/dice-target.svg","scope":"global","command":"// Update all tokens on the map so that the name shows on hover and the bars always show.\n// Display Modes: ALWAYS, CONTROL, HOVER, NONE, OWNER, OWNER_HOVER\n\nconst tokens = canvas.tokens.placeables.map(token => {\n  return {\n    _id: token.id,\n    \"bar1.attribute\": \"attributes.hp\",\n    \"bar2.attribute\": \"attributes.ac.value\",\n    \"displayName\": CONST.TOKEN_DISPLAY_MODES.OWNER_HOVER,\n    \"displayBars\": CONST.TOKEN_DISPLAY_MODES.OWNER\n  };\n});\n\ncanvas.scene.updateEmbeddedDocuments('Token', tokens)","folder":null,"sort":0,"permission":{"default":0,"y5gmtwxmW3A5ZuOP":3},"flags":{}}
{"_id":"fnMfRlpMvuk92hU0","name":"Switch Images","type":"script","author":"y5gmtwxmW3A5ZuOP","img":"icons/svg/dice-target.svg","scope":"global","command":"// Allows swapping between two different .png images.\n// Token sides should have \"a\" and \"b\" at the end of the name like \"name-a.png\" and \"name-b.png\".\n// If you have a different ending, change aName and bName respectively.\n// Author: Phenomen\n\n// IMPORTANT. These two values MUST be the same length.\nlet aName = 'a.png'\nlet bName = 'b.png'\n\nlet tok = canvas.tokens.controlled[0];\nlet img = tok.data.img;\nvar currentSide = img[img.length - aName.length];\nimg = img.slice(0,-Math.abs(aName.length)) + (currentSide == 'a' ? bName: aName);\ntok.document.update({ img });","folder":null,"sort":0,"permission":{"default":0,"y5gmtwxmW3A5ZuOP":3},"flags":{}}
{"_id":"jBcKwGUwHS2V6nat","name":"Token Vision Configuration","type":"script","author":"y5gmtwxmW3A5ZuOP","img":"icons/svg/dice-target.svg","scope":"global","command":"// A macro for the Foundry virtual tabletop that lets a user configure their token's vision and lighting settings. \n\nlet applyChanges = false;\nnew Dialog({\n  title: `Token Vision Configuration`,\n  content: `\n    <form>\n      <div class=\"form-group\">\n        <label>Vision Type:</label>\n        <select id=\"vision-type\" name=\"vision-type\">\n          <option value=\"nochange\">No Change</option>\n          <option value=\"dim0\">Self</option>\n          <option value=\"dim30\">Darkvision (30 ft)</option>\n          <option value=\"dim60\">Darkvision (60 ft)</option>\n          <option value=\"dim90\">Darkvision (90 ft)</option>\n          <option value=\"dim120\">Darkvision (120 ft)</option>\n          <option value=\"dim150\">Darkvision (150 ft)</option>\n          <option value=\"dim180\">Darkvision (180 ft)</option>\n          <option value=\"bright120\">Devil's Sight (Warlock)</option>\n        </select>\n      </div>\n      <div class=\"form-group\">\n        <label>Light Source:</label>\n        <select id=\"light-source\" name=\"light-source\">\n          <option value=\"nochange\">No Change</option>\n          <option value=\"none\">None</option>\n          <option value=\"candle\">Candle</option>\n          <option value=\"lamp\">Lamp</option>\n          <option value=\"bullseye\">Lantern (Bullseye)</option>\n          <option value=\"hooded-dim\">Lantern (Hooded - Dim)</option>\n          <option value=\"hooded-bright\">Lantern (Hooded - Bright)</option>\n          <option value=\"light\">Light (Cantrip)</option>\n          <option value=\"torch\">Torch</option>\n          <option value=\"moon-touched\">Moon-Touched</option>\n        </select>\n      </div>\n    </form>\n    `,\n  buttons: {\n    yes: {\n      icon: \"<i class='fas fa-check'></i>\",\n      label: `Apply Changes`,\n      callback: () => applyChanges = true\n    },\n    no: {\n      icon: \"<i class='fas fa-times'></i>\",\n      label: `Cancel Changes`\n    },\n  },\n  default: \"yes\",\n  close: html => {\n    if (applyChanges) {\n      let updates = [];\n      for ( let token of canvas.tokens.controlled ) {\n        let visionType = html.find('[name=\"vision-type\"]')[0].value || \"none\";\n        let lightSource = html.find('[name=\"light-source\"]')[0].value || \"none\";\n        let dimSight = 0;\n        let brightSight = 0;\n        let dimLight = 0;\n        let brightLight = 0;\n        let lightAngle = 360;\n        let lockRotation = token.data.lockRotation;\n        let lightAnimation = token.data.light.animation;\n        let lightAlpha = token.data.light.alpha;\n        let lightColor = token.data.light.color;\n        const colorFire = \"#f8c377\";\n        const colorWhite = \"#ffffff\";\n        const colorMoonGlow = \"#f4f1c9\";\n        // Get Vision Type Values\n        switch (visionType) {\n          case \"dim0\":\n            dimSight = 0;\n            brightSight = 0;\n            break;\n          case \"dim30\":\n            dimSight = 30;\n            brightSight = 0;\n            break;\n          case \"dim60\":\n            dimSight = 60;\n            brightSight = 0;\n            break;\n          case \"dim90\":\n            dimSight = 90;\n            brightSight = 0;\n            break;\n          case \"dim120\":\n            dimSight = 120;\n            brightSight = 0;\n            break;\n          case \"dim150\":\n            dimSight = 150;\n            brightSight = 0;\n            break;\n          case \"dim180\":\n            dimSight = 180;\n            brightSight = 0;\n            break;\n          case \"bright120\":\n            dimSight = 0;\n            brightSight= 120;\n            break;\n          case \"nochange\":\n          default:\n            dimSight = token.data.dimSight;\n            brightSight = token.data.brightSight;\n        }\n        // Get Light Source Values\n        switch (lightSource) {\n          case \"none\":\n            dimLight = 0;\n            brightLight = 0;\n            lightAnimation = {type: \"none\"};\n            break;\n          case \"candle\":\n            dimLight = 10;\n            brightLight = 5;\n            lightAnimation = {type: \"torch\", speed: 2, intensity: 2};\n            lightColor = colorFire;\n            lightAlpha = 0.15;\n            break;\n          case \"lamp\":\n            dimLight = 45;\n            brightLight = 15;\n            lightAnimation = {type: \"torch\", speed: 2, intensity: 2};\n            lightColor = colorFire;\n            lightAlpha = 0.15;\n            break;\n          case \"bullseye\":\n            dimLight = 120;\n            brightLight = 60;\n            lockRotation = false;\n            lightAngle = 52.5;\n            lightAnimation = {type: \"torch\", speed: 2, intensity: 2};\n            lightColor = colorFire;\n            lightAlpha = 0.15;\n            break;\n          case \"hooded-dim\":\n            dimLight = 5;\n            brightLight = 0;\n            lightAnimation = {type: \"torch\", speed: 2, intensity: 2};\n            lightColor = colorFire;\n            lightAlpha = 0.15;\n            break;\n          case \"hooded-bright\":\n            dimLight = 60;\n            brightLight = 30;\n            lightAnimation = {type: \"torch\", speed: 2, intensity: 2};\n            lightColor = colorFire;\n            lightAlpha = 0.15;\n            break;\n          case \"light\":\n            dimLight = 40;\n            brightLight = 20;\n            lightAnimation = {type: \"none\"};\n            lightColor = colorWhite;\n            lightAlpha = 0.15;\n            break;\n          case \"torch\":\n            dimLight = 40;\n            brightLight = 20;\n            lightAnimation = {type: \"torch\", speed: 2, intensity: 2};\n            lightColor = colorFire;\n            lightAlpha = 0.15;\n            break;\n          case \"moon-touched\":\n            dimLight = 30;\n            brightLight = 15;\n            lightAnimation = {type: \"none\"};\n            lightColor = colorMoonGlow;\n            break;\n          case \"nochange\":\n          default:\n            dimLight = token.data.light.dim;\n            brightLight = token.data.light.bright;\n            lightAngle = token.data.light.angle;\n            lockRotation = token.data.lockRotation;\n            lightAnimation = token.data.light.animation;\n            lightAlpha = token.data.light.alpha;\n            lightColor = token.data.light.color;\n        }\n        // Update Token\n        updates.push({\n          _id: token.id,\n          vision: true,\n          dimSight: dimSight,\n          brightSight: brightSight,\n          \"light.dim\": dimLight,\n          \"light.bright\":  brightLight,\n          \"light.angle\": lightAngle,\n          lockRotation: lockRotation,\n          \"light.animation\": lightAnimation,\n          \"light.alpha\": lightAlpha,\n          \"light.color\": lightColor\n        });\n      }\n      canvas.scene.updateEmbeddedDocuments(\"Token\", updates);\n    }\n  }\n}).render(true);","folder":null,"sort":0,"permission":{"default":0,"y5gmtwxmW3A5ZuOP":3},"flags":{}}
{"_id":"kxwqZGDHqfbGbsiG","name":"Clone Token Actor","type":"script","author":"y5gmtwxmW3A5ZuOP","img":"icons/svg/dice-target.svg","scope":"global","command":"// Clones actor details from the selected token(s) into a new Actor in the item list.\n// Useful if you made changes to the actor associated with the token, but want to save that\n//  updated Actor for later use or into a Compendium.\n// Created Actor will default to the name of the token with the actorNameSuffix (default: '_cloned')\n\n// WORKS ONLY FOR LINKED ACTORS\n\nconst actorNameSuffix = \"_cloned\";\n\ncanvas.tokens.controlled.forEach(o => {\n  Actor.create(o.actor).then(a => {\n    a.update({name: a.name + actorNameSuffix});\n  });\n});","folder":null,"sort":0,"flags":{"core":{"sourceId":"Macro.ihQwEYrlVdc0FiGQ"}},"ownership":{"default":0,"y5gmtwxmW3A5ZuOP":3},"_stats":{"systemId":"dnd5e","systemVersion":"2.0.3","coreVersion":"10.288","createdTime":null,"modifiedTime":1666376739842,"lastModifiedBy":"wCsoNxA9I9elUaGF"}}
{"name":"Unlink Tokens From Actor","type":"script","author":"y5gmtwxmW3A5ZuOP","img":"icons/svg/dice-target.svg","scope":"global","command":"// Unlinks all currently-selected tokens from their actors. This is useful if you're running\n// combat with several copies of the same enemy, as if they're all linked to the same actor,\n// applying damage to one applies damage to all. Select all the baddies and apply this macro\n// to be able to track their HP individually.\n\ncanvas.tokens.updateAll(\n  t => ({ actorLink: false }),\n  t => t._controlled\n);","folder":null,"sort":0,"permission":{"default":0,"y5gmtwxmW3A5ZuOP":3},"flags":{"core":{"sourceId":"Macro.y84Ws6nzEYw30hPm"}},"_id":"ljBriIrT5YMZmrQO"}
{"_id":"lmpb5ZhGg3OYkvtn","name":"Rename Token and Actor","type":"script","author":"y5gmtwxmW3A5ZuOP","img":"icons/svg/dice-target.svg","scope":"global","command":"// quickly change a token and its corresponding unlinked actor\n\nasync function renameToken(newName)\n{\n    for (const token of canvas.tokens.controlled) {\n        console.log(newName);\n        await token.document.update({'name':newName});\n        await token.actor.update({'name' : newName});\n    }\n}            \n\nlet applyChanges=false;\nnew Dialog({\n  title: `Rename token & actor`,\n  content: `\n    <form>\n      <div class=\"form-group\">\n        <input type=\"text\" id=\"new-name\" name=\"new-name\"/>\n        <label for=\"new-name\">New Name</label>\n      </div>\n    </form>\n    `,\n  buttons: {\n    yes: {\n      icon: \"<i class='fas fa-check'></i>\",\n      label: `Apply Changes`,\n      callback: () => applyChanges = true\n    },\n    no: {\n      icon: \"<i class='fas fa-times'></i>\",\n      label: `Cancel Changes`\n    },\n  },\n  default: \"yes\",\n  close: html => {\n      if (applyChanges) {\n            let newName = html.find('[name=\"new-name\"]')[0].value || null;\n            if(newName) \n                renameToken(newName);\n        }\n    }\n}).render(true);","folder":null,"sort":0,"permission":{"default":0,"y5gmtwxmW3A5ZuOP":3},"flags":{"core":{"sourceId":"Macro.hK5R3o61dCxmdlm0"}}}
{"_id":"soTXCSqJwGWNG9ga","name":"Change Disposition","type":"script","author":"y5gmtwxmW3A5ZuOP","img":"icons/svg/dice-target.svg","scope":"global","command":"let applyChanges = false;\nnew Dialog({\n  title: `Token Disposition Changer`,\n  content: `\n    <form>\n      <div class=\"form-group\">\n        <label>Disposition Type:</label>\n        <select id=\"dispo-type\" name=\"dispo-type\">\n          <option value=\"nochange\">No Change</option>\n          <option value=\"hostile\">Hostile</option>\n          <option value=\"neutral\">Neutral</option>\n          <option value=\"friendly\">Friendly</option>\n        </select>\n      </div>\n    </form>\n    `,\n  buttons: {\n    yes: {\n      icon: \"<i class='fas fa-check'></i>\",\n      label: `Apply Changes`,\n      callback: () => applyChanges = true\n    },\n    no: {\n      icon: \"<i class='fas fa-times'></i>\",\n      label: `Cancel Changes`\n    },\n  },\n  default: \"yes\",\n  close: html => {\n    if (applyChanges) {\n      const dispoType = html.find('[name=\"dispo-type\"]')[0].value.toUpperCase();\n      if(dispoType === \"NOCHANGE\") return;\n      const updates = canvas.tokens.controlled.map(t => ({_id: t.id, disposition: CONST.TOKEN_DISPOSITIONS[dispoType]}));\n      canvas.scene.updateEmbeddedDocuments(\"Token\", updates)\n    }\n  }\n}).render(true);","folder":null,"sort":0,"permission":{"default":0,"y5gmtwxmW3A5ZuOP":3},"flags":{}}
{"_id":"th8UFBN1hPa4T9GU","name":"Actor Selector","type":"script","author":"y5gmtwxmW3A5ZuOP","img":"icons/svg/dice-target.svg","scope":"global","command":"// Credit for helping me with this macro goes to  @cole & @Kandashi on the Foundry Discord\n\n//Selects all actors of the same name on the scene.\n// eg: if you have a group of goblins mixed in with kobolds and you want to move all goblins\n// select 1 goblin and run this macro\n// all Goblins will now be selected\n// this should still work in conjunction with Token Mold\nlet selectedId = canvas.tokens.controlled[0].document.actor.id\n\ncanvas.tokens.ownedTokens.forEach(i => {\n  if(i.data.actorId == selectedId) {\n    i.control({releaseOthers: false})\n  }\n})","folder":null,"sort":0,"permission":{"default":0,"y5gmtwxmW3A5ZuOP":3},"flags":{"core":{"sourceId":"Macro.yfhC6smlTkrSlZKt"}}}
