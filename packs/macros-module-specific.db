{"_id":"OJGjAdWyYptiGeBa","name":"Token Vision Config - About Time","permission":{"default":0,"y5gmtwxmW3A5ZuOP":3},"type":"script","flags":{},"scope":"global","command":"// A macro for the Foundry virtual tabletop that lets a user configure their token's vision and lighting settings, based on lighting sources from D&D 5e. Has a dependency on About Time by Tim Posney.\n\nif (canvas.tokens.controlled.length === 0)\n  ui.notifications.error(\"Please select a token\");\n\nlet namedfields = (...fields) => {\n  return (...arr) => {\n    var obj = {};\n    fields.forEach((field, index) => {\n      obj[field] = arr[index];\n    });\n    return obj;\n  };\n};\n\n// Very ugly automated construction below. DRY, but at what cost?\nlet VisionType = namedfields('name', 'dim', 'bright');\nvar visions = (() => {\n  return [\n    VisionType('Leave Unchanged', null, null),\n    VisionType('Self', 5, 0),\n    VisionType('Devil\\'s Sight', 0, 120)\n  ].concat(...[...Array(6).keys()].map(x => (x+1)*30).map(n => {\n    return VisionType(`Darkvision (${n} feet)`, n, 0);\n  }));\n})();\n\nlet LightSource = namedfields('name', 'dim', 'bright', 'angle', 'lockRotation')\nvar lightSources = [\n  LightSource('Leave Unchanged', null, null, null, null),\n  LightSource('None', 0, 0, 360, null),\n  LightSource('Candle', 10, 5, 360, null),\n  LightSource('Torch / Light Cantrip', 40, 20, 360, null),\n  LightSource('Lamp', 45, 15, 360, null),\n  LightSource('Hooded Lantern', 60, 30, 360, null),\n  LightSource('Hooded Lantern (Dim)', 5, 0, 360, null),\n  LightSource('Bullseye Lantern', 120, 60, 52.5, false)\n];\n\nlet applyChanges = false;\nnew Dialog({\n  title: `Token Vision Configuration`,\n  content: `\n<form>\n  <div class=\"form-group\">\n    <label>Vision Type:</label>\n    <select id=\"vision-type\" name=\"vision-type\">\n      ${\n        visions.map((vision, index) => {\n          return `\\t<option value=${index}>${vision.name}</option>`;\n        }).join('\\n')\n      }\n    </select>\n  </div>\n  <div class=\"form-group\">\n    <label>Light Source:</label>\n    <select id=\"light-source\" name=\"light-source\">\n      ${\n        lightSources.map((lightSource, index) => {\n          return `\\t<option value=${index}>${lightSource.name}</option>`;\n        }).join('\\n')\n      }\n    </select>\n  </div>\n  <div class=\"form-group\">\n    <label>Duration in Minutes:</label>\n    <input type=\"number\" id=\"duration\" name=\"duration\" min=\"0\">\n  </div>\n</form>\n`,\n  buttons: {\n    yes: {\n      icon: \"<i class='fas fa-check'></i>\",\n      label: `Apply Changes`,\n      callback: () => applyChanges = true\n    },\n    no: {\n      icon: \"<i class='fas fa-times'></i>\",\n      label: `Cancel Changes`\n    },\n  },\n  default: \"yes\",\n  close: html => {\n    if (applyChanges) {\n      for ( let token of canvas.tokens.controlled ) {\n        let visionIndex = parseInt(html.find('[name=\"vision-type\"]')[0].value) || 0;\n        let lightIndex = parseInt(html.find('[name=\"light-source\"]')[0].value) || 0;\n        let duration = parseInt(html.find('[name=\"duration\"]')[0].value) || 0;\n\n        if (duration > 0) {\n          if (game.modules.get(\"about-time\").active != true) {\n            ui.notifications.error(\"About Time isn't loaded\");\n          } else {\n            ((backup) => {\n              game.Gametime.doIn({minutes:Math.floor(3 * duration / 4)}, () => {\n                ChatMessage.create({\n                  user: game.user._id,\n                  content: \"The fire burns low...\",\n                  speaker: speaker\n                }, {});\n              });\n            })(Object.assign({}, token.data));\n            ((backup) => {\n              game.Gametime.doIn({minutes:duration}, () => {\n                ChatMessage.create({\n                  user: game.user._id,\n                  content: \"The fire goes out, leaving you in darkness.\",\n                  speaker: speaker\n                }, {});\n                token.update({\n                  vision: true,\n                  dimSight: backup.dimSight,\n                  brightSight: backup.brightSight,\n                  dimLight: backup.dimLight,\n                  brightLight:  backup.brightLight,\n                  lightAngle: backup.lightAngle,\n                  lockRotation: backup.lockRotation\n                });\n              });\n            })(Object.assign({}, token.data));\n          }\n        }\n\n        // Configure new token vision\n        let dimSight = visions[visionIndex].dim ?? token.data.dimSight;\n        let brightSight = visions[visionIndex].bright ?? token.data.brightSight;\n        let dimLight = lightSources[lightIndex].dim ?? token.data.dimLight;\n        let brightLight = lightSources[lightIndex].bright ?? token.data.brightLight;\n        let lightAngle = lightSources[lightIndex].angle ?? token.data.lightAngle;\n        let lockRotation = lightSources[lightIndex].lockRotation ?? token.data.lockRotation;\n        // Common settings for all 'torch-like' options\n        // Feel free to change the values to your liking\n        let lightAnimation = {type: \"torch\", speed: 2, intensity: 2};\n        let lightColor = \"#f8c377\"; // Fire coloring.\n        let lightAlpha = 0.15;\n\n        // Update Token\n        console.log(token);\n        token.update({\n          vision: true,\n          dimSight: dimSight,\n          brightSight: brightSight,\n          dimLight: dimLight,\n          brightLight:  brightLight,\n          lightAngle: lightAngle,\n          lockRotation: lockRotation,\n          lightAnimation: lightAnimation,\n          lightColor: lightColor,\n          lightAlpha: lightAlpha\n        });\n      }\n    }\n  }\n}).render(true);","author":"y5gmtwxmW3A5ZuOP","img":"icons/svg/dice-target.svg","actorIds":[]}
{"_id":"VZeBTY7FM8tERZGe","name":"Open Beyond Sheet Player","type":"script","author":"y5gmtwxmW3A5ZuOP","img":"icons/svg/dice-target.svg","scope":"global","command":"// Here's one for your players if you are using Virtual Tabletop Assets - D&D Beyond Integration:\n// Requires https://www.vttassets.com/modules/vtta-dndbeyond or ...\n// https://foundryvtt.com/packages/ddb-importer/ with character sheets linked!\n\nlet popup = () => {\n    if (!game.user.character)\n        return ui.notifications.error(\"You must first have a character assigned to your user!\");\n\n    let char = game.user.character;\n\n    let url = \"\";\n    if (char.data.flags.vtta && char.data.flags.vtta.dndbeyond && char.data.flags.vtta.dndbeyond.url) {\n        url = char.data.flags.vtta.dndbeyond.url;\n    } else if (char.data.flags.ddbimporter && char.data.flags.ddbimporter.dndbeyond && char.data.flags.ddbimporter.dndbeyond.url) {\n        url = char.data.flags.ddbimporter.dndbeyond.url;\n    } else {\n        return ui.notifications.error(\"Character must be linked with a D&D Beyond sheet!\");\n    }\n\n    let ratio = window.innerWidth / window.innerHeight;\n    let width = Math.round(window.innerWidth * 0.5);\n    let height = Math.round(window.innerWidth * 0.5 * ratio);\n    const dndBeyondPopup = window.open(\n        url,\n        \"ddb_sheet_popup\",\n        `resizeable,scrollbars,location=no,width=${width},height=${height},toolbar=1`\n    );\n};\n\npopup();","folder":null,"sort":0,"permission":{"default":0,"y5gmtwxmW3A5ZuOP":3},"flags":{}}
{"_id":"eAl2Dc1HLYp2sUeG","name":"Hit Die","permission":{"default":0,"y5gmtwxmW3A5ZuOP":3},"type":"script","flags":{},"scope":"global","command":"// Requires furnace to work correctly.\n// args[0] === name of character\n// args[1] === \"add\",\"sub\", or \"use\" \n//\t\t\"add\" : adds 1 hit die if able to\n//\t\t\"sub\" : removes 1 hit die if able to\n//\t\t\"use\" : removes 1 hit die and heals actor for rolled amount\n\n(async () => {\n\tconst actor = game.actors.find(i => i.name === args[0]); \n    if (!actor) return ui.notifications.warn(`No Actor by that name available.`);\n    const classItems = actor.data.items.filter(it => it.type === \"class\")\n    if (!classItems.length) return ui.notifications.warn(`Actor has no class!`);\n    if (classItems.length > 1) return ui.notifications.warn(`Actor has multiple classes! This is not (yet) supported.`);\n    const classItem = classItems[0];\n\t\n\tif(args[1] === \"add\")\n\t{\n\t\tif (classItem.data.hitDiceUsed <= 0) return ui.notifications.warn(`You are at maximum Hitdie!`);\n\n\t\tconst classItemUpdate = {\n\t\t\t_id: classItem._id,\n\t\t\tdata: {\n\t\t\t\thitDiceUsed: classItem.data.hitDiceUsed - 1,\n\t\t\t},\n\t\t};\n\n\t\tawait actor.updateEmbeddedEntity(\"OwnedItem\", classItemUpdate);\n\t}\n\t\n\tif(args[1] === \"sub\")\n\t{\n\t\tif (classItem.data.hitDiceUsed >= classItem.data.levels) return ui.notifications.warn(`You have no remaining hit dice to spend!`);\n\n\t\tconst classItemUpdate = {\n\t\t\t_id: classItem._id,\n\t\t\tdata: {\n\t\t\t\thitDiceUsed: classItem.data.hitDiceUsed + 1,\n\t\t\t},\n\t\t};\n\n\t\tawait actor.updateEmbeddedEntity(\"OwnedItem\", classItemUpdate);\n\t}\n\t\n\tif(args[1] === \"use\")\n\t{\n\t\tif (classItem.data.hitDiceUsed >= classItem.data.levels) return ui.notifications.warn(`You have no remaining hit dice to spend!`);\t\t\n\t\tconst classItemUpdate = {\n\t\t\t_id: classItem._id,\n\t\t\tdata: {\n\t\t\t\thitDiceUsed: classItem.data.hitDiceUsed + 1,\n\t\t\t},\n\t\t};\n\t\tawait actor.updateEmbeddedEntity(\"OwnedItem\", classItemUpdate);\n\t\t\n\t\tconst hitDieRoll = new Roll(`1${classItem.data.hitDice} + ${actor.data.data.abilities.con.mod}`);\n\t\thitDieRoll.roll();\n\t\thitDieRoll.toMessage({\n\t\t\tuser : game.user._id,\n\t\t\tspeaker : speaker,\n\t\t\tflavor : \"Roll Hit Dice\"\n\t\t});\n\t\t\n\t\tconst actorUpdate = {\n\t\t\tdata: {\n\t\t\t\tattributes: {\n\t\t\t\t\thp: {\n\t\t\t\t\t\tvalue: Math.clamped(\n\t\t\t\t\t\t\tactor.data.data.attributes.hp.value + hitDieRoll.total,\n\t\t\t\t\t\t\tactor.data.data.attributes.hp.min,\n\t\t\t\t\t\t\tactor.data.data.attributes.hp.max\n\t\t\t\t\t\t)\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t};\n\t\tawait actor.update(actorUpdate);\n\t}    \n})();\n","author":"y5gmtwxmW3A5ZuOP","img":"icons/svg/dice-target.svg","actorIds":[]}
{"name":"Hunters Mark - Mark Attack Wrapper","permission":{"default":0,"y5gmtwxmW3A5ZuOP":3},"type":"script","flags":{},"scope":"global","command":"//This marco is replacement for a rollItemMacro. Replace the name of the item\n//you wish to use to make the attack. This macro must be used with the\n//CastMark.json macro or it will just make a standard attack.\n\n// PUT ITEM MACRO HERE between quotes ****************\nconst itemName = \"Longbow\";\n// ***************************************************\n\n//parameters\n\nlet myToken = token;\nconst macroName = \"world\";\nconst markDmg = \" + 1d6\";\nconst target = game.user.targets.values().next().value;\nconst bonuses = myToken.actor.data.data.bonuses;\nconst actorId = myToken.actor._id + \"_mark\";\n\n//Check to see if the mark flag is set else make attack\n\nfunction checkMark() {\n  const flag = myToken.getFlag(macroName, actorId);\n\n  if (flag) {\n    if (flag.targetId == target.data._id) {\n      markAttack(flag);\n    } else {\n      baseAttack(flag);\n    }\n  } else {\n    game.dnd5e.rollItemMacro(itemName);\n  }\n}\n\n//check if the mark damag is set and if not increase\n//increase global damage by 1d6\n\nfunction markAttack(flag) {\n  if (!flag.isSet) {\n    let obj = {\n      \"data.bonuses.mwak.damage\": flag.meleeAtk + markDmg,\n      \"data.bonuses.rwak.damage\": flag.rangeAtk + markDmg,\n      \"data.bonuses.msak.damage\": flag.meleeSpell + markDmg,\n      \"data.bonuses.rsak.damage\": flag.rangeSpell + markDmg\n    };\n    updateActor(myToken, obj);\n    flag.isSet = true;\n  }\n  game.dnd5e.rollItemMacro(itemName);\n  token.setFlag(macroName, actorId, flag);\n}\n\n// check if the mark damage is set and if it is revert to base global damage\n\nfunction baseAttack(flag) {\n  if (flag) {\n    let obj = {\n      \"data.bonuses.mwak.damage\": flag.meleeAtk,\n      \"data.bonuses.rwak.damage\": flag.rangeAtk,\n      \"data.bonuses.msak.damage\": flag.meleeSpell,\n      \"data.bonuses.rsak.damage\": flag.rangeSpell\n    };\n    updateActor(myToken, obj);\n    flag.isSet = false;\n    game.dnd5e.rollItemMacro(itemName);\n    token.setFlag(macroName, actorId, flag);\n  } else {\n    game.dnd5e.rollItemMacro(itemName);\n  }\n}\n\nasync function updateActor(updateToken, obj) {\n  await updateToken.actor.update(obj);\n}\n\n//Ensure target is set and then call check mark function\n\nif (!myToken) ui.notifications.error(\"Please select your token first.\");\nelse {\n  checkMark();\n}\n","author":"y5gmtwxmW3A5ZuOP","img":"icons/svg/dice-target.svg","actorIds":[],"_id":"m2Dqm2gD0sUDNWbI"}
{"_id":"pQ2VZCynMb4MIhky","name":"Resolve Surprise","permission":{"default":0,"y5gmtwxmW3A5ZuOP":3},"type":"script","flags":{},"scope":"global","command":"// Resolve who is surprised between groups of players and enemies or individual players and enemies\n// This macro requires The Furnance module with \"Advanced Macros\" turned on.\n// ReadMe: https://gitlab.com/x.technocat/foundry-macros/-/blob/e67f9441b2d6d442258db1d51aa2be3ead97569d/surprise-macros/README.md\n\n// Get player character tokens\nconst playerActors = getPlayerActors();\n\n// Get hostile tokens\nconst enemyActors = getEnemyActors();\n\nlet warnMsg = \"\";\n\n// Main function\nconst isSuccessful = checkSurprise(playerActors, enemyActors);\n\nif (!isSuccessful) {\n  return ui.notifications.warn(warnMsg);\n}\n\nasync function checkSurprise(playerActors, enemyActors) {\n  if (!game.user.isGM) {\n    warnMsg = \"You do not have permission to run this macro.\";\n    return false;\n  }\n  if (!playerActors.length > 0) {\n    warnMsg =\n      \"Could not find player characters in the scene. Please add player characters to the scene.\";\n    return false;\n  }\n  if (!enemyActors.length > 0) {\n    warnMsg =\n      \"Could not find hostile tokens. You need tokens with hostile dispositions in the scene to check for Surprise!\";\n    return false;\n  }\n\n  // Displays a popup and handles the input. Thanks to PaperPunk for this.\n  let calculateSurprise = false;\n\n  new Dialog({\n    title: `What Group is Sneaking?`,\n    content: `\n    <form>\n      <div>\n        <label>Select which group is sneaking/ambushing:</label><br><br>\n        <div style=\"margin:auto; width: 50%;\">\n        <input type=\"radio\" name=\"sneaking-group\" id=\"enemies\" value=\"enemies\" checked=\"checked\">\n        <label for=\"enemies\"><b>Enemy</b> is sneaking</label><br>\n        <input type=\"radio\" name=\"sneaking-group\" id=\"party\" value=\"party\">\n        <label for=\"party\"><b>Party</b> is sneaking</label><br>\n        </div>\n        <br>\n      </div>\n    </form>\n    `,\n    buttons: {\n      yes: {\n        icon: \"<i class='fas fa-check'></i>\",\n        label: `Calculate Surprise`,\n        callback: () => (calculateSurprise = true), //if \"yes\" is selected, apply the selection.\n      },\n      no: {\n        icon: \"<i class='fas fa-times'></i>\",\n        label: `Cancel Surprise`,\n      },\n    },\n    // Defaulting to yes, so that when someone selects something and hits enter, it doesn't cancel:\n    default: \"yes\",\n\n    // Handle the input\n    close: (html) => {\n      if (calculateSurprise) {\n        // Determine which group is sneaking based on the user's selection\n        const sneakyOptions = html.find('[name=\"sneaking-group\"]');\n        let sneakingGroup;\n        for (const option of sneakyOptions) {\n          if (option.checked) {\n            sneakingGroup = option.value;\n            break;\n          }\n        }\n\n        let results = ``;\n        let lowestStealthCheck = 0;\n\n        switch (sneakingGroup) {\n          case \"enemies\":\n            lowestStealthCheck = rollStealth(enemyActors);\n            results = calculateSurpriseResults(\n              lowestStealthCheck,\n              playerActors\n            );\n            break;\n\n          case \"party\":\n            lowestStealthCheck = rollStealth(playerActors);\n            results = calculateSurpriseResults(\n              lowestStealthCheck,\n              enemyActors);\n            break;\n        }\n\n        handleChatMessage(results, lowestStealthCheck);\n      }\n    },\n  }).render(true); // display pop up window\n\n  return true; // no issues and we're done here!\n}\n\nasync function handleChatMessage(results, lowestStealth) {\n  let messageContent = ``;\n  let rendered = await lowestStealth.render();\n  messageContent += `<b>Lowest Stealth: </b> ${rendered} <br><br>`;\n  messageContent += results;\n\n  const surpriseRules =\n    \"<br><b>Surprise Rules</b><br>\" +\n    \"Compare the Dexterity (Stealth) checks of anyone hiding with the passive Wisdom (Perception) score of each creature on the opposing side. Any character or monster that doesn't notice <i><b>a</b></i> threat is surprised at the start of the encounter. <br><br>\" +\n    \"If you're surprised, you can't move or take an action on your first turn of the combat, and you can't take a reaction until that turn ends. A member of a group can be surprised even if the other members aren't.<br><br> <i>PHB. 189</i>\";\n\n  messageContent += surpriseRules;\n\n  let chatData = {\n    user: game.user._id,\n    content: messageContent,\n    whisper: ChatMessage.getWhisperRecipients(\"GM\")\n  };\n\n  ChatMessage.create(chatData, {});\n}\n\nfunction getPlayerActors() {\n  // Get tokens in the scene that are player characters and not NPCs. Prioritize selected tokens.\n  const controlledPlayerActors = canvas.tokens.controlled\n    .filter((pc) => pc.actor.isPC && pc.actor.data.type === \"character\")\n    .map((a) => a.actor);\n\n  if (controlledPlayerActors.length > 0) {\n    return controlledPlayerActors;\n  }\n\n  // If none are selected, use all the player characters in the scene\n  return canvas.tokens.children[0].children\n    .filter((pc) => pc.actor.isPC && pc.actor.data.type === \"character\")\n    .map((a) => a.actor);\n}\n\nfunction getEnemyActors() {\n  // Prioritize selected hostile enemies\n  const controlledEnemyActors = canvas.tokens.controlled\n    .filter((ec) => ec.actor.isPC === false && ec.data.disposition === -1)\n    .map((a) => a.actor);\n\n  if (controlledEnemyActors.length > 0) {\n    return controlledEnemyActors;\n  }\n\n  // If none are selected, use all the enemies in the scene that are hostile\n  return canvas.tokens.children[0].children\n    .filter((ec) => ec.actor.isPC === false && ec.data.disposition === -1)\n    .map((a) => a.actor);\n}\n\nfunction rollStealth(sneakyGroup) {\n  // Roll stealth for the sneaking group\n  let stealthResults = [];\n  for (let actor of sneakyGroup) {\n    let stealth =\n      new Roll(\"1d20 + @steMod\", { steMod: actor.data.data.skills.ste.total }).roll();\n    stealthResults.push(stealth);\n  }\n\n  // Return the lowest stealth roll, it's all we need\n  let lowest = stealthResults[0];\n  for (let roll of stealthResults) {\n    if (roll.total < lowest.total) {\n      lowest = roll;\n    }\n  }\n  return lowest;\n}\n\nfunction calculateSurpriseResults(lowestStealth, perceptiveGroup) {\n  let resultMsg = ``;\n\n  const surprisedTxt = `[<span style=\"color:red\">Surprised</span>]`;\n  const notSurprisedTxt = `[<span style=\"color:green\">Not Surprised</span>]`;\n  const alertTxt = `<i>Alert</i>`;\n\n  const lowestPerception = Math.min.apply(\n    Math,\n    perceptiveGroup.map(function (actor) {\n      return actor.data.data.skills.prc.passive;\n    })\n  );\n\n  if (lowestPerception >= lowestStealth) {\n    resultMsg += `<i>No one is Surprised!</i> <br>`;\n  } else {\n    for (let actor of perceptiveGroup) {\n      const name = actor.data.name;\n      const prc = actor.data.data.skills.prc.passive;\n      let msg = ``;\n\n      // If Alert feat not surprised, else if win perception not surprised, else surprised\n      const alertFeat = actor.data.items.find((p) => p.name === \"Alert\");\n      if (alertFeat) {\n        msg = `${name} (${prc}) -- ${notSurprisedTxt} ${alertTxt}`;\n      } else if (prc >= lowestStealth) {\n        msg = `${name} (${prc}) -- ${notSurprisedTxt}`;\n      } else {\n        msg = `${name} (${prc}) -- ${surprisedTxt}`;\n      }\n\n      // Append this actor's surprise result to chat message variable.\n      resultMsg += `${msg} <div style=\"border-bottom: 1px solid gray\"></div> <br>`;\n    }\n  }\n\n  return resultMsg;\n}","author":"y5gmtwxmW3A5ZuOP","img":"icons/svg/dice-target.svg","actorIds":[]}
{"_id":"s7I9TcrGFMH2hQ0c","name":"Hunters Mark - GM Conditions","permission":{"default":0,"y5gmtwxmW3A5ZuOP":3},"type":"script","flags":{},"scope":"global","command":"//This macro must be called 'GMConditions' and be on the GM's\n//hot bar for the castMark.js macro to function correctly.\n//you must tick the option 'Excecute Macro As GM' to grant\n//players access to this macro.\n//To do this you must create a new macro in your game and use\n//the code below, dragging the macro from the compendium\n//will not work.\n\n\nconst action = args[0]\nconst condition = args[1]\nconst targetId = args[2]\nconst target = canvas.tokens.get(targetId);\nif (action == \"apply\"){\n    game.cub.addCondition(condition, target, {replaceExisting: true})\n}\nelse if (action == \"remove\"){\n    game.cub.removeCondition(condition, target, {warn: true});\n}","author":"y5gmtwxmW3A5ZuOP","img":"icons/svg/dice-target.svg","actorIds":[]}
{"_id":"tch2n3sDUiZTxqGM","name":"Hunters Mark - Cast Mark","permission":{"default":0,"y5gmtwxmW3A5ZuOP":3},"type":"script","flags":{},"scope":"global","command":"//This marco is designed to be used in conjunction with MarkAttackWrapper.json\n//and GMConditions.js.\n\n//It is designed to replace the standard rollItemMacro for either the Hex\n//spell or the hunter's mark Spell on either the warlock or ranger, but\n//it will work on any class with hex or hunter's mark by changing the Localization\n//parameters. To use hex, replace warlockName variable below and if you\n//would like to use it with hunter's mark replace rangerName variable below.\n\n// CAUTION! if you change your global damage variables while this macro is\n//active the change will be erased. It should work fine with dynamic effects.\n\n//!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n//This macro is designed to be used with the combat utility belt module.\n//and the furnace module. Once you have it installed, you will have to enable \n//enhanced conditions, and create a condition called 'Marked' as the Localization \n//parameter below. You just need to update that parameter to match whatever condition \n//name you want if you want to use a different name in condition lab.\n//!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n\n//Localization\nconst rangerName = \"Ranger\";\nconst paladinName = \"Paladin\";\nconst warlockName = \"Warlock\";\nconst markSpell = \"Hunter's Mark\";\nconst hexSpell = \"Hex\";\nconst condition = \"Marked\";\nconst flagScope = \"world\";\n\n//parameters\nif (!token) ui.notifications.error(\"Please select your token first.\");\nlet myToken = token;\nconst markDmg = \" + 1d6\";\nif (!game.user.targets.values().next().value) {\n  ui.notifications.error(\"Please select one target\");\n}\nconst target = game.user.targets.values().next().value;\n\nconst conditionList = target.data.effects;\nconst actorId = myToken.actor._id + \"_mark\";\nconst bonuses = myToken.actor.data.data.bonuses;\nlet className = \"\";\nlet spellName = \"\";\nlet gm_macro = null\n\n//Check to make sure that the GM has the GMConditions macro assigned.\ntry{\n    gm_macro = game.macros.entities.find(mb => mb.name === \"GMConditions\");\n}\ncatch(err)\n{\n    ui.notifications.error(\"GMConditions Macro was not found\")\n}\n\n//If Move flag and condition to a new selected target\nfunction move() {\n  let swapTarget = myToken.getFlag(flagScope, actorId);\n  const remCon = canvas.tokens.get(swapTarget.targetId);\n  gm_macro.execute(\"remove\", condition, swapTarget.targetId);\n  swapTarget.targetId = target.data._id;\n  (async () => {\n    await myToken.unsetFlag(flagScope, actorId);\n    myToken.setFlag(flagScope, actorId, swapTarget);\n  })();\n  gm_macro.execute(\"apply\", condition, target.id);\n  console.log();\n}\n\n//revert global damage to base, remove the condition and unset flag\n\nfunction remove() {\n  const flagId = myToken.getFlag(flagScope, actorId);\n\n  let obj = {\n    \"data.bonuses.mwak.damage\": flagId.meleeAtk,\n    \"data.bonuses.rwak.damage\": flagId.rangeAtk,\n    \"data.bonuses.msak.damage\": flagId.meleeSpell,\n    \"data.bonuses.rsak.damage\": flagId.rangeSpell\n  };\n\n  updateActor(myToken, obj);\n\n  const remFlag = canvas.tokens.get(flagId.targetId);\n\n  (async () => {\n    await gm_macro.execute(\"remove\", condition, flagId.targetId);\n    await myToken.unsetFlag(flagScope, actorId);\n  })();\n}\n\n// User input to move or remove flag and condition\n\nfunction alterMark() {\n  const d = new Dialog({\n    title: \"Mark Enemy\",\n    content: \"<p>Would you like to move or remove?</p>\",\n    buttons: {\n      one: {\n        icon: '<i class=\"fas fa-check\"></i>',\n        label: \"Move\",\n        callback: () => move()\n      },\n      two: {\n        icon: '<i class=\"fas fa-times\"></i>',\n        label: \"Remove\",\n        callback: () => remove()\n      }\n    },\n    default: \"two\",\n    close: () => console.log(\"Dialog closed\")\n  }).render(true);\n}\n\n// cast the spell, apply the condition, create and set flag\n\nasync function castSpell() {\n  try {\n    await game.dnd5e.rollItemMacro(spellName);\n  } catch (err) {\n    return null;\n  }\n  gm_macro.execute(\"apply\", condition, target.id);\n\n  let globalDmg = {\n    targetId: target.data._id,\n    meleeAtk: bonuses.mwak.damage,\n    rangeAtk: bonuses.rwak.damage,\n    meleeSpell: bonuses.msak.damage,\n    rangeSpell: bonuses.rsak.damage,\n    isSet: false\n  };\n  myToken.setFlag(flagScope, actorId, globalDmg);\n}\n\n//If the class is ranger and has the hunter's mark spell, set the spell name\n//or say the spell doesn't exist.\n\nfunction setRangerSpell() {\n  className = rangerName;\n  if (actor.items.find(i => i.name === `${markSpell}`)) {\n    spellName = markSpell;\n    castSpell();\n  } else {\n    ui.notifications.error(\n      \"Selected actor does not have the \" + markSpell + \" spell.\"\n    );\n    console.log(\"Selected actor does not have the \" + markSpell + \" spell.\");\n    return null;\n  }\n}\n\n//If the class is paladin and has the hunter's mark spell, set the spell name\n//or say the spell doesn't exist.\n\nfunction setPaladinSpell() {\n  className = paladinName;\n  if (actor.items.find(i => i.name === `${markSpell}`)) {\n    spellName = markSpell;\n    castSpell();\n  } else {\n    ui.notifications.error(\n      \"Selected actor does not have the \" + markSpell + \" spell.\"\n    );\n    console.log(\"Selected actor does not have the \" + markSpell + \" spell.\");\n    return null;\n  }\n}\n\n//If the class is warlock and has the hex spell set the spell name\n//if say the spell doesn't exist\n\nfunction setWarlockSpell() {\n  className = warlockName;\n  if (actor.items.find(i => i.name === `${hexSpell}`)) {\n    spellName = hexSpell;\n    castSpell();\n  } else {\n    ui.notifications.error(\n      \"Selected actor does not have the \" + hexSpell + \" spell.\"\n    );\n    console.log(\"Selected actor does not have the \" + hexSpell + \" spell.\");\n    return null;\n  }\n}\n\n//check whether the token is a ranger or warlock\n\nfunction checkSpell() {\n  if (actor.items.find(i => i.name === `${rangerName}`)) {\n    setRangerSpell();\n  } else if (actor.items.find(i => i.name === `${paladinName}`)) {\n    setPaladinSpell();\n  } else if (actor.items.find(i => i.name === `${warlockName}`)) {\n    setWarlockSpell();\n  } else {\n    ui.notifications.error(\n      \"Please select a \" + rangerName + \", \" + paladinName + \", or \" + warlockName + \" token.\"\n    );\n    console.log(\n      \"Please select a \" + rangerName + \", \" + paladinName + \", or \" + warlockName + \" token.\"\n    );\n  }\n}\n\nasync function updateActor(updateToken, obj) {\n  await updateToken.actor.update(obj);\n}\n\n//If the flag exists call functions to move or remove if it doesn't exist\n// call function to cast the spell\n\nif (myToken.getFlag(flagScope, actorId)) {\n  alterMark();\n} else {\n  checkSpell();\n}","author":"y5gmtwxmW3A5ZuOP","img":"icons/svg/dice-target.svg","actorIds":[]}
{"name":"Pearl of Power","type":"script","author":"wCsoNxA9I9elUaGF","img":"icons/svg/dice-target.svg","scope":"global","command":"// Macro made on Foundry 0.8.9, Dnd5e System 1.5.6\n// This macro needs modules Midi-QOL 0.8.96, DAE 0.8.75 and Dnd5e-helpers 3.0.4\n// Create a macro called <Pearl of Power> (without <>)\n// Pearl of Power has to call this macro on midiqol option \"On Use Macros\", after Active Effects\nif (args[0] == \"on\"){\n\treturn{};\n} else if (args[0] == \"off\"){\n\t// Execute when effect is lost\n\tlet actor = await MidiQOL.MQfromActorUuid(args[2].actorUuid); // actor who lost the effect\n\t// Deleting the extra spell slot of 3rd level\n\tlet actor_data = duplicate(actor.data._source);\n\tactor_data.data.spells.spell3.override = null;\n\tactor_data.data.spells.spell3.value = 0;\n\tactor.update(actor_data);\n\t// Deleting the Hook on update actor\n\tHooks.off(`updateActor`, args[1]);\n} else {\n\t// Execute when using the Pearl of Power\n\tlet ator = args[0].actor;\n\tlet act = game.actors.get(args[0].actor._id);\n\tlet item = args[0].item;\n\tlet spellx;\n\t// Check pact magic and spell levels that have used slots\n\tfor (let i = 0; i < 10; i++)\n\t{\n\t\tlet spells = (i==0) ? ator.data.spells[\"pact\"] : ator.data.spells[\"spell\" + i];\n\t\tif (spells.max > 0 && spells.value < spells.max)\n\t\t{\n\t\t\tif (i == 0)\n\t\t\t{\n\t\t\t\tspellx = `<option value=\"0\">Pact slot</option>`;\n\t\t\t} else if (i == 1)\n\t\t\t{\n\t\t\t\tspellx = `<option value=\"1\">1st Level</option>`;\n\t\t\t} else if (i == 2)\n\t\t\t{\n\t\t\t\tspellx = spellx + `<option value=\"2\">2nd Level</option>`;\n\t\t\t} else if (i == 3)\n\t\t\t{\n\t\t\t\tspellx = spellx + `<option value=\"3\">3rd Level</option>`;\n\t\t\t} else \n\t\t\t{\n\t\t\t\tspellx = spellx + `<option value=\"` + i + `\">` + i + `th Level</option>`;\n\t\t\t}\n\t\t};\n\t\tif (!spellx){\n\t\t\tui.notifications.warn(\"You don't have spent spell slots.\");\n\t\t\treturn{};\n\t\t}\n\t};\n\tlet d = new Dialog({\n\t\ttitle: 'Pearl of Power: Usage Configuration',\n\t\tcontent: `\n\t  <form style=\"font-size:13px\" class=\"dnd5e\" id=\"ability-use-form\">\n\t\t<p>Which spell slot to recover with Pearl of Power.</p>\n\t\t<p class=\"notes\"></p>\n\t\t<div class=\"form-group\">\n\t\t  <label>Spell Slot Level</label>\n\t\t\t<select id=\"spellSlots\" name=\"level\">`+ spellx + `\n\t\t\t</select>\n\t\t</div>\n\t</form>\n\t  `,\n\t\tbuttons: {\n\t\t\tyes: {\n\t\t\t\ticon: '<i class=\"fas fa-dice-d20\"></i>',\n\t\t\t\tlabel: 'Use Feature',\n\t\t\t\tcallback: async (html) =>\n\t\t\t\t{\n\t\t\t\t\tlet level = html.find('[name=\"level\"]').val();\n\t\t\t\t\tlet actor_data = duplicate(act.data._source);\n\t\t\t\t\tlet sourcespells = actor_data.data.spells;\n\t\t\t\t\tlet spells = ator.data.spells;\n\t\t\t\t\t//Pact spell slot\n\t\t\t\t\tif (level == 0)\n\t\t\t\t\t{\n\t\t\t\t\t\t// Pact spell slot of 4th level or greater\n\t\t\t\t\t\tif (spells.pact.level > 3)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t// If actor already has 3rd level spells (not pact), just add one slot\n\t\t\t\t\t\t\tif (spells.spell3.max > 0){\n\t\t\t\t\t\t\t\tsourcespells.spell3.value += 1;\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tsourcespells.spell3.value += 1;\n\t\t\t\t\t\t\t\tsourcespells.spell3.override = 1;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t// Pact spell of 3rd level of lesser, just add one slot\n\t\t\t\t\t\t\tsourcespells.pact.value += 1;\n\t\t\t\t\t\t}\n\t\t\t\t\t// If regular spell slot\n\t\t\t\t\t} else if (level < 3)\n\t\t\t\t\t{\n\t\t\t\t\t\t// Of 1st or 2nd level, just add a slot of the corresponding level\n\t\t\t\t\t\tsourcespells[`spell${level}`].value += 1;\n\t\t\t\t\t} else\n\t\t\t\t\t{\n\t\t\t\t\t\t// If 3rd level or greater than add a 3rd level slot\n\t\t\t\t\t\tsourcespells[`spell3`].value += 1;\n\t\t\t\t\t}\n\t\t\t\t\tawait act.update(actor_data);\n\t\t\t\t\t// If we had to override a spell slot of 3rd level (meaning pact spell of 4th or 5th level and no regular 3rd level spell slot)\n\t\t\t\t\tif (sourcespells.spell3.override = 1){\n\t\t\t\t\t\t// Create a hook when actor is updated checking for the actor, all 3rd level slots spent, an override on 3rd level spells and for the Pearl of Power effect, then delete the effect\n\t\t\t\t\t\tconst myhook = Hooks.on(`updateActor`, (actorroll, data, options, usedID) => {\n\t\t\t\t\t\t\tif(actorroll.data._id == `${act.data._id}` && actorroll.data._source.data.spells.spell3.value == 0 && actorroll.data._source.data.spells.spell3.override == 1){\n\t\t\t\t\t\t\t\tlet efeito = actorroll.effects.find(i => i.data.label === \"Pearl of Power\");\n\t\t\t\t\t\t\t\tif (efeito){\n\t\t\t\t\t\t\t\t\tefeito.delete();\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t});\n\t\t\t\t\t\t// Define effect on user of Pearl of Power, storing the Hook index to later delete it\n\t\t\t\t\t\tconst effectData = {\n\t\t\t\t\t\t  changes: [{key: \"macro.execute\", mode: 1, value: `\"Pearl of Power\" ${myhook}`, priority: 0}],\n\t\t\t\t\t\t  origin: args[0].itemUuid,\n\t\t\t\t\t\t  disabled: false,\n\t\t\t\t\t\t  duration: {startTime: game.time.worldTime},\n\t\t\t\t\t\t  icon: args[0].item.img,\n\t\t\t\t\t\t  label: args[0].item.name,\n\t\t\t\t\t\t  flags: {\"dnd5e-helpers\" : {\"rest-effect\" : \"Short Rest\"}}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tawait act.createEmbeddedDocuments(\"ActiveEffect\", [effectData]);\t\t\t\t\t\t\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t},\n\t\t},\n\t\tdefault: 'yes',\n\t\tclose: () =>\n\t\t{\n\t\t}\n\t}).render(true);\n};","folder":null,"sort":0,"permission":{"default":0,"wCsoNxA9I9elUaGF":3},"flags":{"core":{"sourceId":"Macro.uua7wLIpgRM3k2BF"}},"_id":"D8DaZ1gABBuNfZth"}
{"name":"Hex","type":"script","author":"wCsoNxA9I9elUaGF","img":"icons/svg/dice-target.svg","scope":"global","command":"//Needs Midi-QoL and timesup modules\n//The cursing part of this macro doesn't work when the target is a token with a linked actor sheet (meaning, it should work agains 95% of NPCs, doesn't work for PvP)\n//A workaround is asking for your GM to click the spell/feature, since he has the permission to update any actor sheet\n//You need to create a new feature for the player to be used to change the Hex curse from one target to the next\n//This macro should be called by the OnUse on the Hex spell, the OnUse on this new feature and Bonus Damage Macros on the player\n//You need to use the Hex spell to \"start\" the curse and the new feature to change it to a new target, damage bonus is automatic\n// Hex onUse macro\nif (args[0].hitTargets.length === 0) return;\nif (args[0].tag === \"OnUse\") {\n    let targetUuid = args[0].targets[0].uuid;\n\tlet target = args[0].targets[0];\n\tlet tactor = target?.actor;\n    let actor = await MidiQOL.MQfromActorUuid(args[0].actorUuid); // actor who cast the spell\n    if (!actor || !targetUuid) {\n      console.error(\"Hex: no token/target selected\");\n      return;\n    }\n \n\tnew Dialog({\n\t\ttitle: 'Choose which ability the target will have disadvantage:',\n\t\tcontent: `\n\t\t  <form class=\"flexcol\">\n\t\t\t<div class=\"form-group\">\n\t\t\t  <select id=\"stat\">\n\t\t\t\t<option value=\"str\">Strength</option>\n\t\t\t\t<option value=\"dex\">Dexterity</option>\n\t\t\t\t<option value=\"con\">Constitution</option>\n\t\t\t\t<option value=\"int\">Intelligence</option>\n\t\t\t\t<option value=\"wis\">Wisdom</option>\n\t\t\t\t<option value=\"cha\">Charisma</option>\n\t\t\t  </select>\n\t\t\t</div>\n\t\t  </form>\n\t\t`,\n\t\tbuttons: {\n\t\t\tyes: {\n\t\t\t\ticon: '<i class=\"fas fa-bolt\"></i>',\n\t\t\t\tlabel: 'Select',\n\t\t\t\tcallback: async (html) => {\n\t\t\t\t\tlet stat = html.find('#stat').val();\n\t\t\t\t\t// Getting Hex effect from actor\n\t\t\t\t\tlet effect = actor.effects.find(i => i.data.label === \"Hex\" && i.data.changes[0].key === \"flags.midi-qol.Hexcurse\");\n\t\t\t\t\tif (effect == null){ //If Hex (from caster) is not active on caster\n\t\t\t\t\t\tif (args[0].item.type !== \"spell\") {\n\t\t\t\t\t\t\tui.notifications.warn(\"You don't have an active Hex to curse a new target.\");\n\t\t\t\t\t\t\treturn{};\n\t\t\t\t\t\t}\n\t\t\t\t\t\t// Define duration based on spell level\n\t\t\t\t\t\tlet seconds = (args[0].spellLevel >= 5) ? 86400 :\n\t\t\t\t\t\t\t\t\t   (args[0].spellLevel >= 3) ? 28800 : 3600;\n\t\t\t\t\t\t// Define effect on caster\n\t\t\t\t\t\tconst effectData = {\n\t\t\t\t\t\t  changes: [\n\t\t\t\t\t\t\t{key: \"flags.midi-qol.Hexcurse\", mode: 5, value: targetUuid, priority: 20}, // who is marked\n\t\t\t\t\t\t\t// {key: \"flags.dnd5e.DamageBonusMacro\", mode: 0, value: `ItemMacro.${args[0].item.name}`, priority: 20} // macro to apply the damage\n\t\t\t\t\t\t  ],\n\t\t\t\t\t\t  origin: args[0].itemUuid, //flag the effect as associated to the spell being cast\n\t\t\t\t\t\t  disabled: false,\n\t\t\t\t\t\t  duration: {startTime: game.time.worldTime, seconds: seconds},\n\t\t\t\t\t\t  icon: args[0].item.img,\n\t\t\t\t\t\t  label: args[0].item.name\n\t\t\t\t\t\t}\n\t\t\t\t\t\tawait actor.createEmbeddedDocuments(\"ActiveEffect\", [effectData]);\n\t\t\t\t\t\t// Define effect on target\n\t\t\t\t\t\tconst teffectData = {\n\t\t\t\t\t\t  changes: [{key: `flags.midi-qol.disadvantage.ability.check.${stat}`, mode: 5,value: true, priority: 50}],\n\t\t\t\t\t\t  origin: args[0].itemUuid, //flag the effect as associated to the spell being cast\n\t\t\t\t\t\t  disabled: false,\n\t\t\t\t\t\t  duration: {startTime: game.time.worldTime, seconds: seconds},\n\t\t\t\t\t\t  icon: args[0].item.img,\n\t\t\t\t\t\t  label: args[0].item.name\n\t\t\t\t\t\t}\n\t\t\t\t\t\tawait tactor.createEmbeddedDocuments(\"ActiveEffect\", [teffectData]);\n\t\t\t\t\t\t// Update concentration duration\n\t\t\t\t\t\tlet effectcon = actor.effects.find(i => i.data.label === \"Concentrating\");\n\t\t\t\t\t\tlet duration = effectcon.data.duration;\n\t\t\t\t\t\tduration.seconds = seconds;\n\t\t\t\t\t\tawait effectcon.update({duration});\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// Clear effect on last target if 0 HP or stop\n\t\t\t\t\t\tlet oldtarget;\n\t\t\t\t\t\ttry{\n\t\t\t\t\t\t\toldtarget = await fromUuid(effect.data.changes[0].value)\n\t\t\t\t\t\t} catch(err) {\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (oldtarget != null && oldtarget != undefined){\n\t\t\t\t\t\t\tif (oldtarget.actor.data.data.attributes.hp.value > 0) {\n\t\t\t\t\t\t\t\tui.notifications.warn(\"You can only curse a new creature after the current one drops to 0 HP.\");\n\t\t\t\t\t\t\t\treturn{};\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tlet toldeffect = oldtarget.actor.effects.find(i => i.data.label === \"Hex\" && i.data.origin.includes(actor.id));\n\t\t\t\t\t\t\t\ttoldeffect.delete();\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\t// Update link (copied from changelog on midiqol documentation, I didn't really understand what this is doing but it is working (as of testing)\n\t\t\t\t\t\tlet cd = getProperty(actor.data, \"flags.midi-qol.concentration-data\");\n\t\t\t\t\t\tlet targets = duplicate(cd.targets || [])\n\t\t\t\t\t\ttargets[targets.findIndex(i => i.tokenUuid === effect.data.changes[0].value)] = {tokenUuid: targetUuid, actorUuid: tactor.uuid}\n\t\t\t\t\t\ttargets.push({\"actorUuid\": args[0].actorUuid, \"tokenUuid\": args[0].tokenUuid});\n\t\t\t\t\t\tactor.setFlag(\"midi-qol\", \"concentration-data.targets\", targets);\n\t\t\t\t\t\t// Update targetUuid on actor effect\n\t\t\t\t\t\tlet changes = effect.data.changes;\n\t\t\t\t\t\tchanges[0] = {key: \"flags.midi-qol.Hexcurse\", mode: 5, value: targetUuid, priority: 20} //who is marked\n\t\t\t\t\t\tawait effect.update({changes});\n\t\t\t\t\t\t// Define effect on target\n\t\t\t\t\t\tconst teffectData = {\n\t\t\t\t\t\t  changes: [{key: `flags.midi-qol.disadvantage.ability.check.${stat}`, mode: 5,value: true, priority: 50}],\n\t\t\t\t\t\t  origin: effect.data.origin, //flag the effect as associated to the original spell that was cast\n\t\t\t\t\t\t  disabled: false,\n\t\t\t\t\t\t  duration: {startTime: game.time.worldTime, seconds: effect.data.duration.seconds - (game.time.worldTime - effect.data.duration.startTime) },\n\t\t\t\t\t\t  icon: effect.data.icon,\n\t\t\t\t\t\t  label: effect.data.label\n\t\t\t\t\t\t}\n\t\t\t\t\t\tawait tactor.createEmbeddedDocuments(\"ActiveEffect\", [teffectData]);\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t},\n\t\t}\n\t}).render(true);\n} else if (args[0].tag === \"DamageBonus\") {\n    // only attacks\n    if (![\"mwak\",\"rwak\",\"msak\",\"rsak\"].includes(args[0].item.data.actionType)) return {};\n    let targetUuid = args[0].hitTargets[0].uuid;\n    // only on the marked target\n    if (targetUuid !== getProperty(args[0].actor.flags, \"midi-qol.Hexcurse\")) return {};\n    //let damageType = args[0].item.data.damage.parts[0][1];\n    const diceMult = args[0].isCritical ? 2: 1;\n    return {damageRoll: `${diceMult}d6[Necrotic]`, flavor: \"Hex Damage\"}\n}","folder":null,"sort":0,"permission":{"default":0,"wCsoNxA9I9elUaGF":3},"flags":{"core":{"sourceId":"Macro.78HFo89TRoESFXdw"}},"_id":"IrwO4vbWRRYjCyob"}
