{"_id":"Fa1wGSaq5J1GArjB","name":"Random Cutting Words","permission":{"default":0,"y5gmtwxmW3A5ZuOP":3},"type":"script","flags":{},"scope":"global","command":"// Courtesy of @Zarek\n// Selected target receives a random cutting word from a table called \"Mockeries\" along with the roll reduction.\n// You can find a mockeries table in the community table module.\n\nlet cuttingWords = () => {\n  // Setup variables\n  let tableName = \"mockeries\";\n  let mockery = \"Now go away or I shall taunt you a second time-a!\"; // if table can't be found, use this.\n\n  if (!actor) {\n    ui.notifications.warn(\"You must have an actor selected.\");\n    return\n  }\n  \n  let actorLevels = actor.data.data.levels || 1;\n  let table = game.tables.entities.find(t => t.name == tableName);\n  // Get Targets name\n  const targetId = game.user.targets.ids[0];\n  const targetToken = canvas.tokens.get(targetId);\n  if (!targetToken) {\n    ui.notifications.warn(\"You must target a token.\");\n    return\n  }\n  const targetName = targetToken.name;\n\n  // Roll the result, and mark it drawn\n  if (table) {\n    if (checkTable(table)) {\n      let roll = table.roll();\n      let result = roll.results[0];\n      mockery = result.text;\n      table.updateEmbeddedEntity(\"TableResult\", {\n        _id: result._id,\n        drawn: true\n      });\n    }\n  }\n\n  function checkTable(table) {\n    let results = 0;\n    for (let data of table.data.results) {\n      if (!data.drawn) {\n        results++;\n      }\n    }\n    if (results < 1) {\n      table.reset();\n      ui.notifications.notify(\"Table Reset\")\n      return false\n    }\n    return true\n  }\n\n  let dieType = 'd6';\n  if (actorLevels >= 15) {\n    dieType = 'd12';\n  } else if (actorLevels >= 10) {\n    dieType = 'd10';\n  } else if (actorLevels >= 5) {\n    dieType = 'd8';\n  }\n\n  let messageContent = `<p>${targetName} Reduce your roll by: <b>[[1${dieType}]]</b>.</p>`\n  messageContent += `<p>${token.name} exclaims <b><i>\"${mockery}\"</i></b></p>`\n  messageContent += `<details closed=\"\"><summary><a>Cutting Words</a></summary>\n  <p>When a creature that you can see within 60 feet of you makes an <b>Attack roll, an ability check, or a damage roll</b>, you can use your <b>Reaction</b> to expend one of your uses of <b>Bardic Inspiration</b>,\n  rolling a Bardic Inspiration die and subtracting the number rolled from the creature’s roll.</p>\n  <p>You can choose to use this feature after the creature makes its roll, but before the GM determines whether the Attack roll or ability check succeeds or fails, or before the creature deals its damage. \n  The creature is immune if it can’t hear you or if it’s immune to being <b>Charmed</b>.</p></details>`\n\n  // create the message\n  if (messageContent !== '') {\n    let chatData = {\n      user: game.user._id,\n      speaker: ChatMessage.getSpeaker(),\n      content: messageContent,\n    };\n    ChatMessage.create(chatData, {});\n  }\n};\n\ncuttingWords();\n","author":"y5gmtwxmW3A5ZuOP","img":"icons/svg/dice-target.svg","actorIds":[]}
{"_id":"La6FnFrqIgommZor","name":"Sharpshooter","permission":{"default":0,"y5gmtwxmW3A5ZuOP":3},"type":"script","flags":{},"scope":"global","command":"/*\nCreated Monkan#8752 with guidance from the Rage macro in the FVTT Community Macros\n\nTips to make it work\n 1 -    Have a feature called 'Sharpshooter' for your character.\n 2 -    Make sure you have your weapons with Ranged Weapon Attack. \n 3 -    if you make any changes to your damage or attack calculations, make sure you toggle it off.\n        As it stores the old values to replace once you disable the feat.  It could undo your changes.\n*/\n\nlet ss='';\nlet chatMsg='';\n\n\nif (actor !== undefined && actor !== null) {\n    // find the feat Sharpshooter\n    ss = actor.items.find(i => i.name === 'Sharpshooter');\n    if (ss == undefined) { \n        ui.notifications.warn(\"Please select a single token with the Sharpshooter feat.\");        \n    }\n\n    if (ss !== undefined && ss !== null) {\n\t\tchatMsg = '';\n\t\tlet enabled = false;\n\t\t// store the state of the Sharpshooter toggle in flags\n\t\tif (actor.data.flags.ssMacro !== null && actor.data.flags.ssMacro !== undefined) {\n\t\t\tenabled = true;\n\t\t}\n\t\t// if Sharpshooter is active, disable it\n\t\tif (enabled) {\n            chatMsg = `${actor.name} is aiming Normally now.`;\n            \n            let obj = {};\n\t\t\tobj['flags.ssMacro'] = null;\t\t\t\n\t\t\tactor.update(obj);\n\n\t\t\t// reset items\n\t\t\tfor (let item of actor.items) {\n\t\t\t\tif (item.data.flags.ssMacro !== null && item.data.flags.ssMacro !== undefined) {\n\t\t\t\t\t// restoring the old value from flags\n                    let oldDmg = item.data.flags.ssMacro.oldDmg;\n                    let oldAtk = item.data.flags.ssMacro.oldAtk;\n\t\t\t\t\tlet obj = {};\n                    obj['data.damage.parts'] = oldDmg;\n                    obj['data.attackBonus'] = oldAtk;\n\t\t\t\t\tobj['flags.ssMacro'] = null;\n\t\t\t\t\titem.update(obj);\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t// if Sharpshooter is disabled, enable it\n\t\t} else {\n            chatMsg = `${actor.name} is aiming very carefully!`;\n            \n            let obj = {};\n\t\t\tobj['flags.ssMacro.enabled'] = true;\n\t\t\tactor.update(obj);\n\n            // update items\n            let ssAtk = -5;\n\t\t\tlet ssDmg = 10;\n\t\t\tfor (let item of actor.items) {\n                let isRanged = getProperty(item, 'data.data.actionType') === 'rwak';                \n\t\t\t\tif (isRanged && item.data.data.damage.parts.length > 0) {\n\t\t\t\t\tconsole.log('updating ' + item);\n                    let obj = {};\n                    let atk = item.data.data.attackBonus;\n                    let dmg = item.data.data.damage.parts;\n                    // Save old attack and damage values\n                    obj['flags.ssMacro.oldDmg'] = JSON.parse(JSON.stringify(dmg));\n                    obj['flags.ssMacro.oldAtk'] = JSON.parse(JSON.stringify(atk));\n                    // Set the new attack and damage values\n                    if (atk !== null) {\n                        atk += '' + ssAtk;\n                    } else {\n                        atk = ssAtk;\n                    }\n\t\t\t\t\tdmg[0][0] = `${dmg[0][0]} + ${ssDmg}`;\n                    obj['data.damage.parts'] = dmg;\n                    obj['data.attackBonus'] = atk;\n\t\t\t\t\titem.update(obj);\n\t\t\t\t}\n\t\t\t}\n\n\t\t}\n    }\n\n} else ui.notifications.warn(\"Please select a token.\");\n\n// write to chat if needed:\nif (chatMsg !== '') {\n\tlet chatData = {\n\t\tuser: game.user._id,\n\t\tspeaker: ChatMessage.getSpeaker(),\n\t\tcontent: chatMsg\n    };\n\tChatMessage.create(chatData, {});\n}","author":"y5gmtwxmW3A5ZuOP","img":"icons/svg/dice-target.svg","actorIds":[]}
{"_id":"USJZMHU93aFklWYM","name":"Change Disposition","permission":{"default":0,"y5gmtwxmW3A5ZuOP":3},"type":"script","flags":{},"scope":"global","command":"let applyChanges = false;\nnew Dialog({\n  title: `Token Disposition Changer`,\n  content: `\n    <form>\n      <div class=\"form-group\">\n        <label>Disposition Type:</label>\n        <select id=\"dispo-type\" name=\"dispo-type\">\n          <option value=\"nochange\">No Change</option>\n          <option value=\"hostile\">Hostile</option>\n          <option value=\"neutral\">Neutral</option>\n          <option value=\"friendly\">Friendly</option>\n        </select>\n      </div>\n    </form>\n    `,\n  buttons: {\n    yes: {\n      icon: \"<i class='fas fa-check'></i>\",\n      label: `Apply Changes`,\n      callback: () => applyChanges = true\n    },\n    no: {\n      icon: \"<i class='fas fa-times'></i>\",\n      label: `Cancel Changes`\n    },\n  },\n  default: \"yes\",\n  close: html => {\n    if (applyChanges) {\n      for ( let token of canvas.tokens.controlled ) {\n        let dispoType = html.find('[name=\"dispo-type\"]')[0].value || \"none\";\n        switch (dispoType) {\n          case \"hostile\":\n            token.update({\"disposition\": -1});\n            break;\n          case \"friendly\":\n            token.update({\"disposition\": 1});\n            break;\n          case \"neutral\":\n            token.update({\"disposition\": 0});\n            break;\n          case \"nochange\":\n          default:\n        }\n      }\n    }\n  }\n}).render(true);\n","author":"y5gmtwxmW3A5ZuOP","img":"icons/svg/dice-target.svg","actorIds":[]}
{"_id":"XGhD5LFKknPzy7ar","name":"Great Weapon Master","permission":{"default":0,"y5gmtwxmW3A5ZuOP":3},"type":"script","flags":{},"scope":"global","command":"/*\nCreated Monkan#8752 with guidance from the Rage macro in the FVTT Community Macros\n\nTips to make it work\n 1 -    Have a feature called 'Great Weapon Master' for your character.\n 2 -    Make sure you have your weapons with Heavy property filled out. \n 3 -    if you make any changes to your damage or attack calculations, make sure you toggle it off.\n        As it stores the old values to replace once you disable the feat.  It could undo your changes.\n*/\n\nlet gwm='';\nlet chatMsg='';\n\n\nif (actor !== undefined && actor !== null) {\n    // find the feat Great Weapon Master\n    gwm = actor.items.find(i => i.name === 'Great Weapon Master');\n    if (gwm == undefined) { \n        ui.notifications.warn(\"Please select a single token with the Great Weapon Master feat.\");        \n    }\n\n    if (gwm !== undefined && gwm !== null) {\n\t\tchatMsg = '';\n\t\tlet enabled = false;\n\t\t// store the state of the GWM toggle in flags\n\t\tif (actor.data.flags.gwmMacro !== null && actor.data.flags.gwmMacro !== undefined) {\n\t\t\tenabled = true;\n\t\t}\n\t\t// if GWM is active, disable it\n\t\tif (enabled) {\n            chatMsg = `${actor.name} is swinging Normally now.`;\n            \n            let obj = {};\n\t\t\tobj['flags.gwmMacro'] = null;\t\t\t\n\t\t\tactor.update(obj);\n\n\t\t\t// reset items\n\t\t\tfor (let item of actor.items) {\n\t\t\t\tif (item.data.flags.gwmMacro !== null && item.data.flags.gwmMacro !== undefined) {\n\t\t\t\t\t// restoring the old value from flags\n                    let oldDmg = item.data.flags.gwmMacro.oldDmg;\n                    let oldAtk = item.data.flags.gwmMacro.oldAtk;\n\t\t\t\t\tlet obj = {};\n                    obj['data.damage.parts'] = oldDmg;\n                    obj['data.attackBonus'] = oldAtk;\n\t\t\t\t\tobj['flags.gwmMacro'] = null;\n\t\t\t\t\titem.update(obj);\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t// if GWM is disabled, enable it\n\t\t} else {\n            chatMsg = `${actor.name} is swinging Harder!`;\n            \n            let obj = {};\n\t\t\tobj['flags.gwmMacro.enabled'] = true;\n\t\t\tactor.update(obj);\n\n            // update items\n            let gwmAtk = -5;\n\t\t\tlet gwmDmg = 10;\n\t\t\tfor (let item of actor.items) {\n                let isMelee = getProperty(item, 'data.data.actionType') === 'mwak';\n                let isHeavy = getProperty(item, 'data.data.properties.hvy')\n\t\t\t\tif (isMelee && isHeavy && item.data.data.damage.parts.length > 0) {\n\t\t\t\t\tconsole.log('updating ' + item);\n                    let obj = {};\n                    let atk = item.data.data.attackBonus;\n                    let dmg = item.data.data.damage.parts;\n                    // Save old attack and damage values\n                    obj['flags.gwmMacro.oldDmg'] = JSON.parse(JSON.stringify(dmg));\n                    obj['flags.gwmMacro.oldAtk'] = JSON.parse(JSON.stringify(atk));\n                    // Set the new attack and damage values\n                    if (atk !== null) {\n                        atk += '' + gwmAtk;\n                    } else {\n                        atk = gwmAtk;\n                    }\n\t\t\t\t\tdmg[0][0] = `${dmg[0][0]} + ${gwmDmg}`;\n                    obj['data.damage.parts'] = dmg;\n                    obj['data.attackBonus'] = atk;\n\t\t\t\t\titem.update(obj);\n\t\t\t\t}\n\t\t\t}\n\n\t\t}\n    }\n\n} else ui.notifications.warn(\"Please select a token.\");\n\n// write to chat if needed:\nif (chatMsg !== '') {\n\tlet chatData = {\n\t\tuser: game.user._id,\n\t\tspeaker: ChatMessage.getSpeaker(),\n\t\tcontent: chatMsg\n    };\n\tChatMessage.create(chatData, {});\n}","author":"y5gmtwxmW3A5ZuOP","img":"icons/svg/dice-target.svg","actorIds":[]}
{"_id":"YTCLwzzucNLqs9u1","name":"Divine Smite","permission":{"default":0,"y5gmtwxmW3A5ZuOP":3},"type":"script","flags":{},"scope":"global","command":"/*\n * The Smite macro emulates the Divine Smite feature of Paladins in DnD 5e. A spell slot level to use\n * can be selected, which increases the number of damage dice, and smiting a fiend or undead\n * will also increase the number of damage dice.\n * \n * First, select a token to perform the smite, then target an enemy to be smitten. Make your regular \n * attack and then if you choose to use Divine Smite, run this macro.\n */\n\nlet confirmed = false;\n\n// Create a dialogue box to select spell slot level to use when smiting.\nnew Dialog({\n    title: \"Divine Smite Damage\",\n    content: `\n     <p>Spell Slot level to use Divine Smite with.</p>\n     <form>\n      <div class=\"form-group\">\n       <label>Spell Slot Level:</label>\n       <select id=\"slot-level\" name=\"slot-level\">\n        <option value=\"1\">1</option>\n        <option value=\"2\">2</option>\n        <option value=\"3\">3</option>\n        <option value=\"4\">4</option>\n        <option value=\"5\">5</option>\n       </select>\n      </div>\n     </form>\n     `,\n    buttons: {\n        one: {\n            icon: '<i class=\"fas fa-check\"></i>',\n            label: \"SMITE!\",\n            callback: () => confirmed = true\n        },\n        two: {\n            icon: '<i class=\"fas fa-times\"></i>',\n            label: \"Cancel\",\n            callback: () => confirmed = false\n        }\n    },\n    default: \"Cancel\",\n    close: html => {\n        if (confirmed) {\n            let slotLevel = parseInt(html.find('[name=slot-level]')[0].value);\n            smite(slotLevel);\n        }\n    }\n}).render(true);\n\n/**\n * Gives the spell slot information for a particular actor and spell slot level.\n * @param {Actor5e} actor - the actor to get slot information from.\n * @param {integer} level - the spell slot level to get information about. level 0 is deprecated.\n * @returns {object} contains value (number of slots remaining), max, and override.\n */\nfunction getSpellSlots(actor, level) {\n    let spells = actor.data.data.spells;\n    switch (level) {\n        case 1:\n            return spells.spell1;\n        case 2:\n            return spells.spell2;\n        case 3:\n            return spells.spell3;\n        case 4:\n            return spells.spell4;\n        case 5:\n            return spells.spell5;\n    }\n}\n\n/**\n * Use the controlled token to smite the targeted token.\n * @param {integer} slotLevel - the spell slot level to use when smiting.\n */\nfunction smite(slotLevel) {\n    let targets = game.user.targets;\n    let suseptible = [\"fiend\", \"undead\"];\n    let controlledActor = canvas.tokens.controlled[0].actor;\n    let chosenSpellSlots = getSpellSlots(controlledActor, slotLevel);\n\n    if (chosenSpellSlots.value < 1) {\n        ui.notifications.error(\"No spell slots of the required level available.\");\n        return;\n    }\n    if (targets.size !== 1) {\n        ui.notifications.error(\"You must target exactly one token to Smite.\");\n        return;\n    }\n\n    targets.forEach(target => {\n        let numDice = slotLevel + 1;\n        let type = target.actor.data.data.details.type.toLocaleLowerCase();\n        if (suseptible.includes(type)) numDice += 1;\n        new Roll(`${numDice}d8`).roll().toMessage({ flavor: \"Macro Divine Smite - Damage Roll (Radiant)\", speaker })\n    })\n\n    chosenSpellSlots.value -= 1;\n}","author":"y5gmtwxmW3A5ZuOP","img":"icons/svg/dice-target.svg","actorIds":[]}
{"_id":"ZvtYrzlv9dPpq9Pu","name":"Random Mockeries","permission":{"default":0,"y5gmtwxmW3A5ZuOP":3},"type":"script","flags":{},"scope":"global","command":"// Courtesy of @Zarek\n// Selected target receives a random mockery from a table called \"mockeries\" along with the DC and damage.\n// You can find a table called mockeries in the community tables module.\n\n\nlet tableName = \"mockeries\";\n// default mockery if no table found.\nlet mockery = \"Now go away or I shall taunt you a second time-a!\";\n\nlet viciousMockeries = () => {\n  if (!actor) {\n    ui.notifications.warn(\"You must have an actor selected.\");\n    return\n  }\n\n  let actorLevels = actor.data.data.levels || 1;\n  let table = game.tables.entities.find(t => t.name == tableName);\n\n  // Get Targets name\n  const targetId = game.user.targets.ids[0];\n  const targetToken = canvas.tokens.get(targetId);\n  if (!targetToken) {\n    ui.notifications.warn(\"You must target a token.\");\n    return\n  }\n  const targetName = targetToken.name;\n\n  // Roll the result, and mark it drawn\n  if (table) {\n    if (checkTable(table)) {\n      let roll = table.roll();\n      let result = roll.results[0];\n      mockery = result.text;\n      table.updateEmbeddedEntity(\"TableResult\", {\n        _id: result._id,\n        drawn: true\n      });\n    }\n  }\n\n  function checkTable(table) {\n    let results = 0;\n    for (let data of table.data.results) {\n      if (!data.drawn) {\n        results++;\n      }\n    }\n    if (results < 1) {\n      table.reset();\n      ui.notifications.notify(\"Table Reset\")\n      return false\n    }\n    return true\n  }\n\n  // Add a message with damage roll\n  let numDie = 1;\n  if (actorLevels >= 17) {\n    numDie = 4;\n  } else if (actorLevels >= 11) {\n    numDie = 3;\n  } else if (actorLevels >= 5) {\n    numDie = 2;\n  }\n\n  let messageContent = `<p>${targetName} Roll WIS save DC [[8+${actor.data.data.abilities.cha.mod}+@attributes.prof]] or take [[${numDie}d4]] damage and have disadvantage.</p>`\n  messageContent += `<p>${token.name} exclaims <b><i>\"${mockery}\"</i></b></p>`\n  messageContent += `<details closed=\"\"><summary><a>Vicious Mockery</a></summary><p>You unleash a string of insults laced with subtle enchantments at a creature you can see within range. If the target can hear you (though it need not understand you), it must succeed on a <strong>Wisdom saving throw</strong> or take <strong>1d4 psychic damage</strong> and have <strong>disadvantage on the next attack roll</strong> it makes before the end of its next turn.</p>\n    <p>This spell’s damage increases by 1d4 when you reach 5th level ([[/r 2d4]]), 11th level ([[/r 3d4]]), and 17th level ([[/r 4d4]]).</p></details>`\n\n  // create the message\n  if (messageContent !== '') {\n    let chatData = {\n      user: game.user._id,\n      speaker: ChatMessage.getSpeaker(),\n      content: messageContent,\n    };\n    ChatMessage.create(chatData, {});\n  }\n};\n\nviciousMockeries();\n","author":"y5gmtwxmW3A5ZuOP","img":"icons/svg/dice-target.svg","actorIds":[]}
{"_id":"cVkN7qB4m1mRauBE","name":"Remove Conditions","permission":{"default":0,"y5gmtwxmW3A5ZuOP":3},"type":"script","flags":{},"scope":"global","command":"for ( let token of canvas.tokens.controlled ){\n  await token.update({\"effects\": []});\n}\n","author":"y5gmtwxmW3A5ZuOP","img":"icons/svg/dice-target.svg","actorIds":[]}
{"_id":"devQi2BcIDhI0z1o","name":"Random Inspiration","permission":{"default":0,"y5gmtwxmW3A5ZuOP":3},"type":"script","flags":{},"scope":"global","command":"// Courtesy of @Zarek\n// Selected target receives a random inspiration from a table called \"inspirations\".\n// You can find a table called inspirations in the community tables module\n\n// Setup variables\nlet tableName = \"inspirations\";\n\nlet bardicInspiration = () => {\n  if (!actor) {\n    ui.notifications.warn(\"You must have an actor selected.\");\n    return\n  }\n\n  // Get Targets name\n  let actorLevels = actor.data.data.levels || 1;\n  const targetId = game.user.targets.ids[0];\n  const targetToken = canvas.tokens.get(targetId);\n  if (!targetToken) {\n    ui.notifications.warn(\"You must target a token.\");\n    return\n  }\n  const targetName = targetToken.name;\n\n\n  let table = game.tables.entities.find(t => t.name == tableName);\n\n  //default inspiration if no table is found.\n  //let inspiration = \"Cowards die many times before their deaths; the valiant never taste death but once.\";\n  let inspiration = `I don't know what effect ${targetName} will have upon the enemy, but, by God, he terrifies me.`;\n  \n  // Roll the result, and mark it drawn\n  if (table) {\n    if (checkTable(table)) {\n      // let result = table.roll()[1];\n      let roll = table.roll();\n      let result = roll.results[0];\n      inspiration = result.text;\n      table.updateEmbeddedEntity(\"TableResult\", {\n        _id: result._id,\n        drawn: true\n      });\n    }\n  }\n\n  function checkTable(table) {\n    let results = 0;\n    for (let data of table.data.results) {\n      if (!data.drawn) {\n        results++;\n      }\n    }\n    if (results < 1) {\n      table.reset();\n      ui.notifications.notify(\"Table Reset\")\n      return false\n    }\n    return true\n  }\n\n  let dieType = 'd6';\n  if (actorLevels >= 15) {\n    dieType = 'd12';\n  } else if (actorLevels >= 10) {\n    dieType = 'd10';\n  } else if (actorLevels >= 5) {\n    dieType = 'd8';\n  }\n\n  let messageContent = '';\n  messageContent += `<p>${token.name} exclaims <b><i>\"${inspiration}\"</i></b></p>`\n  messageContent += `<p>${targetName} is inspired.</p>`\n  messageContent += `<details closed=\"\"><summary><a>Bardic Inspiration</a></summary><p>${targetName} gains one Bardic Inspiration die, a <strong>${dieType}</strong>.<br>Once within the next 10 minutes, ${targetName} can roll the die and add the number rolled to one <b>ability check, attack roll, or saving throw</b>. ${targetName} can wait until after it rolls the <strong>d20</strong> before deciding to use the Bardic Inspiration die, but must decide before the DM says whether the roll succeeds or fails. Once the Bardic Inspiration die is rolled, it is lost.</p></details>`\n\n  // create the message\n  if (messageContent !== '') {\n    let chatData = {\n      user: game.user._id,\n      speaker: ChatMessage.getSpeaker(),\n      content: messageContent,\n    };\n    ChatMessage.create(chatData, {});\n  }\n};\nbardicInspiration();\n","author":"y5gmtwxmW3A5ZuOP","img":"icons/svg/dice-target.svg","actorIds":[]}
{"_id":"h7QwZjOWiLiQ4emI","name":"Get Passive Perception","permission":{"default":0,"y5gmtwxmW3A5ZuOP":3},"type":"script","flags":{},"scope":"global","command":"// pull each player's passive perception then whisper the GM with the results.\n// author @Erogroth#7134\n\nlet actors = game.actors.entities.filter(e=> e.data.type==='character');\n\n// pull each player's passive perception\nlet messageContent = '';\nlet messageHeader = '<b>Passive Perception</b><br>';\nfor(let actor of actors) {\n  let pp = actor.data.data.skills.prc.passive; // this gives the passive perception\n   messageContent += `${actor.name} <b>${pp}</b><br>`; // creating the output string\n}\n\n// create the message\nif(messageContent !== '') {\n  let chatData = {\n    user: game.user._id,\n    speaker: ChatMessage.getSpeaker(),\n    content: messageHeader + messageContent,\n    whisper: game.users.entities.filter(u => u.isGM).map(u => u._id)\n  };\n  ChatMessage.create(chatData, {});\n}\n","author":"y5gmtwxmW3A5ZuOP","img":"icons/svg/dice-target.svg","actorIds":[]}
{"_id":"hW29VmM09DenDXNz","name":"Rage","permission":{"default":0,"y5gmtwxmW3A5ZuOP":3},"type":"script","flags":{},"scope":"global","command":"//\t\tDISCLAIMER:\t\tThis macro is an evolved version of the original D&D 5e Rage Macro masterwork written by Felix#6196.\n//\t\t\t\t\t\tNorc#5108 is now maintaining this macro along with continued support from Felix.\n//\n//\n//\t\tUpdates:\t\t1. \tFixed errors resulting from declarations of \"actor\" and \"token\" in a script macro. \n//\t\t\t\t\t\t2. \tAdded automatic Totem Spirit: Bear detection and resistance application \n//\t\t\t\t\t\t\tPLEASE NOTE: A minor update to the Totem Spirit item's name in the character sheet is needed if \n//\t\t\t\t\t\t\tthe VTTA Beyond Integration was not used to create sheet. See Bonus Tip 1 below\n//\t\t\t\t\t\t3. \tAdded error messages for trying to rage with no token or no barbarian selected\n//\t\t\t\t\t\t4. \t(Felix) added resource/usage deduction and errors (re-added after accidentally overwriting the addition) \n//\t\t\t\t\t\t5. \t(Felix, 2020/05/29) Fixed rage damage at level 8\n//\t\t\t\t\t\t6. \t(2020/05/30) Implemented Felix's idea to use global melee weapon attack bonus instead of modifying items\n//\t\t\t\t\t\t7. \t(2020/05/30) Improved Rage icon toggling to be more reliable\n//\t\t\t\t\t\t8. \t(2020/05/30) Removed code from the resource management that created dependency on The Furnace Advanced Macros\n//\t\t\t\t\t\t9. \t(2020/05/30) Implemented Felix's fix for issue where new resistances and rage uses were not saving properly\n//\t\t\t\t\t\t10.\t(2020/05/30) Fixed rage damage formula again...\n//\t\t\t\t\t\t11.\t(2020/05/30) Added basic support for non-strength Based barbarians (Dex, Hexblade)\n//\t\t\t\t\t\t12.\t(2020/05/30) Added optional ability to toggle the icon and name of the macro itself based on current raging state.\n\n//!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n//!!!   OPTIONAL TOKEN ICON-\tOn by default. If a path to a rage icon is defined, it displays like a condition on the raging barbarian.\n//!!!\t\t\t\t\t\t\tTo use a different icon, manually change the filepath below or leave it empty ('') to disable the effect.\n//!!!\nconst rageIconPath = 'icons/svg/explosion.svg';\n//!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n\n//!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n//!!!   OPTIONAL RESOURCE DEDUCTION \tOn by default. First option automatically subtracts from the Rage Resource if enabled.\n//!!!\t\t\t\t\t\t\t\t\tSecond option prevents raging if no Rage resource is left. Set to false if you do not want this.\n\n\t\t\t\tconst deductResource = true;\n\t\t\t\tconst preventNegativeResource = true;\n//!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n\n//!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n//!!!   OPTIONAL NON-STRENGTH BARBARIAN SUPPORT\t\tONLY override to FALSE if your barbarian does not use Strength to make melee attacks\n//!!!\t\t\t\t\t\t\t\t\t\t\t\tand therefore does not get the Rage bonus to melee weapon attack damage. \n//!!!\t\t\n\t\t\t\tconst strAttacks = true;\n//!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n\n//!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n//!!!\tEXPERIMENTAL MACRO ICON/NAME TOGGLE\t\tIf enabled, the macro icon and name toggles based on the barbarian's rage state. \n//!!!\t\t\t\t\t\t\t\t\t\t\tCAUTIONS: \t1. \tThis feature is off by default and is intended for ADVANCED USERS ONLY. \n//!!! \t\t\t\t\t\t\t\t\t\t\t\t\t\t2. \tRequires configuration using \"The Furnace\" module for a player to run!\n//!!!\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tThe GM needs to grant The Furnace's \"Run as GM\" permission for this macro.\n//!!!\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t3. \tWorks best with only one barbarian using this feature at a time.\n\n\t\t\t\t//To auto-toggle the macro's icon/name, override toggleMacro to true below.\n\t\t\t\tconst toggleMacro = false;\n\n\t\t\t\t//To use a different icon, manually change the filepath here\n\t\t\t\tconst stopRageIconPath = 'icons/svg/unconscious.svg';\n\n\t\t\t\t//You must update the following constant to this macro's exact for the macro icon toggling to work.\n\t\t\t\tconst rageMacroName = 'Rage';\n//!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n\n//!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n//!!!\tBonus Tip 1: Bear Totem Spirit Barbs\n//!!!\tIf you chose the Spirit Seeker Primal path, and at level 3 you chose the Bear Totem Spirit (resistance to all non-psychic damage), \n//!!!\tin your 5E character sheet, double-check that the name of your Totem Spirit feature to EXACTLY \"Totem Spirit: Bear\".  Note: Importing\n//!!!\tvia VTTA Beyond Integration uses this name already. The macro then automatically adds the extra Bear Totem Spirit resistances.\n//!!!\n//!!!\tBonus Tip 2: Thrown Weapons\n//!!!\tWhen a barb throws a weapon using strength, typically a javelin but also possibly a dagger, dart, sword, bar table etc, the rage bonus\n//!!!\tshould not be added because it is a ranged attack. However, D&D5E calls javelins and daggers Melee Weapons, because technically they\n//!!!\tare both. To solve this issue, if you always throw the weapon, click the weapon's details and change the attack type to \"Ranged Weapon\n//!!!\tAttack\" in the Action Type dropdown. If you want, you can add a second copy of the item (with no weight/quantity) to use for meleeing.\n//!!!\n//!!!\tBonus Tip 3: The Rage Condition                                                                                                                       \n//!!!\tIf you use the Combat Utility Belt module's Condition Lab, try adding a condition called \"Raging\" with the same icon \t\t\t   \n//!!!\tas the optional rage icon overlay, 'icons/svg/explosion.svg' by default.  See OPTIONAL TOKEN/MACRO ICONS section above.\n//!!!\n//!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n\n//declarations\nlet barb = '';\nlet chatMsg = '';\nlet bear = '';\nlet noRage = false;\nlet toggleResult = false;\n\n//main\n//check to see if Actor exists and is a barbarian\nif (actor !== undefined && actor !== null) {\n\t\t\t\t\n\t// get the barbarian class item\n\tbarb = actor.items.find(i => i.name === 'Barbarian');\n\tif (barb == undefined) {\n\t\tui.notifications.warn(\"Please select a single barbarian token.\");\n\t}\n\tif (barb !== undefined && barb !== null) {\n\t\tchatMsg = '';\n\t\tlet enabled = false;\n\t\t// store the state of the rage toggle in flags\n\t\tif (actor.data.flags.rageMacro !== null && actor.data.flags.rageMacro !== undefined) {\n\t\t\tenabled = true;\n\t\t}\n\t\t\n\t\t// if rage is active, disable it\n\t\tif (enabled) {\n\t\t\tchatMsg = `${actor.name} is no longer raging.`;\n\t\t\t// reset resistances and melee weapon attack bonus\n\t\t\tlet obj = {};\n\t\t\tobj['flags.rageMacro'] = null;\n\t\t\tobj['data.traits.dr'] = actor.data.flags.rageMacro.oldResistances;\n\t\t\tlet test=0;\t\t\t\n\t\t\tobj['data.bonuses.mwak.damage'] = actor.data.flags.rageMacro.oldDmg;\t\n\t\t\tactor.update(obj);\n\t\t\t\n\t\t// if rage is disabled, enable it\n\t\t} else {\n\t\t\tif (deductResource) {\n\t\t\t\tlet hasAvailableResource = false;\n\t\t\t\tlet newResources = duplicate(actor.data.data.resources)\t\t\t\t\n\t\t\t\tlet obj = {}\n\t\t\t\t// Look for Resources under the Core actor data\n\t\t\t\tlet resourceKey = Object.keys(actor.data.data.resources).filter(k => actor.data.data.resources[k].label === \"Rage\").shift();\n\t\t\t\tif (resourceKey && (actor.data.data.resources[resourceKey].value > 0 || !preventNegativeResource)) {\n\t\t\t\t\thasAvailableResource = true;\n\t\t\t\t\tnewResources[resourceKey].value--;\t\t\t\t\t\n\t\t\t\t\tobj['data.resources'] = newResources \n\t\t\t\t\tactor.update(obj);\n\t\t\t\t}\n\t\t\t\tif (!hasAvailableResource) {\n\t\t\t\t\tui.notifications.error(`${actor.name} does not have any rage left, time for a long rest!`);\n\t\t\t\t\tnoRage=true;\n\t\t\t\t}\n\t\t\t\tif (actor.sheet.rendered) {\n\t\t\t\t\t// Update the actor sheet if it is currently open\n\t\t\t\t\tactor.render(true);\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t//activate rage if there is rage available, or if it is okay to rage with 0 resources\n\t\t\tif (!noRage) {\n\t\t\t\tchatMsg = `${actor.name} is RAAAAAGING!`;\n\t\t\t\t// update resistance\n\t\t\t\tlet obj = {};\n\t\t\t\t// storing old resistances in flags to restore later\n\t\t\t\tobj['flags.rageMacro.enabled'] = true;\n\t\t\t\tobj['flags.rageMacro.oldResistances'] = JSON.parse(JSON.stringify(actor.data.data.traits.dr));\n\t\t\t\t// add bludgeoning, piercing and slashing resistance\n\t\t\t\tlet newResistance = duplicate(actor.data.data.traits.dr);\n\t\t\t\tif (newResistance.value.indexOf('bludgeoning') === -1) newResistance.value.push('bludgeoning');\n\t\t\t\tif (newResistance.value.indexOf('piercing') === -1) newResistance.value.push('piercing');\n\t\t\t\tif (newResistance.value.indexOf('slashing') === -1) newResistance.value.push('slashing');\n\t\t\t\t//If bear totem, add bear totem resistances.\n\t\t\t\tbear = actor.items.find(i => i.name === \"Totem Spirit: Bear\")\n\t\t\t\tif (bear !== undefined && bear!== null) {\n\t\t\t\t\tif (newResistance.value.indexOf('acid') === -1) newResistance.value.push('acid');\n\t\t\t\t\tif (newResistance.value.indexOf('cold') === -1) newResistance.value.push('cold');\n\t\t\t\t\tif (newResistance.value.indexOf('fire') === -1) newResistance.value.push('fire');\n\t\t\t\t\tif (newResistance.value.indexOf('force') === -1) newResistance.value.push('force');\n\t\t\t\t\tif (newResistance.value.indexOf('lightning') === -1) newResistance.value.push('lightning');\n\t\t\t\t\tif (newResistance.value.indexOf('necrotic') === -1) newResistance.value.push('necrotic');\n\t\t\t\t\tif (newResistance.value.indexOf('poison') === -1) newResistance.value.push('poison');\n\t\t\t\t\tif (newResistance.value.indexOf('radiant') === -1) newResistance.value.push('radiant');\n\t\t\t\t\tif (newResistance.value.indexOf('thunder') === -1) newResistance.value.push('thunder');\n\t\t\t\t}\n\t\t\t\tobj['data.traits.dr'] = newResistance;\n\t\t\t\tactor.update(obj);\n\t\t\t\n\t\t\t\t// For Strength barbarians, update global melee weapon attack bonus to include rage bonus\n\t\t\t\tif (strAttacks) {\n\t\t\t\t\t// Preserve old mwak damage bonus if there was one\n\t\t\t\t\tlet dmg = actor.data.data.bonuses.mwak.damage;\n\t\t\t\t\tif (dmg==null || dmg == undefined || dmg == '') dmg = 0;\n\t\t\t\t\tobj['flags.rageMacro.oldDmg'] = JSON.parse(JSON.stringify(dmg));\n\t\t\t\n\t\t\t\t\t// Determining the barbarian level\n\t\t\t\t\tlet barblvl = barb.data.data.levels;\n\t\t\t\n\t\t\t\t\t// Formula to determine the rage bonus damage depending on barbarian level\n\t\t\t\t\tlet lvlCorrection =  barblvl === 16 || barblvl === 17 ? 1 : 0;\n\t\t\t\t\tlet rageDmg = 2 + Math.floor(barblvl / 9) + lvlCorrection;\n\t\t\t\t\n\t\t\t\t\t//actually add the bonus rage damage to the previous bonus damage\n\t\t\t\t\t//respect roll formulas if present.\n\t\t\t\t\tif (parseInt(dmg) == dmg) {\n\t\t\t\t\t\tobj['data.bonuses.mwak.damage'] = parseInt(dmg) + rageDmg;\n\t\t\t\t\t} else {\n\t\t\t\t\tobj['data.bonuses.mwak.damage'] = `${dmg} + ${rageDmg}`;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tactor.update(obj);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (!noRage) {\n\t\t\t// toggle rage icon, if rage path is defined above\n\t\t\t(async () => { \n\t\t\t\ttoggleResult = await token.toggleEffect(rageIconPath);\n\t\t\t\tif (toggleResult == enabled) token.toggleEffect(rageIconPath);  \n\t\t\t})();\n\t\t\t\n\t\t\t//toggle macro icon and name, if macro name is correct and stop rage icon path is defined\n\t\t\tlet rageMacro = game.macros.getName(rageMacroName);\n\t\t\t\t//check for name of macro in its \"off\" form\n\t\t\t\tif (rageMacro == null || rageMacro == undefined) {\n\t\t\t\t\trageMacro = game.macros.getName('Stop ' + rageMacroName);\n\t\t\t\t}\n\t\t\tlet obj = {};\n\t\t\tif ( (rageMacro !== null && rageMacro !== undefined) && toggleMacro == true && \n\t\t\t\t\t+ (stopRageIconPath !== null && stopRageIconPath !== undefined && stopRageIconPath !== '') ) {\n\t\t\t\tif (enabled) {\n\t\t\t\t  obj['img'] = rageIconPath;\n\t\t\t\t  obj['name'] = rageMacroName;\n\t\t\t\t} else {\n\t\t\t\t  obj['img'] = stopRageIconPath;\n\t\t\t\t  obj['name'] = 'Stop ' + rageMacroName;\n\t\t\t\t}\n\t\t\t\trageMacro.update(obj);\n\t\t\t} else {\n\t\t\tif (toggleMacro == true) ui.notifications.warn(\"Rage macro named \" + `${rageMacroName}` + \" not found. Rage toggle successful but unable to toggle macro icon.\");\n\t\t\t}\t\n\t\t}\n\t}\n} else ui.notifications.warn(\"Please select a token.\");\n// write to chat if needed:\nif (chatMsg !== '') {\n\tlet chatData = {\n\t\tuser: game.user._id,\n\t\tspeaker: ChatMessage.getSpeaker(),\n\t\tcontent: chatMsg\n\t};\n\tChatMessage.create(chatData, {});\n}\n","author":"y5gmtwxmW3A5ZuOP","img":"icons/svg/dice-target.svg","actorIds":[]}
{"_id":"p0KlDQ5Ab2IIsNJY","name":"Link Actors","permission":{"default":0,"y5gmtwxmW3A5ZuOP":3},"type":"script","flags":{},"scope":"global","command":"const scene = game.scenes.active;\nconst unlinked = canvas.scene.data.tokens.map(t => {\n    const actor = game.actors.entities.find(a => a.name === t.name);\n    if (actor) {\n        return {\n            _id: t._id,\n            actorId: actor.id\n        }\n    } else {\n        console.log(t.name);\n        return {\n            _id: t._id,\n            actorId: \"\"\n        }\n    }\n});\nconst updates = duplicate(unlinked);\n\nscene.updateEmbeddedEntity(\"Token\", updates);\n\nui.notifications.info('Tokens linked to actors.');\nconsole.log(updates);","author":"y5gmtwxmW3A5ZuOP","img":"icons/svg/dice-target.svg","actorIds":[]}
{"_id":"zKbQ7lPYQC96DlIS","name":"Monk Ki","permission":{"default":0,"y5gmtwxmW3A5ZuOP":3},"type":"script","flags":{},"scope":"global","command":"/**\n * Monk Ki Point spender\n * \n * This macro will prompt which Feature you want to spend Ki points on.\n * \n * Flurry of Blows: Automatically cast two Unarmed Strike's\n * Stunning Strike: Automatically show the saving throw DC\n * Deflect Missiles: Automatically show the damage reduction\n */\n(async () => {\n    const kiName = \"Ki Points\";\n    const errNoMonkToken = \"Please select a single monk token.\";\n\n    const sendChat = async (msg) => {\n        let chatData = {\n            user: game.user.id,\n            speaker: ChatMessage.getSpeaker(),\n            content: msg,\n        };\n        ChatMessage.create(chatData, {});\n    }\n\n    if (!actor) {\n        ui.notifications.warn(errNoMonkToken);\n        return\n    }\n\n    let monk = actor.items.find(i => i.name === 'Monk' && i.type === 'class');\n    if (!monk) {\n        ui.notifications.warn(errNoMonkToken);\n        return\n    }\n\n    let monkLevels = monk.data.data.levels || 20;\n    //let subClass = monk.data.data.subclass;\n\n    if (monkLevels < 2) {\n        ui.notifications.warn('You must have a least 2 Monk levels to use ki points.');\n        return\n    }\n\n    class KiFeature {\n        /**\n         * @param {string} name\n         * @param {string} fallbackText\n         * @param {number} requireLevel\n         * @param {function} action\n         * @param {function} appendTemplate\n         * @param {number} kiCost\n         */\n        constructor(name, fallbackText, requireLevel, action, appendTemplate, kiCost) {\n            this.name = name;\n            this.fallbackText = fallbackText;\n            this.requireLevel = requireLevel;\n            this.kiCost = kiCost || 1;\n            if (action) {\n                this.action = action;\n            }\n            if (appendTemplate) {\n                this.appendTemplate = appendTemplate;\n            }\n        }\n\n        render(allowHigher) {\n            let entry = null;\n\n            const pack = game.packs.get(\"dnd5e.classfeatures\");\n            if (!pack) {\n                console.warn('Could not find \"dnd5e.classfeatures\" compendium.');\n            } else {\n                entry = pack.index.find(e => e.name === this.name);\n            }\n\n            if (!allowHigher && this.requireLevel && monkLevels && this.requireLevel > monkLevels) {\n                ui.notifications.warn(`You need to have ${this.requireLevel} monk levels, you only have ${monkLevels}.`)\n                return\n            }\n\n            if (entry) {\n                pack.getEntity(entry._id).then(o => {\n                    let template = `@Compendium[dnd5e.classfeatures.${entry._id}]{${this.name}}\n                    ${o.data.data.description.value}`;\n                    if (this.appendTemplate) {\n                        template += '\\n\\n' + this.appendTemplate();\n                    }\n                    sendChat(template);\n                    if (this.action) {\n                        this.action();\n                    }\n                });\n            } else {\n                console.warn(`Could not find \"${this.name}\" entry in compendium.`);\n                let template = this.fallbackText;\n                if (this.appendTemplate) {\n                    template += '\\n\\n' + this.appendTemplate();\n                }\n                sendChat(template);\n                if (this.action) {\n                    this.action();\n                }\n            }\n        }\n    }\n\n   const openHand = !!actor.items.find(o => o.data.name === 'Open Hand Technique') ? `<br />In addition, you can impose one of the following: <ul><li>It must succeed on a <b>Dexterity</b> saving throw or be knocked prone.</li><li>It must make a <b>Strength</b> saving throw. If it fails, you can push it up to 15 feet away from you.</li><li>It can’t take reactions until the end of your next turn.</li></ul> Saving throw <b>DC ${10 + actor.data.data.abilities.wis.mod}</b>` : \"\";\n\n    const features = [\n        new KiFeature(\"Ki: Flurry of Blows\",\n            `Immediately after you take the <b>Attack</b> action on your turn, you can spend 1 ki point to make two unarmed strikes as a bonus action. ${openHand}`,\n            2,\n            function () {\n                // Automatically roll two Unarmed Strike attacks\n                let strike = actor.items.find(o => o.data.name === 'Unarmed Strike' && o.data.labels.activation === '1 Action')\n                if (strike) {\n                    strike.roll();\n                    strike.roll();\n                }\n            }),\n        new KiFeature(\"Ki: Patient Defense\",\n            \"You can spend 1 ki point to take the <b>Dodge</b> action as a bonus action on your turn.\",\n            2),\n        new KiFeature(\"Ki: Step of the Wind\",\n            \"You can spend 1 ki point to take the <b>Disengage</b> or <b>Dash</b> action as a bonus action on your turn, and your jump distance is doubled for the turn.\",\n            2),\n        new KiFeature(\"Deflect Missiles\",\n            `Starting at 3rd level, you can use your reaction to deflect or catch the missile when you are hit by a ranged weapon attack. When you do so, the damage you take from the attack is reduced by 1d10 + your Dexterity modifier + your monk level. <br />\n\n        If you reduce the damage to 0, you can catch the missile if it is small enough for you to hold in one hand and you have at least one hand free. If you catch a missile in this way, you can spend 1 ki point to make a ranged attack with the weapon or piece of ammunition you just caught, as part of the same reaction. You make this attack with proficiency, regardless of your weapon proficiencies, and the missile counts as a monk weapon for the attack, which has a normal range of 20 feet and a long range of 60 feet.`,\n            3,\n            null,\n            function () {\n                return `Damage reduction: [[/r 1d10+${actor.data.data.abilities.dex.mod}+${monkLevels}]]`;\n            }),\n        new KiFeature(\"Ki: Stunning Strike\",\n            \"Starting at 5th level, you can interfere with the flow of ki in an opponent’s body. When you hit another creature with a melee weapon attack, you can spend 1 ki point to attempt a stunning strike. The target must succeed on a Constitution saving throw or be <b>stunned</b> until the end of your next turn.\",\n            5,\n            null,\n            function () {\n                // Append the saving throw DC to the chat message\n                return `CON saving throw (DC [[8+${actor.data.data.abilities.wis.mod}+@attributes.prof]])`;\n            }),\n        new KiFeature(\"Ki: Diamond Soul\",\n            `Beginning at 14th level, your mastery of ki grants you proficiency in all saving throws.\n\n        Additionally, whenever you make a saving throw and fail, you can spend 1 ki point to reroll it and take the second result.`,\n            14),\n        new KiFeature(\"Ki: Empty Body\",\n            `Beginning at 18th level, you can use your action to spend 4 ki points to become invisible for 1 minute. During that time, you also have resistance to all damage but force damage.\n\n        Additionally, you can spend 8 ki points to cast the astral projection spell, without needing material components. When you do so, you can’t take any other creatures with you.`,\n            18,\n            null,\n            function () {\n                return \"Note: 4 ki points have been spent. Adjust manually if casting astral projection spell.\";\n            },\n            4),\n    ];\n\n    const consumeKi = (feature, allowNegative, allowHigher) => {\n        let hasAvailableResource = false;\n        let selected = features.find(o => o.name == feature);\n        let kiCost = selected.kiCost || 1;\n\n        // Look for Resources under the Core actor data\n        let resourceKey = Object.keys(actor.data.data.resources).filter(k => actor.data.data.resources[k].label === kiName).shift();\n        if (resourceKey && (actor.data.data.resources[resourceKey].value >= kiCost || allowNegative)) {\n            hasAvailableResource = true;\n            actor.data.data.resources[resourceKey].value -= kiCost;\n        }\n\n        // Look for Ki Points Feat that has uses\n        actor.items.filter(i => i.data.name === kiName && i.data.hasUses && (i.data.data.uses.value >= kiCost || allowNegative)).forEach(i => {\n            hasAvailableResource = true;\n            i.data.data.uses.value -= kiCost\n        })\n\n        if (!hasAvailableResource) {\n            ui.notifications.warn(`${actor.name} does not have any ${kiName} left!`);\n            return false;\n        }\n        if (actor.sheet.rendered) {\n            // Update the actor sheet if it is currently open\n            actor.render(true);\n        }\n\n        if (selected) {\n            selected.render(allowHigher);\n        }\n\n        return true;\n    };\n\n    (async () => {\n        let template = `\n        <form>\n            <div class=\"form-group\">\n                <label>Select feature:</label>\n                <select id=\"feature\" name=\"feature\">`\n        features.filter(o => o.requireLevel <= monkLevels).forEach(o => {\n            template += `<option value=\"${o.name}\">${o.name}</option>`;\n        });\n        template += `</select>\n            </div>\n            <div class=\"form-group\">\n                <label>Allow consuming Ki into negative? <input type=\"checkbox\" id=\"allow-negative\" name=\"allow-negative\" value=\"1\"></label>\n            </div>\n            <div class=\"form-group\">\n                <label>Allow consuming Ki feats of higher level? <input type=\"checkbox\" id=\"allow-higher\" name=\"allow-higher\" value=\"1\"></label>\n            </div>\n        </form>`;\n        new Dialog({\n            title: `Monk Ki Point Spender`,\n            content: template,\n            buttons: {\n                yes: {\n                    icon: \"<i class='fas fa-check'></i>\",\n                    label: `Apply`,\n                    callback: (html) => {\n                        let feature = html.find('#feature')[0].value;\n                        let allowNegative = html.find('#allow-negative')[0].checked;\n                        let allowHigher = html.find('#allow-higher')[0].checked;\n                        consumeKi(feature, allowNegative, allowHigher);\n                    }\n                },\n                no: {\n                    icon: \"<i class='fas fa-times'></i>\",\n                    label: `Cancel`\n                },\n            },\n            default: \"yes\"\n        }).render(true);\n    })();\n})()\n","author":"y5gmtwxmW3A5ZuOP","img":"icons/svg/dice-target.svg","actorIds":[]}
{"name":"Sneak Attack","permission":{"default":0,"y5gmtwxmW3A5ZuOP":3},"type":"script","flags":{},"scope":"global","command":"//\t\tDISCLAIMER:\t\tThis macro is heavily based on the original D&D 5e Rage Macro masterwork written by Felix#6196.\n//\t\t\t\t\t\tNorc#5108 created and is maintaining this macro.\n//\n//\t\t\t\t\t\tUpdates:\t1.\t2020/06/05: Initial version.\n\n//!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n//!!!\tBonus Tip: Sneak Attack as a Condition                                                                                                                       \n//!!!\tIf you use the Combat Utility Belt module's Condition Lab, try adding a condition called \"Sneaky\" with the same icon \t\t\t   \n//!!!\tas the optional sneak attack icon overlay, 'icons/svg/mystery-man-black.svg' by default.  See EXPERIMENTAL MACRO ICON/NAME TOGGLE below.\n//!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n\n//!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n//!!!   OPTIONAL TOKEN ICON-\tOn by default. If a path to a sneak attack icon is defined, it displays like a condition on the sneaking rogue.\n//!!!\t\t\t\t\t\t\tTo use a different icon, manually change the filepath below or leave it empty ('') to disable the effect.\n//!!!\nconst sneakIconPath = 'icons/svg/mystery-man-black.svg';\n//!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n\n//!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n//!!!\tEXPERIMENTAL MACRO ICON/NAME TOGGLE\t\tIf enabled, the macro icon and name toggles based on whether the rogue is currently sneaking. \n//!!!\t\t\t\t\t\t\t\t\t\t\tCAUTIONS: \t1. \tThis feature is off by default and is intended for ADVANCED USERS ONLY. \n//!!!\t\t\t\t\t\t\t\t\t\t\t\t\t\t2. \tRequires configuration using \"The Furnace\" module for a player to run!\n//!!!\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tThe GM needs to grant The Furnace's \"Run as GM\" permission for this macro.\n//!!!\t\t\t\t\t\t\t\t\t\t\t\t\t\t3. \tWorks best with only one rogue using this feature at a time.\n\n\t\t\t\t//To auto-toggle the macro's icon/name, override toggleMacro to true below.\n\t\t\t\tconst toggleMacro = false;\n\n\t\t\t\t//To use a different icon, manually change the filepath here\n\t\t\t\tconst stopSneakIconPath = 'icons/svg/cowled.svg';\n\n\t\t\t\t//You must update the following constant to this macro's exact name for the macro icon toggling to work.\n\t\t\t\tconst sneakMacroName = 'Sneak Attack';\n//!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n\nlet toggleResult = false;\nlet enabled = false;\nlet errorReason = '';\nlet sneakAttack = {};\nlet rogue = {};\nlet rogueLvls = 0;\nlet sneakDice = 0;\nlet chatMsg = '';\nlet oldMDmg = '';\nlet oldRDmg = '';\n\nlet macroActor = actor;\nlet macroToken = token;\n\n//!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n//!!!\tBASIC LOCALIZATION SUPPORT\t\t\t\tSets names of D&D5E features as constants instead of hardcoding to allow easier translation.\n//!!!\t\t\t\t\t\t\t\t\t\t\tSets error messages as constants also for easier translation.\n\n\t\t\t\tconst rogueClassName = 'Rogue';\n\t\t\t\tconst sneakAttackFeatureName = 'Sneak Attack';\n\n\t\t\t\tconst errorSelectRogue = 'Please select a single rogue token.';\n\t\t\t\tconst warnMacroNotFound = ' is not a valid macro name, please fix. Sneak attack toggle successful but unable to alter macro.';\n\t\t\t\tconst errorSelectToken = 'Please select a token.';\n//!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n\n\n//check to ensure token is selected and attempt to define the sneak attack feature\nif (macroActor !== null && macroActor !== undefined) {\n\tsneakAttack = macroActor.items.find(i => i.name == `${sneakAttackFeatureName}`);\n} else {\nerrorReason = `${errorSelectToken}`;\n}\n\n//check to ensure token is a rogue\nif (errorReason == '' && macroActor.items.find(i => i.name == `${rogueClassName}`) !== undefined) {\n\trogue = macroActor.items.find(i => i.name == `${rogueClassName}`);\n} else {\n\terrorReason = `${errorSelectRogue}`;\n}\n\nconsole.log(`Error reason is: ${errorReason}`);\n//main execution now that errors are caught\n\nif (errorReason == '') {\n\t\n\tchatMsg = '';\n\tlet enabled = false;\n\t// store the state of the sneak attack toggle in flags\n\tif (macroActor.data.flags.sneakMacro !== null && macroActor.data.flags.sneakMacro !== undefined) {\n\t\tenabled = true;\n\t}\n\t\n\t// if sneak attack is active, disable it\n\tif (enabled) {\n\t\tchatMsg = `${macroActor.name} is no longer sneak attacking.`;\n\t\t// ranged and melee weapon attack bonus\n\t\tlet obj = {};\n\t\tobj['flags.sneakMacro'] = null;\t\t\n\t\tobj['data.bonuses.mwak.damage'] = macroActor.data.flags.sneakMacro.oldMDmg;\t\t\t\n\t\tobj['data.bonuses.rwak.damage'] = macroActor.data.flags.sneakMacro.oldRDmg;\t\n\t\tmacroActor.update(obj);\n\t\t\n\t// if sneak attack is disabled, enable it\n\t} else {\t\t\n\t\tchatMsg = `${macroActor.name} starts sneak attacking!`;\n\t\t\n\t\tlet obj = {};\n\t\tobj['flags.sneakMacro.enabled'] = true;\n\n\t\t// Preserve old mwak damage bonus if there was one\n\t\tlet oldMDmg = macroActor.data.data.bonuses.mwak.damage;\n\t\tif (oldMDmg==null || oldMDmg == undefined || oldMDmg == '') oldMDmg = 0;\n\t\tobj['flags.sneakMacro.oldMDmg'] = JSON.parse(JSON.stringify(oldMDmg));\n\n\t\t// Preserve old rwak damage bonus if there was one\n\t\tlet oldRDmg = macroActor.data.data.bonuses.rwak.damage;\n\t\tif (oldRDmg==null || oldRDmg == undefined || oldRDmg == '') oldRDmg = 0;\n\t\tobj['flags.sneakMacro.oldRDmg'] = JSON.parse(JSON.stringify(oldRDmg));\n\n\t\t\n\t\t// Determining the rogue level\n\t\trogueLvls = rogue.data.data.levels;\n\n\t\t// Formula to determine the sneak attack damage depending on rogue level\t\n\t\tsneakDice = Math.ceil(rogueLvls/2);\n\t\n\t\t//actually add the bonus sneak attack damage to the previous bonus damage\n\t\t//respect roll formulas if present.\n\t\tif (oldMDmg==null || oldMDmg == undefined || oldMDmg == '' || oldMDmg == 0) {\n\t\t\tobj['data.bonuses.mwak.damage'] = `${sneakDice}d6`;\n\t\t} else {\n\t\t\tobj['data.bonuses.mwak.damage'] = `${oldMDmg} + ${sneakDice}d6`;\n\t\t}\n\n\t\tif (oldRDmg==null || oldRDmg == undefined || oldRDmg == '' || oldRDmg == 0) {\n\t\t\tobj['data.bonuses.rwak.damage'] = `${sneakDice}d6`;\n\t\t} else {\n\t\t\tobj['data.bonuses.rwak.damage'] = `${oldRDmg} + ${sneakDice}d6`;\n\t\t}\t\n\n\t\tmacroActor.update(obj);\n\n\t}\t\n\t\n\t//mark or unmark character's token with Sneaky effect icon, if sneakIconPath is defined\n\t(async () => { \n\t\ttoggleResult = await macroToken.toggleEffect(sneakIconPath);\n\t\tif (toggleResult == enabled) macroToken.toggleEffect(sneakIconPath);  \n\t})();\n\n\t//toggle macro icon and name, if enabled\n\tif (toggleMacro) {\n//\t\tNorc's preferred icons, not sure if publicly available\n//\t\tsneakyMacroImgPath = 'systems/dnd5e/icons/skills/shadow_17.jpg';\n//\t\tstopSneakIconPath = 'systems/dnd5e/icons/skills/yellow_11.jpg';\n\t\tlet sneakMacro = game.macros.getName(sneakMacroName);\n\t\t\t//Also check for name of macro in its \"off\" form\n\t\t\tif (sneakMacro == null || sneakMacro == undefined) {\n\t\t\t\tsneakMacro = game.macros.getName('Stop ' + sneakMacroName);\n\t\t\t}\n\t\tlet obj = {};\n\t\tif ( (sneakMacro !== null && sneakMacro !== undefined) && \n\t\t\t\t+ (stopSneakIconPath !== null && stopSneakIconPath !== undefined && stopSneakIconPath !== '') ) {\n\t\t\tif (enabled) {\n\t\t\tobj['img'] = sneakIconPath;\n\t\t\tobj['name'] = sneakMacroName;\n\t\t\t} else {\n\t\t\tobj['img'] = stopSneakIconPath;\n\t\t\tobj['name'] = 'Stop ' + sneakMacroName;\n\t\t\t}\n\t\t\tsneakMacro.update(obj);\n\t\t} else {\n\t\tui.notifications.warn(`${sneakMacroName} ${warnMacroNotFound}`);\t\t\t\n\t\t}\n\t}\n\n} else {\nui.notifications.error(`${errorReason}`);\t\n}\nif (chatMsg !== '') {\n\tlet chatData = {\n\t\tuser: game.user._id,\n\t\tspeaker: ChatMessage.getSpeaker(),\n\t\tcontent: chatMsg\n\t};\n\tChatMessage.create(chatData, {});\n}","author":"y5gmtwxmW3A5ZuOP","img":"icons/svg/dice-target.svg","actorIds":[],"_id":"B8xBTAEQl4PqxzXF"}
{"_id":"hW29VmM09DenDXNz","name":"Rage","permission":{"default":0,"y5gmtwxmW3A5ZuOP":3},"type":"script","flags":{},"scope":"global","command":"//\t\tDISCLAIMER:\t\tThis macro is an evolved version of the original D&D 5e Rage Macro masterwork written by Felix#6196.\n//\t\t\t\t\t\tNorc#5108 is now maintaining this macro along with continued support from Felix.\n//\n//\n//\t\tUpdates:\t\t1. \tFixed errors resulting from declarations of \"actor\" and \"token\" in a script macro. \n//\t\t\t\t\t\t2. \tAdded automatic Totem Spirit: Bear detection and resistance application \n//\t\t\t\t\t\t\tPLEASE NOTE: A minor update to the Totem Spirit item's name in the character sheet is needed if \n//\t\t\t\t\t\t\tthe VTTA Beyond Integration was not used to create sheet. See Bonus Tip 1 below\n//\t\t\t\t\t\t3. \tAdded error messages for trying to rage with no token or no barbarian selected\n//\t\t\t\t\t\t4. \t(Felix) added resource/usage deduction and errors (re-added after accidentally overwriting the addition) \n//\t\t\t\t\t\t5. \t(Felix, 2020/05/29) Fixed rage damage at level 8\n//\t\t\t\t\t\t6. \t(2020/05/30) Implemented Felix's idea to use global melee weapon attack bonus instead of modifying items\n//\t\t\t\t\t\t7. \t(2020/05/30) Improved Rage icon toggling to be more reliable\n//\t\t\t\t\t\t8. \t(2020/05/30) Removed code from the resource management that created dependency on The Furnace Advanced Macros\n//\t\t\t\t\t\t9. \t(2020/05/30) Implemented Felix's fix for issue where new resistances and rage uses were not saving properly\n//\t\t\t\t\t\t10.\t(2020/05/30) Fixed rage damage formula again...\n//\t\t\t\t\t\t11.\t(2020/05/30) Added basic support for non-strength Based barbarians (Dex, Hexblade)\n//\t\t\t\t\t\t12.\t(2020/05/30) Added optional ability to toggle the icon and name of the macro itself based on current raging state.\n//\t\t\t\t\t\t13. (2020/06/04) Fixed bug with experimental macro name/icon toggle only by renaming \"actor\" and \"token\"\n//\t\t\t\t\t\t14. (2020/06/04) Added basic localization support for messages and to allow searching for translated class features\n\n//!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n//!!!\tBonus Tip 1: Bear Totem Spirit Barbs\n//!!!\tIf you chose the Spirit Seeker Primal path, and at level 3 you chose the Bear Totem Spirit (resistance to all non-psychic damage), \n//!!!\tin your 5E character sheet, double-check that the name of your Totem Spirit feature to EXACTLY \"Totem Spirit: Bear\".  Note: Importing\n//!!!\tvia VTTA Beyond Integration uses this name already. The macro then automatically adds the extra Bear Totem Spirit resistances.\n//!!!\n//!!!\tBonus Tip 2: Thrown Weapons\n//!!!\tWhen a barb throws a weapon using strength, typically a javelin but also possibly a dagger, dart, sword, bar table etc, the rage bonus\n//!!!\tshould not be added because it is a ranged attack. However, D&D5E calls javelins and daggers Melee Weapons, because technically they\n//!!!\tare both. To solve this issue, if you always throw the weapon, click the weapon's details and change the attack type to \"Ranged Weapon\n//!!!\tAttack\" in the Action Type dropdown. If you want, you can add a second copy of the item (with no weight/quantity) to use for meleeing.\n//!!!\n//!!!\tBonus Tip 3: The Rage Condition                                                                                                                       \n//!!!\tIf you use the Combat Utility Belt module's Condition Lab, try adding a condition called \"Raging\" with the same icon \t\t\t   \n//!!!\tas the optional rage icon overlay, 'icons/svg/explosion.svg' by default.  See EXPERIMENTAL MACRO ICON/NAME TOGGLE section below.\n//!!!\n//!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n\n//!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n//!!!   OPTIONAL TOKEN ICON-\tOn by default. If a path to a rage icon is defined, it displays like a condition on the raging barbarian.\n//!!!\t\t\t\t\t\t\tTo use a different icon, manually change the filepath below or leave it empty ('') to disable the effect.\n//!!!\nconst rageIconPath = 'icons/svg/explosion.svg';\n//!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n\n//!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n//!!!   OPTIONAL RESOURCE DEDUCTION \tOn by default. First option automatically subtracts from the Rage Resource if enabled.\n//!!!\t\t\t\t\t\t\t\t\tSecond option prevents raging if no Rage resource is left. Set to false if you do not want this.\n\n\t\t\t\tconst deductResource = true;\n\t\t\t\tconst preventNegativeResource = true;\n//!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n\n//!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n//!!!   OPTIONAL NON-STRENGTH BARBARIAN SUPPORT\t\tONLY override to FALSE if your barbarian does not use Strength to make melee attacks\n//!!!\t\t\t\t\t\t\t\t\t\t\t\tand therefore does not get the Rage bonus to melee weapon attack damage. \n//!!!\t\t\n\t\t\t\tconst strAttacks = true;\n//!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n\n//!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n//!!!\tEXPERIMENTAL MACRO ICON/NAME TOGGLE\t\tIf enabled, the macro icon and name toggles based on the barbarian's rage state. \n//!!!\t\t\t\t\t\t\t\t\t\t\tCAUTIONS: \t1. \tThis feature is off by default and is intended for ADVANCED USERS ONLY. \n//!!!\t\t\t\t\t\t\t\t\t\t\t\t\t\t2. \tRequires configuration using \"The Furnace\" module for a player to run!\n//!!!\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tThe GM needs to grant The Furnace's \"Run as GM\" permission for this macro.\n//!!!\t\t\t\t\t\t\t\t\t\t\t\t\t\t3. \tWorks best with only one barbarian using this feature at a time.\n\n\t\t\t\t//To auto-toggle the macro's icon/name, override toggleMacro to true below.\n\t\t\t\tconst toggleMacro = false;\n\n\t\t\t\t//To use a different icon, manually change the filepath here\n\t\t\t\tconst stopRageIconPath = 'icons/svg/unconscious.svg';\n\n\t\t\t\t//You must update the following constant to this macro's exact name for the macro icon toggling to work.\n\t\t\t\tconst rageMacroName = 'Rage';\n//!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n\n//declarations\nlet barb = '';\nlet chatMsg = '';\nlet bear = '';\nlet noRage = false;\nlet toggleResult = false;\nlet macroActor = actor;\nlet macroToken = token;\n\n//!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n//!!!\tBASIC LOCALIZATION SUPPORT\t\t\t\tSets names of D&D5E features as constants instead of hardcoding to allow easier translation.\n//!!!\t\t\t\t\t\t\t\t\t\t\tSets error messages as constants also for easier translation.\nconst barbClassName = 'Barbarian';\nconst rageFeatureName = 'Rage';\nconst bearTotemFeatureName = 'Totem Spirit: Bear';\n\nconst errorSelectBarbarian = 'Please select a single barbarian token.';;\nconst errorNoRage = ' does not have any rage left, time for a long rest!';\nconst warnMacroNotFound = ' is not a valid macro name, please fix. Rage toggle successful but unable to alter macro.';\nconst errorSelectToken = 'Please select a token.';\n//!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n\n\n//main\n//check to see if Actor exists and is a barbarian\nif (macroActor !== undefined && macroActor !== null) {\n\t\t\t\t\n\t// get the barbarian class item\n\tbarb = macroActor.items.find(i => i.name === `${barbClassName}`);\n\tif (barb == undefined) {\n\t\tui.notifications.warn(`${errorSelectBarbarian}`);\n\t}\n\tif (barb !== undefined && barb !== null) {\n\t\tchatMsg = '';\n\t\tlet enabled = false;\n\t\t// store the state of the rage toggle in flags\n\t\tif (macroActor.data.flags.rageMacro !== null && macroActor.data.flags.rageMacro !== undefined) {\n\t\t\tenabled = true;\n\t\t}\n\t\t\n\t\t// if rage is active, disable it\n\t\tif (enabled) {\n\t\t\tchatMsg = `${macroActor.name} is no longer raging.`;\n\t\t\t// reset resistances and melee weapon attack bonus\n\t\t\tlet obj = {};\n\t\t\tobj['flags.rageMacro'] = null;\n\t\t\tobj['data.traits.dr'] = macroActor.data.flags.rageMacro.oldResistances;\t\t\n\t\t\tobj['data.bonuses.mwak.damage'] = macroActor.data.flags.rageMacro.oldDmg;\t\n\t\t\tmacroActor.update(obj);\n\t\t\t\n\t\t// if rage is disabled, enable it\n\t\t} else {\n\t\t\tif (deductResource) {\n\t\t\t\tlet hasAvailableResource = false;\n\t\t\t\tlet newResources = duplicate(macroActor.data.data.resources)\t\t\t\t\n\t\t\t\tlet obj = {}\n\t\t\t\t// Look for Resources under the Core macroActor data\n\t\t\t\tlet resourceKey = Object.keys(macroActor.data.data.resources).filter(k => macroActor.data.data.resources[k].label === `${rageFeatureName}`).shift();\n\t\t\t\tif (resourceKey && (macroActor.data.data.resources[resourceKey].value > 0 || !preventNegativeResource)) {\n\t\t\t\t\thasAvailableResource = true;\n\t\t\t\t\tnewResources[resourceKey].value--;\t\t\t\t\t\n\t\t\t\t\tobj['data.resources'] = newResources \n\t\t\t\t\tmacroActor.update(obj);\n\t\t\t\t}\n\t\t\t\tif (!hasAvailableResource) {\n\t\t\t\t\tui.notifications.error(`${macroActor.name} ${errorNoRage}`);\n\t\t\t\t\tnoRage=true;\n\t\t\t\t}\n\t\t\t\tif (macroActor.sheet.rendered) {\n\t\t\t\t\t// Update the macroActor sheet if it is currently open\n\t\t\t\t\tmacroActor.render(true);\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t//activate rage if there is rage available, or if it is okay to rage with 0 resources\n\t\t\tif (!noRage) {\n\t\t\t\tchatMsg = `${macroActor.name} is RAAAAAGING!`;\n\t\t\t\t// update resistance\n\t\t\t\tlet obj = {};\n\t\t\t\t// storing old resistances in flags to restore later\n\t\t\t\tobj['flags.rageMacro.enabled'] = true;\n\t\t\t\tobj['flags.rageMacro.oldResistances'] = JSON.parse(JSON.stringify(macroActor.data.data.traits.dr));\n\t\t\t\t// add bludgeoning, piercing and slashing resistance\n\t\t\t\tlet newResistance = duplicate(macroActor.data.data.traits.dr);\n\t\t\t\tif (newResistance.value.indexOf('bludgeoning') === -1) newResistance.value.push('bludgeoning');\n\t\t\t\tif (newResistance.value.indexOf('piercing') === -1) newResistance.value.push('piercing');\n\t\t\t\tif (newResistance.value.indexOf('slashing') === -1) newResistance.value.push('slashing');\n\t\t\t\t//If bear totem, add bear totem resistances.\n\t\t\t\tbear = macroActor.items.find(i => i.name === `${bearTotemFeatureName}`)\n\t\t\t\tif (bear !== undefined && bear!== null) {\n\t\t\t\t\tif (newResistance.value.indexOf('acid') === -1) newResistance.value.push('acid');\n\t\t\t\t\tif (newResistance.value.indexOf('cold') === -1) newResistance.value.push('cold');\n\t\t\t\t\tif (newResistance.value.indexOf('fire') === -1) newResistance.value.push('fire');\n\t\t\t\t\tif (newResistance.value.indexOf('force') === -1) newResistance.value.push('force');\n\t\t\t\t\tif (newResistance.value.indexOf('lightning') === -1) newResistance.value.push('lightning');\n\t\t\t\t\tif (newResistance.value.indexOf('necrotic') === -1) newResistance.value.push('necrotic');\n\t\t\t\t\tif (newResistance.value.indexOf('poison') === -1) newResistance.value.push('poison');\n\t\t\t\t\tif (newResistance.value.indexOf('radiant') === -1) newResistance.value.push('radiant');\n\t\t\t\t\tif (newResistance.value.indexOf('thunder') === -1) newResistance.value.push('thunder');\n\t\t\t\t}\n\t\t\t\tobj['data.traits.dr'] = newResistance;\n\t\t\t\tmacroActor.update(obj);\n\t\t\t\n\t\t\t\t// For Strength barbarians, update global melee weapon attack bonus to include rage bonus\n\t\t\t\tif (strAttacks) {\n\t\t\t\t\t// Preserve old mwak damage bonus if there was one\n\t\t\t\t\tlet dmg = macroActor.data.data.bonuses.mwak.damage;\n\t\t\t\t\tif (dmg==null || dmg == undefined || dmg == '') dmg = 0;\n\t\t\t\t\tobj['flags.rageMacro.oldDmg'] = JSON.parse(JSON.stringify(dmg));\n\t\t\t\n\t\t\t\t\t// Determining the barbarian level\n\t\t\t\t\tlet barblvl = barb.data.data.levels;\n\t\t\t\n\t\t\t\t\t// Formula to determine the rage bonus damage depending on barbarian level\n\t\t\t\t\tlet lvlCorrection =  barblvl === 16 || barblvl === 17 ? 1 : 0;\n\t\t\t\t\tlet rageDmg = 2 + Math.floor(barblvl / 9) + lvlCorrection;\n\t\t\t\t\n\t\t\t\t\t//actually add the bonus rage damage to the previous bonus damage\n\t\t\t\t\t//respect roll formulas if present.\n\t\t\t\t\tif (parseInt(dmg) == dmg) {\n\t\t\t\t\t\tobj['data.bonuses.mwak.damage'] = parseInt(dmg) + rageDmg;\n\t\t\t\t\t} else {\n\t\t\t\t\tobj['data.bonuses.mwak.damage'] = `${dmg} + ${rageDmg}`;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tmacroActor.update(obj);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (!noRage) {\n\t\t\t// toggle rage icon, if rage path is defined above\n\t\t\t(async () => { \n\t\t\t\ttoggleResult = await macroToken.toggleEffect(rageIconPath);\n\t\t\t\tif (toggleResult == enabled) macroToken.toggleEffect(rageIconPath);  \n\t\t\t})();\n\t\t\t\n\t\t\t//toggle macro icon and name, if macro name is correct and stop rage icon path is defined\n\t\t\tlet rageMacro = game.macros.getName(rageMacroName);\n\t\t\t\t//check for name of macro in its \"off\" form\n\t\t\t\tif (rageMacro == null || rageMacro == undefined) {\n\t\t\t\t\trageMacro = game.macros.getName('Stop ' + rageMacroName);\n\t\t\t\t}\n\t\t\tlet obj = {};\n\t\t\tif ( (rageMacro !== null && rageMacro !== undefined) && toggleMacro == true && \n\t\t\t\t\t+ (stopRageIconPath !== null && stopRageIconPath !== undefined && stopRageIconPath !== '') ) {\n\t\t\t\tif (enabled) {\n\t\t\t\t  obj['img'] = rageIconPath;\n\t\t\t\t  obj['name'] = rageMacroName;\n\t\t\t\t} else {\n\t\t\t\t  obj['img'] = stopRageIconPath;\n\t\t\t\t  obj['name'] = 'Stop ' + rageMacroName;\n\t\t\t\t}\n\t\t\t\trageMacro.update(obj);\n\t\t\t} else {\n\t\t\tif (toggleMacro == true) ui.notifications.warn(`${rageMacroName} ${warnMacroNotFound}`);\n\t\t\t}\t\n\t\t}\n\t}\n} else ui.notifications.warn(errorSelectToken);\n// write to chat if needed:\nif (chatMsg !== '') {\n\tlet chatData = {\n\t\tuser: game.user._id,\n\t\tspeaker: ChatMessage.getSpeaker(),\n\t\tcontent: chatMsg\n\t};\n\tChatMessage.create(chatData, {});\n}","author":"y5gmtwxmW3A5ZuOP","img":"icons/svg/dice-target.svg","actorIds":[]}
